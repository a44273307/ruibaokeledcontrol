C51 COMPILER V9.05   LEDCONTROL                                                            06/10/2023 17:34:33 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE LEDCONTROL
OBJECT MODULE PLACED IN ledcontrol.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ledcontrol.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "stc15f2k60s2.h"           // 单片机STC15F2K60S2头文件,可以不再加入reg51.h
   2          #include <intrins.h>                                    // 加入此头文件后,可使用_nop_库函数
   3          #include "delay.h"                      // 延时函数头文件
   4          #include "uart.h"                               // 串行通信函数头文件
   5          #define  uint unsigned int  
   6          #define  uchar unsigned char    
   7          #include <stdio.h>
   8          #include <string.h>
   9          #include "MODBUS.h"
  10          
  11          #include <stdio.h>
  12          #include <string.h>
  13          #include <stdlib.h>
  14          
  15          static bit busy;
  16          
  17          void initiic()
  18          {
  19   1          _push_(P_SW2);
  20   1          P_SW2 |= 0x80;
  21   1          P_SW2 |= 0x08;
  22   1          _pop_(P_SW2);
  23   1      }
  24          void Start()
  25          {uint i=0;
  26   1          busy = 1;
  27   1          I2CMSCR = 0x81;                             //发送START命令
  28   1          while (busy && i < 6000)i++;
  29   1      }
  30          
  31          void SendData(char dat)
  32          {uint i=0;
  33   1          I2CTXD = dat;                               //写数据到数据缓冲区
  34   1          busy = 1;
  35   1          I2CMSCR = 0x82;                             //发送SEND命令
  36   1          while (busy && i < 6000)i++;
  37   1      }
  38          
  39          void RecvACK()
  40          {uint i=0;
  41   1          busy = 1;
  42   1          I2CMSCR = 0x83;                             //发送读ACK命令
  43   1          while (busy && i < 6000)i++;
  44   1      }
  45          
  46          char RecvData()
  47          {uint i=0;
  48   1          busy = 1;
  49   1          I2CMSCR = 0x84;                             //发送RECV命令
  50   1          while (busy && i < 6000)i++;
  51   1          return I2CRXD;
  52   1      }
  53          
  54          void SendACK()
  55          {uint i=0;
C51 COMPILER V9.05   LEDCONTROL                                                            06/10/2023 17:34:33 PAGE 2   

  56   1          I2CMSST = 0x00;                             //设置ACK信号
  57   1          busy = 1;
  58   1          I2CMSCR = 0x85;                             //发送ACK命令
  59   1          while (busy && i < 6000)i++;
  60   1      }
  61          
  62          void SendNAK()
  63          {uint i=0;
  64   1          I2CMSST = 0x01;                             //设置NAK信号
  65   1          busy = 1;
  66   1          I2CMSCR = 0x85;                             //发送ACK命令
  67   1          while (busy && i < 6000)i++;
  68   1      }
  69          
  70          void Stop()
  71          {uint i=0;
  72   1          busy = 1;
  73   1          I2CMSCR = 0x86;                             //发送STOP命令
  74   1          while (busy && i < 6000)i++;
  75   1      }
  76          void I2C_Isr() interrupt 24
  77          {
  78   1          _push_(P_SW2);
  79   1          P_SW2 |= 0x80;
  80   1          if (I2CMSST & 0x40)
  81   1          {
  82   2              I2CMSST &= ~0x40;                       //清中断标志
  83   2              busy = 0;
  84   2          }
  85   1          _pop_(P_SW2);
  86   1      }
  87          
  88          void deanyanpre()
  89           {  
  90   1        uint sw1=2047;
  91   1        uint sw2=3000;
  92   1        sw1=HoldingReg[3];
  93   1        sw2=HoldingReg[4];
  94   1      //   printf("***%d-%d***\n",sw2/256,sw2%256);
  95   1        Start();        // 发送起始命令
  96   1        SendData(0xc2); // 发送设备地址+写命令
  97   1        RecvACK();
  98   1        SendData(0x60); // 发送存储地址高字节
  99   1        RecvACK();
 100   1        SendData(sw1 / 16); // 发送存储地址低字节
 101   1        RecvACK();
 102   1        SendData((sw1 % 16) << 4); // 写测试数据1
 103   1        RecvACK();
 104   1        Stop(); // 发送停止命令
 105   1      
 106   1        Start();        // 发送起始命令
 107   1        SendData(0xc0); // 发送设备地址+写命令
 108   1        RecvACK();
 109   1        SendData(0x60); // 发送存储地址高字节
 110   1        RecvACK();
 111   1        SendData(sw2 / 16); // 发送存储地址低字节
 112   1        RecvACK();
 113   1        SendData((sw2 % 16) << 4); // 写测试数据1
 114   1        RecvACK();
 115   1        Stop();
 116   1      
 117   1        Start();        // 发送起始命令
C51 COMPILER V9.05   LEDCONTROL                                                            06/10/2023 17:34:33 PAGE 3   

 118   1        SendData(0xc2); // 发送设备地址+写命令
 119   1        RecvACK();
 120   1        SendData(0x60); // 发送存储地址高字节
 121   1        RecvACK();
 122   1        SendData(sw1 / 16); // 发送存储地址低字节
 123   1        RecvACK();
 124   1        SendData((sw1 % 16) << 4); // 写测试数据1
 125   1        RecvACK();
 126   1        Stop(); // 发送停止命令
 127   1      
 128   1        Start();        // 发送起始命令
 129   1        SendData(0xc0); // 发送设备地址+写命令
 130   1        RecvACK();
 131   1        SendData(0x60); // 发送存储地址高字节
 132   1        RecvACK();
 133   1        SendData(sw2 / 16); // 发送存储地址低字节
 134   1        RecvACK();
 135   1        SendData((sw2 % 16) << 4); // 写测试数据1
 136   1        RecvACK();
 137   1        Stop();
 138   1                        
 139   1       }
 140           
 141          sbit led1 = P3 ^ 7;
 142          sbit led2 = P3 ^ 6;
 143           void deanyan()
 144           {
 145   1            deanyanpre();
 146   1       }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    441    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
