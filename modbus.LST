C51 COMPILER V9.05   MODBUS                                                                06/04/2023 16:52:26 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE MODBUS
OBJECT MODULE PLACED IN modbus.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE modbus.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //----------------------------------------------------------------------------//
   2          //´Ë´úÂëÖ»Ö§³Ö×÷ÎªModbus´ÓÕ¾Éè±¸µÄModbus RTUÄ£Ê½
   3          //
   4          //Ö§³ÖµÄ¹¦ÄÜÂë£º
   5          //0x03 ¶Á±£³Ö¼Ä´æÆ÷£¨¶Á¶à¸ö±£³Ö¼Ä´æÆ÷µÄÖµ£¬ÓÐÐ§µØÎ»Îª0-99£©
   6          //0x06 Ð´µ¥¸ö¼Ä´æÆ÷£¨Ð´ÈëÒ»¸ö¼Ä´æÆ÷µÄÖµ£¬ÓÐÐ§µØÖ·Îª0-99£©
   7          //0x10 Ð´¶à¸ö¼Ä´æÆ÷£¨Ð´Èë¶à¸ö¼Ä´æÆ÷µÄÖµ£¬ÓÐÐ§µØÖ·Îª0-99£©
   8          //
   9          //Ö§³ÖµÄÒì³£Âë£º
  10          //0x01 ·Ç·¨¹¦ÄÜÂë£¨²»Ö§³ÖµÄ¹¦ÄÜÂë£©
  11          //0x02 ·Ç·¨Êý¾ÝµØÖ·£¨ÆðÊ¼µØÖ·²»ÔÚÓÐÐ§·¶Î§ÄÚ£©
  12          //0x03 ·Ç·¨Êý¾ÝÖµ£¨ÔÚÆðÊ¼µØÖ·µÄ»ù´¡ÉÏ£¬ÊýÁ¿ÊÇ²»ºÏ·¨µÄ£©
  13          //----------------------------------------------------------------------------//
  14          
  15          #include "MODBUS.h"
  16          #include "uart.h"
  17          #include "stc15f2k60s2.h"
  18          #include <string.h>
  19          // #include "sys.h"
  20          // #include "delay.h"
  21          // #include "usart.h"
  22          // #include "timer.h"
  23          // #include "modbusCRC.h"
  24          // #include "dma.h"
  25          // #include "io.h"
  26          // #include "24cxx.h"
  27          // #include "yunxingkongzhi.h"
  28          // #include "kongzhiban.h"
  29          // #include "pingmu.h"
  30          
  31          
  32          int Slave_Address=1;
  33          
  34          #define Modbus_ReadHoldingReg   3
  35          #define Modbus_WriteSingleReg   6
  36          #define Modbus_WriteMultipleReg 10       
  37          /* ±äÁ¿¶¨Òå ------------------------------------------------------------------*/
  38          uint8_t Modbus_Send_Buff[Modbus_Max_Send_Buff];                //·¢ËÍÊý¾Ý»º³åÇø
  39          uint8_t Modbus_Rcv_Buff[Modbus_Max_Rcv_Buff];                //½ÓÊÕÊý¾Ý»º³åÇø
  40          uint8_t Modbus_Timeout_Cnt;                                                        //¶¨Ê±Æ÷ÖÐ¶Ï¼ÆÊý
  41          uint8_t Modbus_Rcv_Cnt;                                                                //½ÓÊÕ×Ö½Ú¼ÆÊý
  42          uint8_t        Modbus_Rcv_flag;                                                        //Éè±¸½øÈë½ÓÊÕ×´Ì¬±
             -êÖ¾
  43          uint8_t Modbus_Cmd_flag;                                                        //Éè±¸½øÈëÃüÁî½âÎö×´Ì¬±êÖ¾
  44          uint8_t Modbus_Exe_flag;                                                        //Éè±¸½øÈëÃüÁîÖ´ÐÐ×´Ì¬±êÖ¾
  45          uint8_t Modbus_Function;                                                        //´ÓÕ¾Éè±¸ÐèÖ´ÐÐµÄ¹¦ÄÜ
  46          
  47          volatile uint16_t HoldingReg[100] = {0, 0, 0, 0};                                //±£³Ö¼Ä´æÆ÷
  48          int UART3_Handler=0;
  49          /* º¯Êý¶¨Òå ------------------------------------------------------------------*/
  50          
  51          //----------------------------------------------------------------------------//
  52          //º¯Êý¹¦ÄÜ£ºÖðÎ»¼ÆËã·¨CRC16Ð£Ñé£¬ÔÚModbusÖÐCRC½á¹ûÒª½øÐÐ¸ßµÍ×Ö½Ú½»»»£¬¼´µÍ×Ö½ÚÔÚÇ°£¬¸ß×Ö½ÚÔÚºó
  53          //Èë¿Ú²ÎÊý£ºpuchMsgÊÇÒª½øÐÐCRCÐ£ÑéµÄÏûÏ¢£»usDataLenÊÇÏûÏ¢ÖÐ×Ö½ÚÊý
  54          //³ö¿Ú²ÎÊý£º¼ÆËã³öÀ´µÄCRCÐ£ÑéÂë£¬16Î»³¤¶È
C51 COMPILER V9.05   MODBUS                                                                06/04/2023 16:52:26 PAGE 2   

  55          //×îºóÐÞ¸Ä£º2015.11.29
  56          //±¸×¢£º
  57          //----------------------------------------------------------------------------//
  58          void init_485()
  59          {
  60   1              
  61   1      }
  62          char cuncu_485()
  63           {
  64   1              // printf("cuncu_485 %d",1);
  65   1              return 1;
  66   1       }
  67          uint16_t Modbus_CRC16(uint8_t *puchMsg, uint8_t usDataLen)
  68          {
  69   1              uint16_t CRC_Cal = 0xFFFF;
  70   1              uint8_t CRC_High, CRC_Low;
  71   1              uint8_t i, j;
  72   1              
  73   1              for(j = 0; j < usDataLen; j++)
  74   1              {
  75   2                      CRC_Cal = CRC_Cal ^ *puchMsg++;
  76   2                      
  77   2                      for (i = 0; i < 8; i++)
  78   2                      {
  79   3                              if((CRC_Cal & 0x0001) == 0x0001)
  80   3                              {
  81   4                                      CRC_Cal = CRC_Cal >> 1;
  82   4                                      CRC_Cal = CRC_Cal ^ 0xA001;
  83   4                              }
  84   3                              else
  85   3                              {
  86   4                                      CRC_Cal = CRC_Cal >> 1;
  87   4                              }
  88   3                      }
  89   2              }
  90   1              
  91   1              CRC_High = (uint8_t)(CRC_Cal >> 8);
  92   1              CRC_Low = (uint8_t)(CRC_Cal & 0x00FF);
  93   1              
  94   1              return (CRC_Low << 8 | CRC_High);
  95   1              
  96   1      //        return CRC_Cal;
  97   1      
  98   1      }
  99          
 100          //----------------------------------------------------------------------------//
 101          //º¯Êý¹¦ÄÜ£ºModbus³õÊ¼»¯
 102          //Èë¿Ú²ÎÊý£ºIDÊÇ´ÓÕ¾Õ¾ºÅ
 103          //³ö¿Ú²ÎÊý£ºÎÞ
 104          //×îºóÐÞ¸Ä£º2015.11.20
 105          //±¸×¢£º
 106          //----------------------------------------------------------------------------//
 107          void Modbus_Init(void)
 108          {
 109   1              uint16_t i;
 110   1              
 111   1              //----------------------------------------------------------//
 112   1              //ModbusÏà¹Ø±äÁ¿³õÊ¼»¯
 113   1              //----------------------------------------------------------//
 114   1              Modbus_Timeout_Cnt = 0;
 115   1              Modbus_Rcv_Cnt = 0;
 116   1              Modbus_Rcv_flag = 0;
C51 COMPILER V9.05   MODBUS                                                                06/04/2023 16:52:26 PAGE 3   

 117   1              Modbus_Cmd_flag = 0;
 118   1              Modbus_Exe_flag = 0;
 119   1              
 120   1              for(i = 0; i < Modbus_Max_Rcv_Buff; i++)                //Çå³ý½ÓÊÕ»º³åÇø
 121   1              {
 122   2                      Modbus_Rcv_Buff[i] = '\0';
 123   2              }
 124   1              
 125   1              for(i = 0; i < Modbus_Max_Send_Buff; i++)                //Çå³ý·¢ËÍ»º³åÇø
 126   1              {
 127   2                      Modbus_Send_Buff[i] = '\0';
 128   2              }
 129   1              
 130   1              //----------------------------------------------------------//
 131   1              //TIM2¶¨Ê±Æ÷Ê¹ÄÜ
 132   1              //----------------------------------------------------------//
 133   1              //TIM_Cmd(TIM2, ENABLE);
 134   1      }
 135          int rectimes;
 136          void chuankou1jisuuan(unsigned char ans)
 137          {
 138   1              Modbus_Rcv_Buff[Modbus_Rcv_Cnt]=ans;
 139   1              Modbus_Rcv_Cnt++;
 140   1              rectimes=2;
 141   1      }
 142          int recover=0;
 143          int bijiao(const char *a,const char *b)
 144          {
 145   1              int i;
 146   1              for(i=0;i<6;i++)
 147   1              {
 148   2                  if(a[i]!=b[i])
 149   2                  {
 150   3                      return 0;
 151   3                  }
 152   2              }
 153   1              return 1;
 154   1      }
 155          
 156          void chuliguankji()
 157          {
 158   1          char* index;
 159   1          index=strstr(Modbus_Rcv_Buff,"@STCISP#");
 160   1              if(index==0)
 161   1              {
 162   2                  return  ;
 163   2              }
 164   1          IAP_CONTR=0x60;
 165   1      }
 166          void time1msjisuan()
 167          {
 168   1          if(rectimes>0)
 169   1          {
 170   2              rectimes--;
 171   2              if(rectimes==0)
 172   2              {
 173   3                 chuliguankji();
 174   3                  recover=1;
 175   3              }
 176   2          }    
 177   1      }
 178          
C51 COMPILER V9.05   MODBUS                                                                06/04/2023 16:52:26 PAGE 4   

 179          void Modbus_Cmd(void);
 180          void Modbus_Exe(void);
 181          
 182          void jishouokjisuan()
 183          {
 184   1              
 185   1              Modbus_Cmd_flag=1;//Êý¾Ý½ÓÊÜÍê,,½øÈëÖÐ¶Ï±êÖ¾Î»..
 186   1              Modbus_Cmd();     //Êý¾Ý´¦Àí,,          
 187   1              Modbus_Exe();     //´¦ÀíÍê·¢...    
 188   1              Modbus_ClearBuff();//ÅªÍêÁËÇåÀí»º³åÇø     
 189   1      }
 190          
 191          char dmatime=0;
 192          void DMA1_Channel2_IRQHandler(void)
 193          {
 194   1      
 195   1      }
 196          //----------------------------------------------------------------------------//
 197          //º¯Êý¹¦ÄÜ£ºModbusÃüÁî½âÎöº¯Êý
 198          //Èë¿Ú²ÎÊý£ºÎÞ
 199          //³ö¿Ú²ÎÊý£ºÎÞ
 200          //×îºóÐÞ¸Ä£º2015.12.11
 201          //±¸×¢£º
 202          //----------------------------------------------------------------------------//
 203          void Modbus_Cmd(void)
 204          {
 205   1              uint8_t Modbus_CRC_Rcv_Hi;                //½ÓÊÕµ½µÄModbusCRCÐ£ÑéÂë¸ß×Ö½Ú
 206   1              uint8_t Modbus_CRC_Rcv_Lo;                //½ÓÊÕµ½µÄModbusCRCÐ£ÑéÂëµÍ×Ö½Ú
 207   1              uint16_t Modbus_CRC_Rcv;                //½ÓÊÕµ½µÄModbusCRCÐ£ÑéÂë
 208   1              uint16_t Modbus_CRC_Cal;                //¸ù¾Ý½ÓÊÕµ½µÄÊý¾Ý¼ÆËã³öÀ´µÄCRCÖµ
 209   1              
 210   1              //----------------------------------------------------------//
 211   1              //¿ªÊ¼ÃüÁî½âÎö
 212   1              //----------------------------------------------------------//
 213   1              if(Modbus_Cmd_flag == 1)
 214   1              {
 215   2                      if(Modbus_Rcv_Cnt > 4)                //Èç¹û½ÓÊÕµ½µÄÒ»Ö¡µÄ×Ö½ÚÊý´óÓÚ4 Ê×ÏÈÈ·±£Ö¡µÄ³¤¶ÈÔÚÕý
             -³£·¶Î§
 216   2                      {
 217   3                              Modbus_CRC_Rcv_Lo = Modbus_Rcv_Buff[Modbus_Rcv_Cnt - 2];                          
             -              //½ÓÊÕµ½µÄModbusCRCÐ£ÑéÂëµÍ×Ö½Ú
 218   3                              Modbus_CRC_Rcv_Hi = Modbus_Rcv_Buff[Modbus_Rcv_Cnt - 1];                          
             -              //½ÓÊÕµ½µÄModbusCRCÐ£ÑéÂë¸ß×Ö½Ú
 219   3                              Modbus_CRC_Rcv = (uint16_t)(Modbus_CRC_Rcv_Lo << 8 | Modbus_CRC_Rcv_Hi);        //
             -½ÓÊÕµ½µÄModbusCRCÐ£ÑéÂë£¨16Î»£©
 220   3                              Modbus_CRC_Cal = Modbus_CRC16(Modbus_Rcv_Buff, Modbus_Rcv_Cnt - 2);               
             -         //¸ù¾Ý½ÓÊÕµ½µÄÊý¾Ý¼ÆËãCRCÖµ
 221   3                              if(Modbus_CRC_Cal == Modbus_CRC_Rcv)                //Èç¹û¼ÆËãµÄCRCÖµÓë½ÓÊÜµÄCRCÖµ
             -ÏàµÈ
 222   3                              {
 223   4                                      //USART_SendByte(USART1, 0xAC);
 224   4                                      if(Slave_Address == Modbus_Rcv_Buff[0])        //Èç¹ûÊÇ±¾»úµØÖ·
 225   4                                      {
 226   5                                              switch(Modbus_Rcv_Buff[1])                        //ÓÃswitch·ÖÖ§Óï
             -¾äÀ´È·¶¨¹¦ÄÜ
 227   5                                              {
 228   6                                              case Modbus_ReadHoldingReg:                                       
             -         //Èç¹ûÊÇ¶Á±£´æ¼Ä´æÆ÷
 229   6                                                      Modbus_Function = Modbus_ReadHoldingReg;        //½«´ÓÕ¾Éè
             -±¸ÐèÖ´ÐÐµÄ¹¦ÄÜ¸³ÖµÎª¶Á±£´æ¼Ä´æÆ÷
 230   6                                                      Modbus_Exe_flag = 1;                                      
             -          //Éè±¸½øÈëÃüÁîÖ´ÐÐ×´Ì¬
C51 COMPILER V9.05   MODBUS                                                                06/04/2023 16:52:26 PAGE 5   

 231   6                                                      break;                                                    
             -                            //Ìø³ö·ÖÖ§Óï¾ä
 232   6                                                      
 233   6                                              case Modbus_WriteSingleReg:
 234   6                                                      Modbus_Function = Modbus_WriteSingleReg;        //½«´ÓÕ¾Éè
             -±¸ÐèÖ´ÐÐµÄ¹¦ÄÜ¸³ÖµÎªÐ´µ¥¸ö¼Ä´æÆ÷
 235   6                                                      Modbus_Exe_flag = 1;                                      
             -          //Éè±¸½øÈëÃüÁîÖ´ÐÐ×´Ì¬
 236   6                                                      break;                                                    
             -                            //Ìø³ö·ÖÖ§Óï¾ä
 237   6                                              
 238   6                                              case Modbus_WriteMultipleReg:
 239   6                                                      Modbus_Function = Modbus_WriteMultipleReg;        //½«´ÓÕ¾
             -Éè±¸ÐèÖ´ÐÐµÄ¹¦ÄÜ¸³ÖµÎªÐ´¶à¸ö¼Ä´æÆ÷
 240   6                                                      Modbus_Exe_flag = 1;                                      
             -          //Éè±¸½øÈëÃüÁîÖ´ÐÐ×´Ì¬
 241   6                                                      break;                                                    
             -                            //Ìø³ö·ÖÖ§Óï¾ä
 242   6                                                      
 243   6                                              default:
 244   6                                                      Modbus_ErrorHandling(0x01);                //ËùÓÐ¹¦ÄÜÂë¶¼²
             -»·ûºÏ£¬Ôò·µ»Ø¹¦ÄÜÂë´íÎóÒì³£ÏìÓ¦±¨ÎÄ
 245   6                                                      return;
 246   6                                              }
 247   5                                      }
 248   4                                      
 249   4                                      else                //·ñÔòÇå¿Õ½ÓÊÕÊý¾Ý»º³åÇøºÍ·¢ËÍÊý¾Ý»º³åÇø
 250   4                                      {
 251   5                                              Modbus_ClearBuff();
 252   5                                      }
 253   4                              }
 254   3                              
 255   3                              else                //·ñÔòÇå¿Õ½ÓÊÕÊý¾Ý»º³åÇøºÍ·¢ËÍÊý¾Ý»º³åÇø
 256   3                              {
 257   4                                      Modbus_ClearBuff();
 258   4                              }
 259   3                              
 260   3                      }
 261   2                      
 262   2                      else                //·ñÔòÇå¿Õ½ÓÊÕÊý¾Ý»º³åÇøºÍ·¢ËÍÊý¾Ý»º³åÇø
 263   2                      {
 264   3                              Modbus_ClearBuff();
 265   3                      }
 266   2                      
 267   2                      Modbus_Cmd_flag = 0;                //Éè±¸ÍË³öÃüÁî½âÎö×´Ì¬±êÖ¾
 268   2              }
 269   1      }
 270          
 271          //----------------------------------------------------------------------------//
 272          //º¯Êý¹¦ÄÜ£ºModbusÃüÁîÖ´ÐÐº¯Êý
 273          //Èë¿Ú²ÎÊý£ºÎÞ
 274          //³ö¿Ú²ÎÊý£ºÎÞ
 275          //×îºóÐÞ¸Ä£º2015.12.6
 276          //±¸×¢£º
 277          //----------------------------------------------------------------------------//
 278          void Modbus_Exe(void)
 279          {
 280   1              if(Modbus_Exe_flag == 1)
 281   1              {
 282   2                      switch(Modbus_Function)
 283   2                      {
 284   3                      case Modbus_ReadHoldingReg:
C51 COMPILER V9.05   MODBUS                                                                06/04/2023 16:52:26 PAGE 6   

 285   3                              Modbus_ReadHoldingReg_Process();
 286   3                              break;
 287   3                              
 288   3                      case Modbus_WriteSingleReg:
 289   3                              Modbus_WriteSingleReg_Process();
 290   3                              break;
 291   3                      
 292   3                      case Modbus_WriteMultipleReg:
 293   3                              Modbus_WriteMultipleReg_Process();
 294   3                              break;
 295   3                              
 296   3                      }
 297   2                      Modbus_Exe_flag = 0;
 298   2              }
 299   1      }
 300          
 301          //----------------------------------------------------------------------------//
 302          //º¯Êý¹¦ÄÜ£º¹¦ÄÜÂë0x03£¬¶Á±£³Ö¼Ä´æÆ÷
 303          //Èë¿Ú²ÎÊý£ºÎÞ
 304          //³ö¿Ú²ÎÊý£ºÎÞ
 305          //×îºóÐÞ¸Ä£º2015.12.5
 306          //±¸×¢£º
 307          //----------------------------------------------------------------------------//
 308          void Modbus_ReadHoldingReg_Process(void)
 309          {
 310   1              uint8_t Send_Cnt;                        //·¢ËÍ×Ö½ÚÊýÁ¿
 311   1              uint16_t StartAddress_Reg;        //Òª¶ÁÈ¡µÄ¼Ä´æÆ÷ÆðÊ¼µØÖ·
 312   1              uint16_t Num_Reg;                        //Òª¶ÁÈ¡µÄ¼Ä´æÆ÷µÄÊýÁ¿
 313   1              uint16_t CRC_Cal;                        //CRCÐ£ÑéÂë
 314   1              uint16_t i, j;                                //ÁÙÊ±±äÁ¿
 315   1              
 316   1              StartAddress_Reg = Modbus_Rcv_Buff[2] << 8 | Modbus_Rcv_Buff[3];        //´Ó½ÓÊÕÊý¾Ý»º³åÇøµÃµ½Òª¶Á
             -È¡µÄ¼Ä´æÆ÷ÆðÊ¼µØÖ·
 317   1              Num_Reg = Modbus_Rcv_Buff[4] << 8 | Modbus_Rcv_Buff[5];                                //´Ó½ÓÊÕÊý¾
             -Ý»º³åÇøµÃµ½Òª¶ÁÈ¡µÄ¼Ä´æÆ÷ÊýÁ¿
 318   1              
 319   1              if(StartAddress_Reg < 100)                //¼Ä´æÆ÷ÆðÊ¼µØÖ·ÔÚÕýÈ··¶Î§ÄÚ
 320   1              {
 321   2                      if(StartAddress_Reg + Num_Reg < 100 && Num_Reg > 0)                //ÆðÊ¼µØÖ·+¼Ä´æÆ÷ÊýÁ¿Î»
             -ÓÚÕýÈ··¶Î§ÄÚ ²¢ÇÒ ¼Ä´æÆ÷ÊýÁ¿ÕýÈ·
 322   2                      {
 323   3                                                                                                                                                              
 324   3                              Send_Cnt = 3 + (Num_Reg << 1) + 2;                //¼ÆËã·¢ËÍ×Ö½ÚÊýÁ¿
 325   3                              Modbus_Send_Buff[0] = Slave_Address;                        //´ÓÕ¾µØÖ·
 326   3                              Modbus_Send_Buff[1] = Modbus_ReadHoldingReg;        //¹¦ÄÜÂë
 327   3                              Modbus_Send_Buff[2] = Num_Reg << 1;                                //¼Ä´æÆ÷×Ö½ÚÊýÁ
             -¿ µÈÓÚ ¼Ä´æÆ÷ÊýÁ¿³Ë2
 328   3                              
 329   3                              for(i = StartAddress_Reg, j = 3; i < StartAddress_Reg + Num_Reg; i++, j += 2)     
             -   //¶ÁÈ¡¼Ä´æÆ÷µÄÊý¾Ý
 330   3                              {
 331   4                                      Modbus_Send_Buff[j] = (uint8_t)(HoldingReg[i] >> 8);
 332   4                                      Modbus_Send_Buff[j + 1] = (uint8_t)(HoldingReg[i] & 0x00FF);
 333   4                              }
 334   3              
 335   3                              CRC_Cal = Modbus_CRC16(Modbus_Send_Buff, 3 + (Num_Reg << 1));                     
             -           //¼ÆËã·¢ËÍÊý¾ÝµÄCRCÐ£ÑéÂë
 336   3                              Modbus_Send_Buff[3 + (Num_Reg << 1)] = (uint8_t)(CRC_Cal >> 8);                   
             -             //ÏÈÊÇµÍ×Ö½Ú
 337   3                              Modbus_Send_Buff[3 + (Num_Reg << 1) + 1] = (uint8_t)(CRC_Cal & 0x00FF);           
             -     //ºóÊÇ¸ß×Ö½Ú
 338   3              
C51 COMPILER V9.05   MODBUS                                                                06/04/2023 16:52:26 PAGE 7   

 339   3                              //USART_SendString(USART1, Modbus_Send_Buff, Send_Cnt);                        //·
             -¢ËÍÏìÓ¦±¨ÎÄ
 340   3                              HAL_UART_Transmit_DMA_485(&UART3_Handler,(u8*)Modbus_Send_Buff,Send_Cnt);
 341   3                              //Modbus_ClearBuff();                //Çå¿Õ½ÓÊÕÊý¾Ý»º³åÇøºÍ·¢ËÍÊý¾Ý»º³åÇø
 342   3                      }
 343   2                      else
 344   2                      {
 345   3                              Modbus_ErrorHandling(0x03);                //·Ç·¨Êý¾ÝÖµ
 346   3                      }
 347   2              }
 348   1              
 349   1              else
 350   1              {
 351   2                      Modbus_ErrorHandling(0x02);                        //·Ç·¨Êý¾ÝµØÖ·
 352   2              }
 353   1              
 354   1      }
 355          
 356          //----------------------------------------------------------------------------//
 357          //º¯Êý¹¦ÄÜ£º¹¦ÄÜÂë0x06£¬Ð´µ¥¸ö¼Ä´æÆ÷
 358          //Èë¿Ú²ÎÊý£ºÎÞ
 359          //³ö¿Ú²ÎÊý£ºÎÞ
 360          //×îºóÐÞ¸Ä£º2015.12.6
 361          //±¸×¢£º
 362          //----------------------------------------------------------------------------//
 363          void Modbus_WriteSingleReg_Process(void)
 364          {
 365   1              uint8_t Send_Cnt;                        //·¢ËÍ×Ö½ÚÊýÁ¿
 366   1              uint16_t Address_Reg;                //ÒªÐ´ÈëµÄ¼Ä´æÆ÷µØÖ·
 367   1              uint16_t Value_Reg;                        //ÒªÐ´ÈëµÄ¼Ä´æÆ÷Öµ
 368   1              uint16_t CRC_Cal;                        //CRCÐ£ÑéÂë
 369   1              
 370   1              Address_Reg = Modbus_Rcv_Buff[2] << 8 | Modbus_Rcv_Buff[3];                //´Ó½ÓÊÕÊý¾Ý»º³åÇøµÃµ½Ò
             -ªÐ´ÈëµÄ¼Ä´æÆ÷µØÖ·
 371   1              Value_Reg = Modbus_Rcv_Buff[4] << 8 | Modbus_Rcv_Buff[5];                //´Ó½ÓÊÕÊý¾Ý»º³åÇøµÃµ½ÒªÐ
             -´ÈëµÄ¼Ä´æÆ÷Öµ
 372   1              
 373   1              if(Address_Reg < 100)                //¼Ä´æÆ÷ÆðÊ¼µØÖ·ÔÚÕýÈ··¶Î§ÄÚ
 374   1              {
 375   2                                                              
 376   2                      Send_Cnt = 6 + 2;                //¼ÆËã·¢ËÍ×Ö½ÚÊýÁ¿
 377   2                      
 378   2                      HoldingReg[Address_Reg] = Value_Reg;                //½«ÒªÐ´ÈëµÄ¼Ä´æÆ÷ÖµÐ´Èë¼Ä´æÆ÷
 379   2                      
 380   2                      Modbus_Send_Buff[0] = Slave_Address;                                                      
             -                  //´ÓÕ¾µØÖ·
 381   2                      Modbus_Send_Buff[1] = Modbus_WriteSingleReg;                                              
             -          //¹¦ÄÜÂë
 382   2                      Modbus_Send_Buff[2] = (uint8_t)(Address_Reg >> 8);                                        
             -        //¼Ä´æÆ÷µØÖ·¸ß×Ö½Ú
 383   2                      Modbus_Send_Buff[3] = (uint8_t)(Address_Reg & 0x00FF);                                    
             -    //¼Ä´æÆ÷µØÖ·µÍ×Ö½Ú
 384   2                      Modbus_Send_Buff[4] = (uint8_t)(HoldingReg[Address_Reg] >> 8);                        //¼Ä
             -´æÆ÷Öµ¸ß×Ö½Ú
 385   2                      Modbus_Send_Buff[5] = (uint8_t)(HoldingReg[Address_Reg] & 0x00FF);                //¼Ä´æÆ÷
             -ÖµµÍ×Ö½Ú
 386   2                      
 387   2                      CRC_Cal = Modbus_CRC16(Modbus_Send_Buff, 6);                        //¼ÆËã·¢ËÍÊý¾ÝµÄCRCÐ£Ñ
             -éÂë
 388   2                      Modbus_Send_Buff[6] = (uint8_t)(CRC_Cal >> 8);                        //ÏÈÊÇµÍ×Ö½Ú
 389   2                      Modbus_Send_Buff[7] = (uint8_t)(CRC_Cal & 0x00FF);                //ºóÊÇ¸ß×Ö½Ú
 390   2                      
C51 COMPILER V9.05   MODBUS                                                                06/04/2023 16:52:26 PAGE 8   

 391   2                     // USART_SendString(USART1, Modbus_Send_Buff, Send_Cnt);        //·¢ËÍÏìÓ¦±¨ÎÄ
 392   2                      HAL_UART_Transmit_DMA_485(&UART3_Handler,(u8*)Modbus_Send_Buff,Send_Cnt);
 393   2                      //Modbus_ClearBuff();                //Çå¿Õ½ÓÊÕÊý¾Ý»º³åÇøºÍ·¢ËÍÊý¾Ý»º³åÇø
 394   2              }
 395   1              
 396   1              else
 397   1              {
 398   2                      Modbus_ErrorHandling(0x02);                        //·Ç·¨Êý¾ÝµØÖ·
 399   2              }
 400   1      }
 401          
 402          //----------------------------------------------------------------------------//
 403          //º¯Êý¹¦ÄÜ£º¹¦ÄÜÂë0x10£¬Ð´¶à¸ö¼Ä´æÆ÷
 404          //Èë¿Ú²ÎÊý£ºÎÞ
 405          //³ö¿Ú²ÎÊý£ºÎÞ
 406          //×îºóÐÞ¸Ä£º2015.12.9
 407          //±¸×¢£º
 408          //----------------------------------------------------------------------------//
 409          void Modbus_WriteMultipleReg_Process(void)
 410          {
 411   1              uint8_t Send_Cnt;                        //·¢ËÍ×Ö½ÚÊýÁ¿
 412   1              uint16_t StartAddress_Reg;        //ÒªÐ´ÈëµÄ¼Ä´æÆ÷ÆðÊ¼µØÖ·
 413   1              uint16_t Num_Reg;                        //ÒªÐ´ÈëµÄ¼Ä´æÆ÷µÄÊýÁ¿
 414   1              uint16_t CRC_Cal;                        //CRCÐ£ÑéÂë
 415   1              uint16_t i, j;                                //ÁÙÊ±±äÁ¿
 416   1              
 417   1              StartAddress_Reg = Modbus_Rcv_Buff[2] << 8 | Modbus_Rcv_Buff[3];        //´Ó½ÓÊÕÊý¾Ý»º³åÇøµÃµ½ÒªÐ´
             -ÈëµÄ¼Ä´æÆ÷ÆðÊ¼µØÖ·
 418   1              Num_Reg = Modbus_Rcv_Buff[4] << 8 | Modbus_Rcv_Buff[5];                                //´Ó½ÓÊÕÊý¾
             -Ý»º³åÇøµÃµ½ÒªÐ´ÈëµÄ¼Ä´æÆ÷ÊýÁ¿
 419   1              
 420   1              if(StartAddress_Reg < 100)                        //¼Ä´æÆ÷ÆðÊ¼µØÖ·ÔÚÕýÈ··¶Î§ÄÚ
 421   1              {
 422   2                      if(StartAddress_Reg + Num_Reg < 100 && Num_Reg > 0)                                //ÆðÊ¼µ
             -ØÖ·+¼Ä´æÆ÷ÊýÁ¿Î»ÓÚÕýÈ··¶Î§ÄÚ ²¢ÇÒ ¼Ä´æÆ÷ÊýÁ¿ÕýÈ·                        
 423   2                      {
 424   3                              for(i = StartAddress_Reg, j = 7; i < StartAddress_Reg + Num_Reg; i++, j += 2)     
             -   //½«ÒªÐ´ÈëµÄ¼Ä´æÆ÷ÖµÐ´Èë¼Ä´æÆ÷
 425   3                              {
 426   4                                      HoldingReg[i] = Modbus_Rcv_Buff[j] << 8 | Modbus_Rcv_Buff[j + 1];
 427   4                              }
 428   3                              Send_Cnt = 6 + 2;
 429   3                      
 430   3                              Modbus_Send_Buff[0] = Slave_Address;                                              
             -  //´ÓÕ¾µØÖ·
 431   3                              Modbus_Send_Buff[1] = Modbus_WriteMultipleReg;                                //¹¦
             -ÄÜÂë
 432   3                              Modbus_Send_Buff[2] = (uint8_t)(StartAddress_Reg >> 8);                //¼Ä´æÆ÷ÆðÊ
             -¼µØÖ·¸ß×Ö½Ú
 433   3                              Modbus_Send_Buff[3] = (uint8_t)(StartAddress_Reg & 0x00FF);        //¼Ä´æÆ÷ÆðÊ¼µØÖ
             -·µÍ×Ö½Ú
 434   3                              Modbus_Send_Buff[4] = (uint8_t)(Num_Reg >> 8);                                //¼Ä
             -´æÆ÷ÊýÁ¿¸ß×Ö½Ú
 435   3                              Modbus_Send_Buff[5] = (uint8_t)(Num_Reg & 0x00FF);                        //¼Ä´æÆ÷
             -ÊýÁ¿µÍ×Ö½Ú
 436   3                              
 437   3                              CRC_Cal = Modbus_CRC16(Modbus_Send_Buff, 6);                        //¼ÆËã·¢ËÍÊý¾Ý
             -µÄCRCÐ£ÑéÂë
 438   3                              Modbus_Send_Buff[6] = (uint8_t)(CRC_Cal >> 8);                        //ÏÈÊÇµÍ×Ö½Ú
 439   3                              Modbus_Send_Buff[7] = (uint8_t)(CRC_Cal & 0x00FF);                //ºóÊÇ¸ß×Ö½Ú
 440   3                              
 441   3                             // USART_SendString(USART1, Modbus_Send_Buff, Send_Cnt);        //·¢ËÍÏìÓ¦±¨ÎÄ
C51 COMPILER V9.05   MODBUS                                                                06/04/2023 16:52:26 PAGE 9   

 442   3                              HAL_UART_Transmit_DMA_485(&UART3_Handler,(u8*)Modbus_Send_Buff,Send_Cnt);
 443   3                              //Modbus_ClearBuff();                //Çå¿Õ½ÓÊÕÊý¾Ý»º³åÇøºÍ·¢ËÍÊý¾Ý»º³åÇø
 444   3                      }
 445   2                      
 446   2                      else
 447   2                      {
 448   3                              Modbus_ErrorHandling(0x03);
 449   3                      }
 450   2              }
 451   1              
 452   1              else
 453   1              {
 454   2                      Modbus_ErrorHandling(0x02);
 455   2              }
 456   1      }
 457          
 458          //----------------------------------------------------------------------------//
 459          //º¯Êý¹¦ÄÜ£º´íÎó´¦Àí
 460          //Èë¿Ú²ÎÊý£ºErrorTypeÊÇ´íÎóÀàÐÍ
 461          //³ö¿Ú²ÎÊý£ºÎÞ
 462          //×îºóÐÞ¸Ä£º2015.12.11
 463          //±¸×¢£º
 464          //----------------------------------------------------------------------------//
 465          void Modbus_ErrorHandling(uint8_t ErrorType)
 466          {
 467   1              uint16_t CRC_Cal;                        //CRCÐ£ÑéÂë
 468   1              
 469   1              switch(ErrorType)                        //ÓÃswitch·ÖÖ§Óï¾äÀ´È·¶¨ModbusÒì³£Âë
 470   1              {
 471   2              case 0x01:                                        //·Ç·¨¹¦ÄÜÂë
 472   2                      Modbus_Send_Buff[0] = Slave_Address;                                        //´ÓÕ¾µØÖ·
 473   2                      Modbus_Send_Buff[1] = Modbus_Rcv_Buff[1] + 0x80;                //Òì³£¹¦ÄÜÂë
 474   2                      Modbus_Send_Buff[2] = 0x01;                                                               
             - //Òì³£Âë
 475   2                      CRC_Cal = Modbus_CRC16(Modbus_Send_Buff, 3);                        //¼ÆËã·¢ËÍÊý¾ÝµÄCRCÐ£Ñ
             -éÂë
 476   2                      Modbus_Send_Buff[3] = (uint8_t)(CRC_Cal >> 8);                        //ÏÈÊÇµÍ×Ö½Ú
 477   2                      Modbus_Send_Buff[4] = (uint8_t)(CRC_Cal & 0x00FF);                //ºóÊÇ¸ß×Ö½Ú
 478   2                      
 479   2                      //USART_SendString(USART1, Modbus_Send_Buff, 5);                        //·¢ËÍÒì³£ÏìÓ¦±¨ÎÄ
 480   2                                              HAL_UART_Transmit_DMA_485(&UART3_Handler,(u8*)Modbus_Send_Buff,5);
 481   2                      break;
 482   2                      
 483   2              case 0x02:                                        //·Ç·¨Êý¾ÝµØÖ·
 484   2                      Modbus_Send_Buff[0] = Slave_Address;                                        //´ÓÕ¾µØÖ·
 485   2                      Modbus_Send_Buff[1] = Modbus_Rcv_Buff[1] + 0x80;                //Òì³£¹¦ÄÜÂë
 486   2                      Modbus_Send_Buff[2] = 0x02;                                                               
             - //Òì³£Âë
 487   2                      CRC_Cal = Modbus_CRC16(Modbus_Send_Buff, 3);                        //¼ÆËã·¢ËÍÊý¾ÝµÄCRCÐ£Ñ
             -éÂë
 488   2                      Modbus_Send_Buff[3] = (uint8_t)(CRC_Cal >> 8);                        //ÏÈÊÇµÍ×Ö½Ú
 489   2                      Modbus_Send_Buff[4] = (uint8_t)(CRC_Cal & 0x00FF);                //ºóÊÇ¸ß×Ö½Ú
 490   2                      
 491   2                      //USART_SendString(USART1, Modbus_Send_Buff, 5);                        //·¢ËÍÒì³£ÏìÓ¦±¨ÎÄ
 492   2                                              HAL_UART_Transmit_DMA_485(&UART3_Handler,(u8*)Modbus_Send_Buff,5);
 493   2                      break;
 494   2                      
 495   2              case 0x03:                                        //·Ç·¨Êý¾ÝÖµ
 496   2                      Modbus_Send_Buff[0] = Slave_Address;                                        //´ÓÕ¾µØÖ·
 497   2                      Modbus_Send_Buff[1] = Modbus_Rcv_Buff[1] + 0x80;                //Òì³£¹¦ÄÜÂë
 498   2                      Modbus_Send_Buff[2] = 0x03;                                                               
             - //Òì³£Âë
C51 COMPILER V9.05   MODBUS                                                                06/04/2023 16:52:26 PAGE 10  

 499   2                      CRC_Cal = Modbus_CRC16(Modbus_Send_Buff, 3);                        //¼ÆËã·¢ËÍÊý¾ÝµÄCRCÐ£Ñ
             -éÂë
 500   2                      Modbus_Send_Buff[3] = (uint8_t)(CRC_Cal >> 8);                        //ÏÈÊÇµÍ×Ö½Ú
 501   2                      Modbus_Send_Buff[4] = (uint8_t)(CRC_Cal & 0x00FF);                //ºóÊÇ¸ß×Ö½Ú
 502   2                      
 503   2                      //USART_SendString(USART1, Modbus_Send_Buff, 5);                        //·¢ËÍÒì³£ÏìÓ¦±¨ÎÄ
 504   2                                              HAL_UART_Transmit_DMA_485(&UART3_Handler,(u8*)Modbus_Send_Buff,5);
 505   2                      break;
 506   2      //        default:
 507   2      //                return;
 508   2                      
 509   2              }
 510   1              
 511   1              //Modbus_ClearBuff();                //Çå¿Õ½ÓÊÕÊý¾Ý»º³åÇøºÍ·¢ËÍÊý¾Ý»º³åÇø
 512   1      }
 513          
 514          //----------------------------------------------------------------------------//
 515          //º¯Êý¹¦ÄÜ£ºÇå¿Õ½ÓÊÕÊý¾Ý»º³åÇøºÍ·¢ËÍÊý¾Ý»º³åÇø
 516          //Èë¿Ú²ÎÊý£ºÎÞUSAR
 517          //³ö¿Ú²ÎÊý£ºÎÞ
 518          //×îºóÐÞ¸Ä£º2015.12.5
 519          //±¸×¢£º
 520          //----------------------------------------------------------------------------//
 521          void Modbus_ClearBuff(void)
 522          {
 523   1              uint16_t i;
 524   1              for(i = 0; i < Modbus_Max_Rcv_Buff; i++)                //Çå³ý½ÓÊÕ»º³åÇø
 525   1              {
 526   2                      Modbus_Rcv_Buff[i] = '\0';
 527   2              }
 528   1              Modbus_Rcv_Cnt = 0;                        //½ÓÊÕ×Ö½Ú¼ÆÊýÇå0
 529   1              
 530   1              for(i = 0; i < Modbus_Max_Send_Buff; i++)                //Çå³ý·¢ËÍ»º³åÇø
 531   1              {
 532   2                      Modbus_Send_Buff[i] = '\0';
 533   2              }
 534   1              
 535   1      }
 536          
 537          //----------------------------------------------------------------------------//
 538          //º¯Êý¹¦ÄÜ£º°ÑÒ»¸ö×Ö½ÚµÄ¸ß4Î»Ê®Áù½øÖÆÊý´æµ½ÁíÒ»¸ö×Ö½ÚµÄµÍ4Î»Àï
 539          //Èë¿Ú²ÎÊý£ºÒ»¸ö×Ö½ÚµÄÊý¾Ý
 540          //³ö¿Ú²ÎÊý£ºÁíÒ»¸ö×Ö½Ú
 541          //×îºóÐÞ¸Ä£º2015.11.28
 542          //±¸×¢£º
 543          //----------------------------------------------------------------------------//
 544          uint8_t High4BitsToOneByte(uint8_t Byte)
 545          {
 546   1              uint8_t tempByte;
 547   1              
 548   1              tempByte = (Byte >> 4) & 0x0F;
 549   1              
 550   1              return tempByte; 
 551   1      }
 552          
 553          //----------------------------------------------------------------------------//
 554          //º¯Êý¹¦ÄÜ£º°ÑÒ»¸ö×Ö½ÚµÄµÍ4Î»Ê®Áù½øÖÆÊý´æµ½ÁíÒ»¸ö×Ö½ÚµÄµÍ4Î»Àï
 555          //Èë¿Ú²ÎÊý£ºÒ»¸ö×Ö½ÚµÄÊý¾Ý
 556          //³ö¿Ú²ÎÊý£ºÁíÒ»¸ö×Ö½Ú
 557          //×îºóÐÞ¸Ä£º2015.11.28
 558          //±¸×¢£º
 559          //----------------------------------------------------------------------------//
C51 COMPILER V9.05   MODBUS                                                                06/04/2023 16:52:26 PAGE 11  

 560          uint8_t Low4BitsToOneByte(uint8_t Byte)
 561          {
 562   1              uint8_t tempByte;
 563   1              
 564   1              tempByte = Byte & 0x0F;
 565   1              
 566   1              return tempByte; 
 567   1      }
 568          
 569          //----------------------------------------------------------------------------//
 570          //º¯Êý¹¦ÄÜ£º°ÑµÍ4Î»16½øÖÆÊý×ª»»ÎªÔÚOLED×Ö¿âÉÏ¶ÔÓ¦µÄ0~9ºÍA~F
 571          //Èë¿Ú²ÎÊý£ºHexByteÊÇµÍ4Î»16½øÖÆÊý
 572          //³ö¿Ú²ÎÊý£ºOLED×Ö¿âÉÏ¶ÔÓ¦µÄ0~9ºÍA~F
 573          //×îºóÐÞ¸Ä£º2015.11.28
 574          //±¸×¢£º
 575          //----------------------------------------------------------------------------//
 576          uint8_t HexToOLEDAsc(uint8_t HexByte)
 577          {
 578   1              if((HexByte >= 0x00) && (HexByte <= 0x09))                        //Êý×Ö0~9
 579   1              {
 580   2                      HexByte += 0x30;
 581   2              }
 582   1              else if((HexByte >= 0x0A) && (HexByte <= 0x0F))        //Êý×ÖA~F
 583   1              {
 584   2                      HexByte += 0x37;
 585   2              }
 586   1              else
 587   1              {
 588   2                      HexByte = 0xff;
 589   2              }
 590   1              
 591   1              return HexByte; 
 592   1      }
 593          void HAL_UART_Transmit_DMA_485(int *huart, uint8_t *pData, uint16_t Size)
 594          {
 595   1              int i;
 596   1              for(i=0;i<Size;i++)
 597   1              {
 598   2                      sendbyte1(pData[i]);
 599   2              }
 600   1      }
*** WARNING C280 IN LINE 593 OF modbus.c: 'huart': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1802    ----
   CONSTANT SIZE    =      9    ----
   XDATA SIZE       =    315      42
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
