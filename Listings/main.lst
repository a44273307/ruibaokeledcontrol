C251 COMPILER V5.60.0,  main                                                               31/07/23  20:42:27  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc251\C251\BIN\C251.EXE main.c LARGE BROWSE DEBUG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.
                    -\Objects\main.obj) 

stmt  level    source

    1          //  @布丁橘长 2023/03/10
    2          //  PWM编码器模式示例，本示例程序编码器模式1/2/3均支持，SMCR = 1：模式1，SMCR = 2:模式2，SMCR = 3：模式3
    3          //  EC11左旋或右旋，改变数码管亮度
    4          //  EC11引脚定义：A相-P1.0，B相-P5.4
    5          //  MAX7219数码管模块引脚定义：CS = P6^5;DIN = P6^6;CLK = P6^4;（可在MAX7219.h中修改）
    6          //  实验开发板：屠龙刀三.1 @主频12MHz
    7          
    8          
    9          
   10          
   11          
   12          
   13          
   14          
   15          #include <string.h>
   16          #include "stc32g.h"
   17          #include "config.h"
   18          
   19          
   20          #include <stdio.h>
   21          #include <stdarg.h>
   22          #include <stdio.h>
   23          
   24          #include <stdlib.h>
   25          #include "uart.h"
*** WARNING C317 IN LINE 24 OF uart.h: attempt to redefine macro 'MAIN_Fosc'
   26          #include "tongxin.h"
   27          #include "tongxin2.h"
   28          #include "STC32G_EEPROM.h"
   29          
   30          void SYS_Ini();   // STC32初始化设置
   31          void EC11_Handle(); // EC11数据处理
   32                    // 数码管显示
   33          void PWM_Config(); // PWM初始化设置
   34          
   35          u8 cnt_H, cnt_L;   // 计数值高8位、低8位
   36          u16 count, newcount; // 当前计数值、上次计数值
   37                     // 亮度计数值
   38          
   39          int bili=2;
   40          void SYS_Ini() // STC32初始化设置
   41          {
   42   1        EAXFR = 1;    // 使能访问 XFR
   43   1        CKCON = 0x00; // 设置外部数据总线速度为最快
   44   1        WTST = 0x00;  // 设置程序代码等待参数，赋值为 0 可将 CPU 执行程序的速度设置为最快
   45   1        P0M1 = 0x00;
   46   1        P0M0 = 0x00; // 设置P0口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   47   1        P1M1 = 0x00;
   48   1        P1M0 = 0x00; // 设置P1口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   49   1        P2M1 = 0x00;
   50   1        P2M0 = 0x00; // 设置P2口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   51   1        P3M1 = 0x00;
   52   1        P3M0 = 0x00; // 设置P3口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   53   1        P4M1 = 0x00;
   54   1        P4M0 = 0x00; // 设置P4口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   55   1        P5M1 = 0x00;
   56   1        P5M0 = 0x00; // 设置P5口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   57   1        P6M1 = 0x00;
C251 COMPILER V5.60.0,  main                                                               31/07/23  20:42:27  PAGE 2   

   58   1        P6M0 = 0x00; // 设置P6口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   59   1        P7M1 = 0x00;
   60   1        P7M0 = 0x00; // 设置P7口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   61   1      }
   62          
   63          
   64          
   65          void Delay100ms() //@24.000MHz
   66          {
   67   1        unsigned long i;
   68   1      
   69   1        _nop_();
   70   1        _nop_();
   71   1        i = 599998UL;
   72   1        while (i)
   73   1          i--;
   74   1      }
   75          // 定义printf函数
   76          void printf1(const char *fmt, ...)
   77          {
   78   1        char *p;
   79   1        char buf[128]; // 定义一个缓冲区，足够存储输出的字符串
   80   1        va_list args;
   81   1        va_start(args, fmt);
   82   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
   83   1        va_end(args);
   84   1      
   85   1        p = (unsigned char *)buf;
   86   1        while (*p != '\0')
   87   1        {
   88   2          sendbyte1(*p);
   89   2          p++;
   90   2        }
   91   1      }
   92          // 定义printf函数
   93          void printf3(const char *fmt, ...)
   94          {
   95   1        char *p;
   96   1        char buf[128]; // 定义一个缓冲区，足够存储输出的字符串
   97   1        va_list args;
   98   1        va_start(args, fmt);
   99   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
  100   1        va_end(args);
  101   1      
  102   1        p = (unsigned char *)buf;
  103   1        while (*p != '\0')
  104   1        {
  105   2          sendbyte3(*p);
  106   2          p++;
  107   2        }
  108   1      }
  109          char code duanzhi[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e
             -, 0x79, 0x71, 0x76, 0x00, 0x40, 0xff};
  110          
  111          sbit led4 = P4 ^ 3;
  112          sbit led3 = P4 ^ 4;
  113          sbit led2 = P2 ^ 0;
  114          sbit led1 = P2 ^ 1;
  115          #define Y0 led1
  116          #define Y1 led2
  117          #define Y2 led3
  118          #define Y3 led4
  119          
  120          char yout_set(char weizhi, char zhi)
  121          {
  122   1        if (weizhi == 0)
C251 COMPILER V5.60.0,  main                                                               31/07/23  20:42:27  PAGE 3   

  123   1          Y0 = zhi;
  124   1        if (weizhi == 1)
  125   1          Y1 = zhi;
  126   1        if (weizhi == 2)
  127   1          Y2 = zhi;
  128   1        if (weizhi == 3)
  129   1          Y3 = zhi;
  130   1      
  131   1        return (0);
  132   1      }
  133          void yout_closeall()
  134          {
  135   1        char i;
  136   1        for (i = 0; i < 4; i++)
  137   1        {
  138   2          yout_set(i, 1);
  139   2        }
  140   1      }
  141          void Delay10us() //@24.000MHz
  142          {
  143   1        unsigned long i;
  144   1      
  145   1        _nop_();
  146   1        _nop_();
  147   1        _nop_();
  148   1        i = 58UL;
  149   1        while (i)
  150   1          i--;
  151   1      }
  152          void delay10x(int i)
  153          {
  154   1        while (i-- > 0)
  155   1        {
  156   2          Delay10us();
  157   2        }
  158   1      }
  159          void showpre(int num)
  160          {
  161   1        int i;
  162   1        int a[4];
  163   1        a[0] = num % 10000 / 1000;
  164   1        a[1] = num % 1000 / 100;
  165   1      
  166   1        a[2] = num % 100 / 10;
  167   1        a[3] = num % 10;
  168   1      
  169   1        for (i = 0; i < 4; i++)
  170   1        {
  171   2          yout_closeall();
  172   2          yout_set(i, 0);
*** WARNING C188 IN LINE 172 OF main.c: 'parameter 1': value truncated
  173   2          P0 = ~duanzhi[a[i]];
  174   2          Delay10us();
  175   2          yout_closeall();
  176   2          P0 = 0xff;
  177   2          Delay10us();
  178   2        }
  179   1      }
  180          
  181          void testmain()
  182          {
  183   1        int a, b;
  184   1        int times = 0;
  185   1      }
*** WARNING C47 IN LINE 183 OF main.c: 'a': unreferenced local variable
*** WARNING C47 IN LINE 183 OF main.c: 'b': unreferenced local variable
C251 COMPILER V5.60.0,  main                                                               31/07/23  20:42:27  PAGE 4   

  186          
  187          
  188          void dealchuankou();
  189          int gsetzhi = 600;
  190          
  191          
  192          
  193          
  194          
  195          
  196          
  197          char* mystrstr(const char* haystack, const char* needle) {
  198   1          if (*needle == '\0') {
  199   2              return (char*)haystack;
  200   2          }
  201   1      
  202   1          while (*haystack != '\0') {
  203   2              const char* h = haystack;
  204   2              const char* n = needle;
  205   2      
  206   2              while (*n != '\0' && *h == *n) {
  207   3                  h++;
  208   3                  n++;
  209   3              }
  210   2      
  211   2              if (*n == '\0') {
  212   3                  return (char*)haystack; // 子串匹配成功，返回起始位置
  213   3              }
  214   2      
  215   2              haystack++;
  216   2          }
  217   1      
  218   1          return NULL; // 未找到子串，返回NULL
  219   1      }
  220          size_t mystrlen(const char* str) {
  221   1          size_t length = 0;
  222   1          while (str[length] != '\0') {
  223   2              length++;
  224   2          }
  225   1          return length;
  226   1      }
  227          
  228          char* myaddstrstr(const char* haystack, const char* needle)
  229          { 
  230   1        char* result = mystrstr(haystack, needle);
  231   1         if (result != NULL)
  232   1         {
  233   2          result=result+mystrlen(needle);
  234   2         }
  235   1         return result;
  236   1      }
  237          
  238          #define MAX_REGISTERS 10 // 设置最大寄存器数量
  239          
  240          struct Register
  241          {
  242            unsigned int num;
  243            unsigned int value;
  244          };
  245          struct Register registers[MAX_REGISTERS];
  246          int numRegisters = 0;
  247          void showgetzhi()
  248          {
  249   1        unsigned char i;
  250   1        if (i == 0)
  251   1        {
C251 COMPILER V5.60.0,  main                                                               31/07/23  20:42:27  PAGE 5   

  252   2          printf1("Register not get");
  253   2        }
  254   1        // 遍历并打印所有寄存器的值
  255   1        for (i = 0; i < numRegisters; i++)
  256   1        {
  257   2          printf1("Register %d: %d\n", registers[i].num, registers[i].value);
  258   2        }
  259   1      }
  260          
  261          #define MAXgetzhi 100
  262          int getzhi[MAXgetzhi]={0};
  263          void jixi3(char* input)
  264          {
  265   1        char *p=input;
  266   1        char *p1;
  267   1        int i;
  268   1        numRegisters=0;
  269   1        //1234-2234;333-4;end
  270   1        for( i=0;i<100;i++)
  271   1        {
  272   2          p1=myaddstrstr(p,";"); //找有没有下一个的
  273   2          if(p1==NULL)
  274   2          {
  275   3            break;
  276   3          }
  277   2          registers[numRegisters].num = atoi(p);
  278   2          p=myaddstrstr(p,"-");
  279   2          registers[numRegisters].value = atoi(p);
  280   2          numRegisters++;
  281   2          p=myaddstrstr(p,";");  //指向下一个后面
  282   2        }
  283   1        showgetzhi();
  284   1      }
  285          // 分离，发命令，20发读的命令，返回的值，默认是电流值。。。
  286          void jixi2(char* input)
  287          {
  288   1        char *p=input;
  289   1        char *p1;
  290   1        int i;
  291   1        unsigned int weizhi;
  292   1        unsigned int zhi;
  293   1        //1234-2234;333-4;end
  294   1        for( i=0;i<100;i++)
  295   1        {
  296   2          p1=myaddstrstr(p,";"); //找有没有下一个的
  297   2          if(p1==NULL)
  298   2          {
  299   3            break;
  300   3          }
  301   2          weizhi = atoi(p);
  302   2          p=myaddstrstr(p,"-");
  303   2          zhi = atoi(p);
  304   2          if(weizhi<MAXgetzhi)
  305   2          getzhi[weizhi]=zhi;
  306   2          p=myaddstrstr(p,";");  //指向下一个后面
  307   2          printf1("get set%d-%d",weizhi,zhi);
  308   2          push2(weizhi,zhi);
  309   2          
  310   2        }
  311   1      }
  312          int flaginit=0;
  313          void setzhione(int dizhi,int zhi)
  314          {
  315   1        if(flaginit==0)
  316   1        {
  317   2          return ;
C251 COMPILER V5.60.0,  main                                                               31/07/23  20:42:27  PAGE 6   

  318   2        }
  319   1        push(dizhi,zhi);
  320   1      }
  321          void jiexi(char* input)
  322          {
  323   1        char par[500]={0};
  324   1        char *begin,end;
  325   1        begin=myaddstrstr(input,"set:");
  326   1        // printf1("input begin%s",begin);
  327   1        end=myaddstrstr(begin,"end");
*** WARNING C161 IN LINE 327 OF main.c: 'far' pointer truncated to 'char'
*** WARNING C10 IN LINE 327 OF main.c: conversion: 'pointer' to 'char'
  328   1        // printf1("input end%s",end);
  329   1        if(begin!=NULL && end!=NULL)
*** WARNING C40 IN LINE 329 OF main.c: 'char' converted to 'far' pointer
  330   1        {
  331   2          strcpy(par,begin);
  332   2          jixi2(par);
  333   2        }
  334   1      }
  335          
  336          
  337          
  338          
  339          int setprezhi;
  340          
  341          int dianliusettime=0;
  342          char flagdianliuset=0;
  343          void setdianliusettime(int zhi)
  344          {
  345   1        if(dianliusettime!=0)
  346   1        {
  347   2          return ;
  348   2        }
  349   1        dianliusettime=zhi;
  350   1      }
  351          void changedainliuzhi()
  352          {
  353   1        if(setprezhi!=gsetzhi)
  354   1        {
  355   2          setprezhi=gsetzhi;
  356   2          setdianliusettime(250);
  357   2        }
  358   1      }
  359          
  360          
  361          
  362          char xin[30] = {0};
  363          sbit X0=P1^3;
  364          sbit X1=P1^1;
  365          void shurulvbo(void)
  366          {
  367   1        static u8 keybuf[40] = {
  368   1          0xFF,
  369   1          0xFF,
  370   1          0xFF,
  371   1          0xFF,
  372   1          0xFF,
  373   1          0xFF,
  374   1          0xFF,
  375   1          0xFF,
  376   1          0xFF,
  377   1          0xFF,
  378   1          0xFF,
  379   1          0xFF,
  380   1          0xFF,
C251 COMPILER V5.60.0,  main                                                               31/07/23  20:42:27  PAGE 7   

  381   1          0xFF,
  382   1          0xFF,
  383   1          0xFF,
  384   1          0xFF,
  385   1          0xFF,
  386   1          0xFF,
  387   1          0xFF,
  388   1          0xFF,
  389   1          0xFF,
  390   1          0xFF,
  391   1          0xFF,
  392   1          0xFF,
  393   1          0xFF,
  394   1          0xFF,
  395   1          0xFF,
  396   1          0xFF,
  397   1          0xFF,
  398   1          0xFF,
  399   1          0xFF,
  400   1          0xFF,
  401   1          0xFF,
  402   1          0xFF,
  403   1          0xFF,
  404   1          0xFF,
  405   1          0xFF,
  406   1          0xFF,
  407   1          0xFF,
  408   1        }; // 矩阵按键扫描缓冲区 8ms
  409   1        unsigned char i;
  410   1        i = X0;
  411   1        keybuf[0] = (keybuf[0] << 1) | i;
  412   1        i = X1;
  413   1        keybuf[1] = (keybuf[1] << 1) | i;
  414   1        // i = X2;
  415   1        // keybuf[2] = (keybuf[2] << 1) | i;
  416   1        // i = X3;
  417   1        // keybuf[3] = (keybuf[3] << 1) | i;
  418   1        for (i = 0; i < 2; i++) // 3按键，所以循环3次
  419   1        {
  420   2          if ((keybuf[i] & 0xFF) == 0x00)
  421   2          {
  422   3            xin[i] = 0;
  423   3          }
  424   2          else if ((keybuf[i] & 0xFF) == 0xFF)
  425   2          { // 连续3次扫描值为1，即1*8ms内都是弹起状态时，可认为按键已稳定的弹起
  426   3            xin[i] = 1;
  427   3          }
  428   2        }
  429   1      }
  430          char flagsetliangdu=0;
  431          void writebuf();
  432          void keydown(int i) // 按键按下的处理、、、
  433          {
  434   1        
  435   1        printf1("keydown %d",i);
  436   1        if(i==0)
  437   1          setzhione(4,gsetzhi);
  438   1        if(i==1)
  439   1        {
  440   2          // if(flagsetliangdu==0)//不能设置值。。变成设置
  441   2          // {
  442   2      
  443   2          // }
  444   2          if(flagsetliangdu==1)//保存记录的值
  445   2          {
  446   3            printf1("flagsetliangdusetzhi %d",gsetzhi);
C251 COMPILER V5.60.0,  main                                                               31/07/23  20:42:27  PAGE 8   

  447   3            writebuf();   
  448   3          }
  449   2          flagsetliangdu=1-flagsetliangdu;
  450   2        }
  451   1          
  452   1      
  453   1      }
  454          void keyup(int i) // 按键按下的处理、、、
  455          {
  456   1        printf1("keyup %d",i);
  457   1        if(i==0)
  458   1          setzhione(4,0);
  459   1      }
  460          void keyallchuli()
  461          {
  462   1        int i;
  463   1        static char flag[10] = {0};   // 标志记录
  464   1        static int dowmtimes[10] = {0}; // 标志记录
  465   1        for (i = 0; i < 6; i++)
  466   1        {
  467   2          if (xin[i] == 0)
  468   2          {
  469   3            if (flag[i] == 0) // 代表按键第一次按下。。。
  470   3            {
  471   4              flag[i] = 1;
  472   4              keydown(i);
  473   4            }
  474   3          }
  475   2          if (xin[i] == 1)
  476   2          {
  477   3            if (flag[i] == 1) // 代表下去了又上来
  478   3            {
  479   4              keyup(i);
  480   4            }
  481   3            flag[i] = 0;
  482   3            
  483   3          }
  484   2        }
  485   1      }
  486          void dealorder();
  487          void getdianliupre()
  488          {
  489   1      
  490   1      }
  491          int timereport=0;
  492          
  493          void init2test()
  494          {
  495   1        Alltongxininfo2 get={0};
  496   1        printf1("read begin");
  497   1        while (1)
  498   1        {
  499   2          if(timereport%1000==0)
  500   2          {
  501   3            printf1("read[%d].....",timereport);
  502   3          }
  503   2          if(timereport>3000)
  504   2          {
  505   3            printf1("read failed");
  506   3            break;
  507   3          }
  508   2          pop22(&get);
  509   2          if(get.weizhi==4)
  510   2          {
  511   3            get.zhi=get.zhi/2;
  512   3            gsetzhi=get.zhi;
C251 COMPILER V5.60.0,  main                                                               31/07/23  20:42:27  PAGE 9   

  513   3            printf1("read over %d ",gsetzhi);
  514   3            break;
  515   3          }
  516   2          dealorder();//取缓冲区里面的命令进行发送
  517   2          showpre(gsetzhi);
  518   2          dealchuankou();//解析上来的串口命令。
  519   2        }
  520   1        
  521   1      }
  522          int errpromdizhi=0x000040;
  523          void writebuf()
  524          {
  525   1        u8 get[10];
  526   1        get[0]=55;
  527   1        get[1]=gsetzhi/100;
  528   1        get[2]=gsetzhi%100;
  529   1        EEPROM_SectorErase(errpromdizhi);
  530   1        EEPROM_write_n(errpromdizhi,get,3);
  531   1      }
  532          
  533          void readbuf()
  534          {
  535   1        u8 get[10];
  536   1      
  537   1          EEPROM_read_n(errpromdizhi,get,3);
  538   1          if(get[0]==55)
  539   1          {
  540   2              printf("has init\n");
  541   2          gsetzhi=get[1]*100+get[2];
  542   2          if(gsetzhi>=1023)
  543   2          {
  544   3            gsetzhi=1023;
  545   3          }
  546   2          if(gsetzhi<=0)
  547   2          {
  548   3            gsetzhi=0;
  549   3          }
  550   2          printf("has init %d-%d\n",get[1],get[2]);
  551   2          }
  552   1          else
  553   1          {
  554   2              printf("not init\n");
  555   2          get[0]=55;
  556   2          gsetzhi=550;
  557   2            EEPROM_write_n(errpromdizhi,get,1);
  558   2          }
  559   1      }
  560          sbit keyled1=P3^6;
  561          sbit keyled2=P3^5;
  562          #define ledon 0
  563          #define ledclose 1
  564          void showled()
  565          {
  566   1        keyled1=ledclose;
  567   1        keyled2=ledclose;
  568   1        keyled2=ledon;
  569   1      }
  570          // void test3()
  571          // {
  572          //  int i;
  573          //  for(i=0;i<1023;i=i+100)
  574          //  {
  575          //    gsetzhi=i;
  576              
  577          //    writebuf();
  578          //    readbuf();
C251 COMPILER V5.60.0,  main                                                               31/07/23  20:42:27  PAGE 10  

  579          //  }
  580          // }
  581          void main(void)
  582          {
  583   1      
  584   1        SYS_Ini();    // STC32初始化设置
  585   1        PWM_Config(); // PWM初始化设置
  586   1        EA = 1;     // 使能EA总中断
  587   1      
  588   1        UartInit();
  589   1        Uart23Init();
  590   1        printf1("system is ok");
  591   1        Timer0Init();
  592   1        printf1("system is overall");
  593   1        
  594   1        keyallchuli();
  595   1        flaginit=1;
  596   1        setzhione(4,0);
  597   1        // test3();
  598   1        readbuf();
  599   1        while (1)
  600   1        {
  601   2          showled();
  602   2          keyallchuli();
  603   2          showpre(gsetzhi);
  604   2          dealorder();//取缓冲区里面的命令进行发送
  605   2          dealchuankou();//解析上来的串口命令。
  606   2        }
  607   1      }
  608          
  609          void PWM_ISR() interrupt 26
  610          {
  611   1        if (PWMA_SR1 & 0X02) // 当捕获中断标志置1
  612   1        {
  613   2          cnt_H = PWMA_CCR1H; // 读取计数值高8位
  614   2          cnt_L = PWMA_CCR1L; // 读取计数值低8位
  615   2          PWMA_SR1 &= ~0X02;  // 清零捕获中断标志
  616   2          EC11_Handle();    // 处理EC11数据
  617   2        }
  618   1      }
  619          void PWM_Config() // PWM初始化设置
  620          {
  621   1        PWMA_CCER1 = 0x00; // 关闭通道
  622   1        PWMA_CCMR1 = 0xA1; // 通道模式配置为输入，接编码器 , 滤波器 80 时钟
  623   1        PWMA_CCMR2 = 0xA1; // 通道模式配置为输入，接编码器 , 滤波器 80 时钟
  624   1        PWMA_CCER1 = 0x55; // 使能捕获/比较通道1、通道2
  625   1      
  626   1        //  PWMA_SMCR = 0x01;         // 编码器模式 1
  627   1        //  PWMA_SMCR = 0x02;         // 编码器模式 2
  628   1        PWMA_SMCR = 0x03; // 编码器模式 3
  629   1      
  630   1        PWMA_IER = 0x02;  // 使能中断
  631   1        PWMA_CR1 |= 0x01; // 使能计数器
  632   1        PWMA_PS |= 0x04;  // 选择 PWM2_2 通道
  633   1      }
  634          
  635          // 返回变化的步数
  636          long calculateChange(unsigned int previous, unsigned int current)
  637          {
  638   1        long diff = (current - previous + 65536) % 65536;
*** WARNING C188 IN LINE 638 OF main.c: 'initialization': value truncated
  639   1        return diff;
  640   1      }
  641          
  642          char buf3[500];
  643          char flag3 = 0;
C251 COMPILER V5.60.0,  main                                                               31/07/23  20:42:27  PAGE 11  

  644          int weishu3;
  645          int timeleft1, timeleft2, timeleft3, timeleft4;
  646          void chuankou1put(char c)
  647          {
  648   1        buf3[weishu3++] = c;
  649   1        if (weishu3 > sizeof(buf3) - 3)
  650   1          weishu3 = 0;
  651   1        timeleft3 = 3;
  652   1      }
  653          void chuankou1time()
  654          {
  655   1        if (timeleft3 > 0)
  656   1        {
  657   2          timeleft3--;
  658   2          if (timeleft3 == 0) // 数据一次收完了.
  659   2          {
  660   3            flag3 = 1;
  661   3          }
  662   2        }
  663   1      }
  664          char get1[100];
  665          int weizhi1=0;
  666          void chuliguankji()
  667          {
  668   1          char* index;
  669   1          index=mystrstr(get1,"@STCISP#");
  670   1        if(index==0)
  671   1        {
  672   2            return  ;
  673   2        }
  674   1          IAP_CONTR=0x60;
  675   1      }
  676          void UARTInterrupt(void) interrupt 4
  677          {
  678   1        unsigned char ans;
  679   1        if (RI)
  680   1        {
  681   2          RI = 0;
  682   2          ans = SBUF;
  683   2          get1[weizhi1++]=ans;
  684   2          if(weizhi1>80)
  685   2          {
  686   3            weizhi1=0;
  687   3          }
  688   2          chuliguankji();
  689   2          // IAP_CONTR=0x60;
  690   2        }
  691   1        else
  692   1        {
  693   2          TI = 0;
  694   2        }
  695   1        if (TI) // 发送中断..
  696   1        {
  697   2          TI = 0;
  698   2        }
  699   1      }
  700          void addgetsetzhi(int i)
  701          {
  702   1        int ans;
  703   1        ans=gsetzhi+i;
  704   1        if(ans>=0 && ans<=1023)
  705   1        {
  706   2          gsetzhi=ans;
  707   2        }
  708   1      }
  709          static int timepush=0;
C251 COMPILER V5.60.0,  main                                                               31/07/23  20:42:27  PAGE 12  

  710          void dealorder()
  711          {
  712   1        char out[30]={0};
  713   1        Alltongxininfo get;
  714   1        if(timepush>45)
  715   1        {
  716   2          timepush=0;
  717   2          pop2(&get);
  718   2          if(get.weizhi==4)
  719   2          {
  720   3            get.zhi=get.zhi*bili;
  721   3          }
  722   2          sprintf(out,"set:%d-%d;end",get.weizhi,get.zhi);
  723   2          printf3(out);
  724   2        }
  725   1      }
  726          void Timer0() interrupt 1
  727          {
  728   1        timereport++;
  729   1        shurulvbo();
  730   1        chuankou1time();
  731   1        if(!empty())
*** WARNING C140 IN LINE 731 OF main.c: 'empty' undefined; assuming 'extern int empty()'
  732   1        {
  733   2          timepush++;
  734   2        }
  735   1      }
  736          void EC11_Handle() // EC11数据处理函数
  737          {
  738   1        static unsigned int previous = 0;
  739   1        unsigned int nowzhi;
  740   1        long ans;
  741   1        nowzhi = cnt_H * 256 + cnt_L; // 读取当前计数值
  742   1        ans = calculateChange(previous, nowzhi);
  743   1        previous = nowzhi;
  744   1        if(flagsetliangdu==1)
  745   1        {
  746   2          if (ans == 4)
  747   2          {
  748   3            addgetsetzhi(1);
  749   3          }
  750   2          else
  751   2          {
  752   3            addgetsetzhi(-1);
  753   3          }
  754   2          // 设定电流值。。。
  755   2          setzhione(4,gsetzhi);
  756   2          // setzhione(2,1);//开灯。。
  757   2        }
  758   1        
  759   1      }
  760          
  761          int step=0;
  762          void showstep(const char *s)
  763          {
  764   1        printf1("%s\n",s);
  765   1      }
  766          char* my_strstr(const char* haystack, const char* needle) {
  767   1          if (*needle == '\0') {
  768   2              return (char*) haystack;
  769   2          }
  770   1      
  771   1          while (*haystack != '\0') {
  772   2              const char* h = haystack;
  773   2              const char* n = needle;
  774   2      
C251 COMPILER V5.60.0,  main                                                               31/07/23  20:42:27  PAGE 13  

  775   2              while (*h == *n && *n != '\0') {
  776   3                  h++;
  777   3                  n++;
  778   3              }
  779   2      
  780   2              if (*n == '\0') {
  781   3                  return (char*) haystack;
  782   3              }
  783   2      
  784   2              haystack++;
  785   2          }
  786   1      
  787   1          return NULL;
  788   1      }
  789          
  790          void dealchuankou()
  791          {
  792   1        if (flag3 == 1)
  793   1        {
  794   2          flag3 = 0;
  795   2          jiexi(buf3);
  796   2          memset(buf3, 0, sizeof(buf3));
  797   2          weishu3 = 0;
  798   2        }
  799   1      }
  800          
  801          
  802          void Uart3() interrupt 17 using 1
  803          {
  804   1        char temp3; 
  805   1          if (S3CON & S3RI)
  806   1          {
  807   2              S3CON &= ~S3RI; //??S3RI?
  808   2          temp3 = S3BUF;
  809   2          chuankou1put(temp3);
  810   2              // chuankou3put(temp3);
  811   2          }
  812   1          if (S3CON & S3TI)
  813   1          {
  814   2              S3CON &= ~S3TI; // 清除S3TI位
  815   2              busy3 = 0;      // 清忙标志
  816   2          }
  817   1      }
  818          // 写个函数，传入两个非负数，计算是前进还是后退了，变化规律 15,16,0,1,2...15,16


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3076     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       983        934
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      1205     ------
End of Module Information.


C251 COMPILATION COMPLETE.  9 WARNING(S),  0 ERROR(S)
