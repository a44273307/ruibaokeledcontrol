C51 COMPILER V9.00   MAIN                                                                  07/19/2023 03:58:02 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil2\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /************************************************************************************
   2             
   3          程序名称： （晶振频率18.432MHz） 
   4          功能说明: 通过串口3发送“Everything is possible!”  
   5                    波特率9600，数据位8，奇偶效验无，停止位1，数据流控制无  
   6          ************************************************************************************/
   7          #include "stc15f2k60s2.h"           // 单片机STC15F2K60S2头文件,可以不再加入reg51.h
   8          #include <intrins.h>                                    // 加入此头文件后,可使用_nop_库函数
   9          #include "delay.h"                      // 延时函数头文件
  10          #include "uart.h"                               // 串行通信函数头文件
  11          #define  uint unsigned int  
  12          #define  uchar unsigned char    
  13          #include <stdio.h>
  14          #include <string.h>
  15          #include "MODBUS.h"
  16          
  17          #include <stdio.h>
  18          #include <string.h>
  19          #include <stdlib.h>
  20          
  21          
  22          char buf3[500];
  23          char flag3 = 0;
  24          int weishu3;
  25          int timeleft1, timeleft2, timeleft3, timeleft4;
  26          void chuankou1put(char c)
  27          {
  28   1              buf3[weishu3++] = c;
  29   1              if (weishu3 > sizeof(buf3) - 3)
  30   1                      weishu3 = 0;
  31   1              timeleft3 = 3;
  32   1      }
  33          void chuankou1time()
  34          {
  35   1              if (timeleft3 > 0)
  36   1              {
  37   2                      timeleft3--;
  38   2                      if (timeleft3 == 0) // 数据一次收完了.
  39   2                      {
  40   3                              flag3 = 1;
  41   3                      }
  42   2              }
  43   1      }
  44          
  45          #define MAXgetzhi 100
  46          int getzhi[MAXgetzhi]={0};
  47          
  48          
  49          char* mystrstr(const char* haystack, const char* needle) {
  50   1          if (*needle == '\0') {
  51   2              return (char*)haystack;
  52   2          }
  53   1      
  54   1          while (*haystack != '\0') {
  55   2              const char* h = haystack;
C51 COMPILER V9.00   MAIN                                                                  07/19/2023 03:58:02 PAGE 2   

  56   2              const char* n = needle;
  57   2      
  58   2              while (*n != '\0' && *h == *n) {
  59   3                  h++;
  60   3                  n++;
  61   3              }
  62   2      
  63   2              if (*n == '\0') {
  64   3                  return (char*)haystack; // 子串匹配成功，返回起始位置
  65   3              }
  66   2      
  67   2              haystack++;
  68   2          }
  69   1      
  70   1          return NULL; // 未找到子串，返回NULL
  71   1      }
  72          size_t mystrlen(const char* str) {
  73   1          size_t length = 0;
  74   1          while (str[length] != '\0') {
  75   2              length++;
  76   2          }
  77   1          return length;
  78   1      }
  79          
  80          char* myaddstrstr(const char* haystack, const char* needle)
  81          {       
  82   1              char* result = mystrstr(haystack, needle);
  83   1               if (result != NULL)
  84   1               {
  85   2                      result=result+mystrlen(needle);
  86   2               }
  87   1               return result;
  88   1      }
  89          void jixi2(char* input)
  90          {
  91   1              char *p=input;
  92   1              char *p1;
  93   1              int i;
  94   1              unsigned int weizhi;
  95   1              unsigned int zhi;
  96   1              //1234-2234;333-4;end
  97   1              for( i=0;i<100;i++)
  98   1              {
  99   2                      p1=myaddstrstr(p,";"); //找有没有下一个的
 100   2                      if(p1==NULL)
 101   2                      {
 102   3                              break;
 103   3                      }
 104   2                      weizhi = atoi(p);
 105   2                      p=myaddstrstr(p,"-");
 106   2                      zhi = atoi(p);
 107   2                      if(weizhi<MAXgetzhi)
 108   2                      getzhi[weizhi]=zhi;
 109   2                      p=myaddstrstr(p,";");  //指向下一个后面
 110   2                      printf("get set%d-%d",weizhi,zhi);
 111   2              }
 112   1      }
 113          void jiexi(char* input)
 114          {
 115   1              char par[500]={0};
 116   1              char *begin,end;
 117   1              begin=myaddstrstr(input,"set:");
C51 COMPILER V9.00   MAIN                                                                  07/19/2023 03:58:02 PAGE 3   

 118   1              // printf("input begin%s",begin);
 119   1              end=myaddstrstr(begin,"end");
*** WARNING C260 IN LINE 119 OF MAIN.C: '=': pointer truncation
 120   1              // printf("input end%s",end);
 121   1              if(begin!=NULL && end!=NULL)
 122   1              {
 123   2                      strcpy(par,begin);
 124   2                      jixi2(par);
 125   2              }
 126   1      }
 127          
 128          char* my_strstr(const char* haystack, const char* needle) {
 129   1          if (*needle == '\0') {
 130   2              return (char*) haystack;
 131   2          }
 132   1      
 133   1          while (*haystack != '\0') {
 134   2              const char* h = haystack;
 135   2              const char* n = needle;
 136   2      
 137   2              while (*h == *n && *n != '\0') {
 138   3                  h++;
 139   3                  n++;
 140   3              }
 141   2      
 142   2              if (*n == '\0') {
 143   3                  return (char*) haystack;
 144   3              }
 145   2      
 146   2              haystack++;
 147   2          }
 148   1      
 149   1          return NULL;
 150   1      }
 151          void dealchuankou()
 152          {
 153   1              if (flag3 == 1)
 154   1              {
 155   2                      flag3 = 0;
 156   2                      jiexi(buf3);
 157   2                      memset(buf3, 0, sizeof(buf3));
 158   2                      weishu3 = 0;
 159   2              }
 160   1      }
 161          
 162          
 163          
 164          
 165          
 166          
 167          
 168          
 169          
 170          
 171          
 172          
 173          
 174          
 175          
 176          int delay_mszhi;
 177          uint temp1,temp2,temp3,temp4;
 178          
C51 COMPILER V9.00   MAIN                                                                  07/19/2023 03:58:02 PAGE 4   

 179          
 180          void io_inint()
 181          {
 182   1              P0M1 = 0;       P0M0 = 0;       //设置P0.0~P0.7为准双向口
 183   1        P1M0 = 0x00; // 设置P1.0为ADC口
 184   1        P1M1 = 0x80;
 185   1              P2M1 = 0;       P2M0 = 0;       //设置P2.0~P2.7为准双向口 
 186   1                  P3M0 = 0;
 187   1          P3M1 = 0;
 188   1              P4M1 = 0;       P4M0 = 0;       //设置P4.0~P4.7为准双向口
 189   1              // P5M1 = 0;    P5M0 = 0;       //设置P5.0~P5.7为准双向口
 190   1      
 191   1                  P5M0 = 0xff; P5M1 = 0x00; 
 192   1      
 193   1      }
 194          
 195          
 196          void delay_ms(int m);
 197          
 198          
 199          
 200          sbit out2=P3^2;
 201          
 202          extern void deanyan();
 203          sbit fen=P5^4;
 204          
 205          #define Iapid 0x0000
 206          uchar p1, a_a;
 207          void IapIdle()
 208          {
 209   1        IAP_CONTR = 0;    // ??±?IAP????
 210   1        IAP_CMD = 0;      // ?????ü???????÷
 211   1        IAP_TRIG = 0;     // ??????・??????÷
 212   1        IAP_ADDRH = 0x80; // ?????・?è????・?IAP???ò
 213   1        IAP_ADDRL = 0;
 214   1      }
 215          
 216          uint8_t IapRead(int addr)
 217          {
 218   1        uint8_t dat;
 219   1      
 220   1        IAP_CONTR = 0x80;      // ????IAP
 221   1        IAP_TPS = 40;          // ?è??????????12MHz
 222   1        IAP_CMD = 1;           // ?è??IAP???ü??
 223   1        IAP_ADDRL = addr;      // ?è??IAP?????・
 224   1        IAP_ADDRH = addr >> 8; // ?è??IAP?????・
 225   1        IAP_TRIG = 0x5a;       // ????・??ü??(0x5a)
 226   1        IAP_TRIG = 0xa5;       // ????・??ü??(0xa5)
 227   1        _nop_();
 228   1        dat = IAP_DATA; // ??IAP????
 229   1        IapIdle();      // ??±?IAP????
 230   1      
 231   1        return dat;
 232   1      }
 233          
 234          void IapProgram(int addr, char dat)
 235          {
 236   1        IAP_CONTR = 0x80;      // ????IAP
 237   1        IAP_TPS = 40;          // ?è??????????12MHz
 238   1        IAP_CMD = 2;           // ?è??IAP???ü??
 239   1        IAP_ADDRL = addr;      // ?è??IAP?????・
 240   1        IAP_ADDRH = addr >> 8; // ?è??IAP?????・
C51 COMPILER V9.00   MAIN                                                                  07/19/2023 03:58:02 PAGE 5   

 241   1        IAP_DATA = dat;        // ??IAP????
 242   1        IAP_TRIG = 0x5a;       // ????・??ü??(0x5a)
 243   1        IAP_TRIG = 0xa5;       // ????・??ü??(0xa5)
 244   1        _nop_();
 245   1        IapIdle(); // ??±?IAP????
 246   1      }
 247          
 248          void IapErase(int addr)
 249          {
 250   1        IAP_CONTR = 0x80;      // ????IAP
 251   1        IAP_TPS = 40;          // ?è??????????12MHz
 252   1        IAP_CMD = 3;           // ?è??IAP?????ü??
 253   1        IAP_ADDRL = addr;      // ?è??IAP?????・
 254   1        IAP_ADDRH = addr >> 8; // ?è??IAP?????・
 255   1        IAP_TRIG = 0x5a;       // ????・??ü??(0x5a)
 256   1        IAP_TRIG = 0xa5;       // ????・??ü??(0xa5)
 257   1        _nop_();               //
 258   1        IapIdle();             // ??±?IAP????
 259   1      }
 260          
 261          //
 262          void write_eeprom()
 263          {
 264   1        IapErase(Iapid); // ????????
 265   1        IapProgram(Iapid + 1, p1);
 266   1      
 267   1        IapProgram(Iapid + 60, a_a);
 268   1      }
 269          /******************°????????????ú????eeprom????????*****************/
 270          void read_eeprom()
 271          {
 272   1        uchar t, t1;
 273   1        p1 = IapRead(Iapid + 1);
 274   1        a_a = IapRead(Iapid + 60);
 275   1      }
*** WARNING C280 IN LINE 272 OF MAIN.C: 't': unreferenced local variable
*** WARNING C280 IN LINE 272 OF MAIN.C: 't1': unreferenced local variable
 276          /**************???ú×??ìeeprom??????*****************/
 277          void init_eeprom()
 278          {
 279   1        read_eeprom();
 280   1        if (a_a != 6) // ?????????ú?????????ú????eeprom
 281   1        {
 282   2      
 283   2          p1 = 0;
 284   2          a_a = 6;
 285   2      
 286   2          write_eeprom(); // ±???????
 287   2        }
 288   1      }
 289          void Exxwrite(int addr, uint dat)
 290          {
 291   1          addr=addr*2;
 292   1          IapProgram(addr,dat/256);
 293   1          IapProgram(addr+1,dat%256);
 294   1      }
 295          uint ExxRead(int addr)
 296          {
 297   1          uint dat;
 298   1          addr=addr*2;
 299   1          dat=IapRead(addr);
 300   1          dat=dat*256;
C51 COMPILER V9.00   MAIN                                                                  07/19/2023 03:58:02 PAGE 6   

 301   1          dat=dat+IapRead(addr+1);
 302   1          return dat;
 303   1      }
 304          void writebuf();
 305          void initbuf()
 306          {
 307   1          int i;
 308   1          int dizhi=Iapid+1;
 309   1          for ( i = 0; i < len_HoldingReg; i++)
 310   1          {
 311   2              HoldingReg[i]=0;
 312   2          }
 313   1          if(123!=ExxRead(dizhi))//没有初始化，初始化一次。。
 314   1          {
 315   2              Exxwrite(dizhi,123);
 316   2              writebuf();
 317   2          }
 318   1          for ( i = 0; i < len_HoldingReg; i++)
 319   1          {
 320   2              dizhi=dizhi+1;
 321   2              HoldingReg[i]=ExxRead(dizhi);
 322   2              if(0!=HoldingReg[i] && -1 !=HoldingReg[i])
 323   2              {
 324   3                  printf("HoldingReg[%d]-[%d]",i,HoldingReg[i]);
 325   3              }
 326   2          }
 327   1      }
 328          void writebuf()
 329          {
 330   1          int i;
 331   1          int dizhi=Iapid+1;
 332   1          for ( i = 0; i < len_HoldingReg; i++)
 333   1          {
 334   2              dizhi=dizhi+1;
 335   2              Exxwrite(dizhi,HoldingReg[i]);
 336   2          }
 337   1      }
 338          // 比较值是否发生了变化。。
 339          uint16_t bufcheck[len_HoldingReg]={0};
 340          void buffchecktongbu()
 341          {
 342   1          int i;
 343   1          for ( i = 0; i < len_HoldingReg; i++)
 344   1          {
 345   2              bufcheck[i]=HoldingReg[i];
 346   2          }
 347   1      }
 348          int IsbuffcheckFailed()
 349          {
 350   1          int i;
 351   1          for ( i = 0; i < len_HoldingReg; i++)
 352   1          {
 353   2             if(bufcheck[i]!=HoldingReg[i])
 354   2             {
 355   3              return 1;
 356   3             }
 357   2          }
 358   1          return 0;
 359   1      }
 360          void main()                                                    
 361          {
 362   1              io_inint();
C51 COMPILER V9.00   MAIN                                                                  07/19/2023 03:58:02 PAGE 7   

 363   1          UartInit();
 364   1              Uart23Init();
 365   1              Timer0Init();
 366   1              Uart4Init();
 367   1              P_SW2 = 0x80;
 368   1          I2CCFG = 0xe0;                              //使能I2C主机模式
 369   1          I2CMSST = 0x00;
 370   1              EA = 1;
 371   1              out2=1;
 372   1              Modbus_ClearBuff();
 373   1          deanyan();
 374   1              delay_ms(10);
 375   1          printf("system init ok");
 376   1          initbuf();
 377   1          buffchecktongbu();
 378   1          printf("system init ok1");
 379   1          HoldingReg[2]=1;
 380   1          HoldingReg[4]=800;
 381   1          deanyan();
 382   1           printf("system init ok3");
 383   1              while (1)
 384   1              {
 385   2                      if (recover == 1)
 386   2              {
 387   3                  delay_mszhi=0;
 388   3                              chuliguankji();
*** WARNING C206 IN LINE 388 OF MAIN.C: 'chuliguankji': missing function-prototype
 389   3                  jishouokjisuan();
 390   3                  if(IsbuffcheckFailed())
 391   3                  {
 392   4                      
 393   4                      printf("xiugaidata begin");
 394   4                      buffchecktongbu();
 395   4                      deanyan();
 396   4                      writebuf();
 397   4                      printf("xiugaidata end %d",delay_mszhi);
 398   4                  }
 399   3                  recover = 0;
 400   3              }
 401   2              }
 402   1      } 
 403          int delay_mszhi;         
 404          uint time,lv_bo;
 405          void delay_ms(int m)
 406          {
 407   1          delay_mszhi=0;
 408   1          while (delay_mszhi<=m*2)
 409   1          {
 410   2              
 411   2          }
 412   1      }
 413          void Timer0() interrupt 1
 414          {
 415   1              time1msjisuan();
 416   1              delay_mszhi++;
 417   1      }
 418          void UARTInterrupt(void) interrupt 4
 419          {
 420   1              unsigned char ans;
 421   1              if (RI)
 422   1              {
 423   2                      RI = 0;
C51 COMPILER V9.00   MAIN                                                                  07/19/2023 03:58:02 PAGE 8   

 424   2                      ans=SBUF;
 425   2                      chuankou1jisuuan(ans);
 426   2              }
 427   1              else
 428   1              {
 429   2                      TI = 0;
 430   2              }
 431   1              if (TI) //发送中断..
 432   1              {
 433   2                      TI = 0;
 434   2              }
 435   1      }
 436          
 437          void uart2(void ) interrupt 8 
 438          {
 439   1        if (S2CON & S2RI)
 440   1              {
 441   2                      S2CON &= ~S2RI;         
 442   2                      temp2 = S2BUF;
 443   2              }
 444   1        if (S2CON & S2TI)
 445   1          {
 446   2                              //y1=0;
 447   2              S2CON &= ~S2TI;         //清除S2TI位
 448   2              busy2 = 0;               //清忙标志
 449   2          }  
 450   1      }
 451          
 452            
 453          
 454          
 455          void Uart3() interrupt 17 using 1
 456          {
 457   1          if (S3CON & S3RI)
 458   1          {
 459   2              S3CON &= ~S3RI;         //??S3RI?
 460   2              temp3 = S3BUF;
 461   2                                      
 462   2         }
 463   1      if (S3CON & S3TI)
 464   1          {
 465   2              S3CON &= ~S3TI;         //清除S3TI位
 466   2              busy3 = 0;               //清忙标志
 467   2          }
 468   1      }
 469          
 470          void Uart4() interrupt 18 
 471          {
 472   1          if (S4CON & S4RI)
 473   1          {
 474   2              S4CON &= ~S4RI;         //??S4RI?
 475   2              temp4=S4BUF;
 476   2         }
 477   1      if(TI4)
 478   1              {
 479   2                      CLR_TI4();
 480   2                      busy4 = 0;               //清忙标志
 481   2              }
 482   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.00   MAIN                                                                  07/19/2023 03:58:02 PAGE 9   

   CODE SIZE        =   2303    ----
   CONSTANT SIZE    =    628    ----
   XDATA SIZE       =    767     566
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
