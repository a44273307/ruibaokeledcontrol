C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc251\C251\BIN\C251.EXE main.c LARGE BROWSE DEBUG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.
                    -\Objects\main.obj) 

stmt  level    source

    1          //  @布丁橘长 2023/03/10
    2          //  PWM编码器模式示例，本示例程序编码器模式1/2/3均支持，SMCR = 1：模式1，SMCR = 2:模式2，SMCR = 3：模式3
    3          //  EC11左旋或右旋，改变数码管亮度
    4          //  EC11引脚定义：A相-P1.0，B相-P5.4
    5          //  MAX7219数码管模块引脚定义：CS = P6^5;DIN = P6^6;CLK = P6^4;（可在MAX7219.h中修改）
    6          //  实验开发板：屠龙刀三.1 @主频12MHz
    7          
    8          
    9          
   10          
   11          
   12          
   13          
   14          
   15          #include <string.h>
   16          #include "stc32g.h"
   17          #include "config.h"
   18          
   19          
   20          #include <stdio.h>
   21          #include <stdarg.h>
   22          #include <stdio.h>
   23          
   24          #include <stdlib.h>
   25          #include "uart.h"
*** WARNING C317 IN LINE 24 OF uart.h: attempt to redefine macro 'MAIN_Fosc'
   26          #include "tongxin.h"
   27          #include "tongxin2.h"
   28          #include "STC32G_EEPROM.h"
   29          
   30          void SYS_Ini();   // STC32初始化设置
   31          void EC11_Handle(); // EC11数据处理
   32                    // 数码管显示
   33          void PWM_Config(); // PWM初始化设置
   34          
   35          u8 cnt_H, cnt_L;   // 计数值高8位、低8位
   36          u16 count, newcount; // 当前计数值、上次计数值
   37                     // 亮度计数值
   38          
   39          
   40          
   41          char rec2[500];
   42          int weizhi2=0;
   43          // 01 是用力啊检查地址的，，默认55
   44          u16 g_reg[40]={0};
   45          #define indexAdddianliu 20
   46          #define indexTImeuse 21
   47          #define indexTImeAll 22
   48          #define indexMAXdianliu 23
   49          
   50          
   51          
   52          // 最后下去到板子的要乘以2，，最后的计算值。。
   53          
   54          int bili=2;
   55          void SYS_Ini() // STC32初始化设置
   56          {
   57   1        EAXFR = 1;    // 使能访问 XFR
C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 2   

   58   1        CKCON = 0x00; // 设置外部数据总线速度为最快
   59   1        WTST = 0x00;  // 设置程序代码等待参数，赋值为 0 可将 CPU 执行程序的速度设置为最快
   60   1        P0M1 = 0x00;
   61   1        P0M0 = 0x00; // 设置P0口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   62   1        P1M1 = 0x00;
   63   1        P1M0 = 0x00; // 设置P1口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   64   1        P2M1 = 0x00;
   65   1        P2M0 = 0x00; // 设置P2口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   66   1        P3M1 = 0x00;
   67   1        P3M0 = 0x00; // 设置P3口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   68   1        P4M1 = 0x00;
   69   1        P4M0 = 0x00; // 设置P4口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   70   1        P5M1 = 0x00;
   71   1        P5M0 = 0x00; // 设置P5口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   72   1        P6M1 = 0x00;
   73   1        P6M0 = 0x00; // 设置P6口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   74   1        P7M1 = 0x00;
   75   1        P7M0 = 0x00; // 设置P7口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   76   1      }
   77          
   78          
   79          
   80          void Delay100ms() //@24.000MHz
   81          {
   82   1        unsigned long i;
   83   1      
   84   1        _nop_();
   85   1        _nop_();
   86   1        i = 599998UL;
   87   1        while (i)
   88   1          i--;
   89   1      }
   90          // 定义printf函数
   91          void printf1(const char *fmt, ...)
   92          {
   93   1        char *p;
   94   1        char buf[128]; // 定义一个缓冲区，足够存储输出的字符串
   95   1        va_list args;
   96   1        va_start(args, fmt);
   97   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
   98   1        va_end(args);
   99   1      
  100   1        p = (unsigned char *)buf;
  101   1        while (*p != '\0')
  102   1        {
  103   2          sendbyte1(*p);
  104   2          p++;
  105   2        }
  106   1      }
  107          
  108          // 定义printf函数
  109          void printtoDianao(const char *fmt, ...)
  110          {
  111   1        char *p;
  112   1        char buf[400]={0}; // 定义一个缓冲区，足够存储输出的字符串
  113   1        va_list args;
  114   1        va_start(args, fmt);
  115   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
  116   1        va_end(args);
  117   1        p = (unsigned char *)buf;
  118   1        while (*p != '\0')
  119   1        {
  120   2          sendbyte1(*p);
  121   2          p++;
  122   2        }
  123   1      }
C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 3   

  124          
  125          
  126          
  127          
  128          // 定义printf函数
  129          void printfTopingmu(const char *fmt, ...)
  130          {
  131   1        char *p;
  132   1        char buf[128]; // 定义一个缓冲区，足够存储输出的字符串
  133   1        va_list args;
  134   1        va_start(args, fmt);
  135   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
  136   1        va_end(args);
  137   1      
  138   1        p = (unsigned char *)buf;
  139   1        while (*p != '\0')
  140   1        {
  141   2          sendbyte3(*p);
  142   2          p++;
  143   2        }
  144   1      }
  145          
  146          char code duanzhi[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e
             -, 0x79, 0x71, 0x76, 0x00, 0x40, 0xff};
  147          
  148          sbit led4 = P4 ^ 3;
  149          sbit led3 = P4 ^ 4;
  150          sbit led2 = P2 ^ 0;
  151          sbit led1 = P2 ^ 1;
  152          #define Y0 led1
  153          #define Y1 led2
  154          #define Y2 led3
  155          #define Y3 led4
  156          
  157          char yout_set(char weizhi, char zhi)
  158          {
  159   1        if (weizhi == 0)
  160   1          Y0 = zhi;
  161   1        if (weizhi == 1)
  162   1          Y1 = zhi;
  163   1        if (weizhi == 2)
  164   1          Y2 = zhi;
  165   1        if (weizhi == 3)
  166   1          Y3 = zhi;
  167   1      
  168   1        return (0);
  169   1      }
  170          void yout_closeall()
  171          {
  172   1        char i;
  173   1        for (i = 0; i < 4; i++)
  174   1        {
  175   2          yout_set(i, 1);
  176   2        }
  177   1      }
  178          void Delay10us() //@24.000MHz
  179          {
  180   1        unsigned long i;
  181   1      
  182   1        _nop_();
  183   1        _nop_();
  184   1        _nop_();
  185   1        i = 58UL;
  186   1        while (i)
  187   1          i--;
  188   1      }
C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 4   

  189          void delay10x(int i)
  190          {
  191   1        while (i-- > 0)
  192   1        {
  193   2          Delay10us();
  194   2        }
  195   1      }
  196          void showpre(int num)
  197          {
  198   1        int i;
  199   1        int a[4];
  200   1        a[0] = num % 10000 / 1000;
  201   1        a[1] = num % 1000 / 100;
  202   1      
  203   1        a[2] = num % 100 / 10;
  204   1        a[3] = num % 10;
  205   1      
  206   1        for (i = 0; i < 4; i++)
  207   1        {
  208   2          yout_closeall();
  209   2          yout_set(i, 0);
*** WARNING C188 IN LINE 209 OF main.c: 'parameter 1': value truncated
  210   2          P0 = ~duanzhi[a[i]];
  211   2          Delay10us();
  212   2          yout_closeall();
  213   2          P0 = 0xff;
  214   2          Delay10us();
  215   2        }
  216   1      }
  217          
  218          void testmain()
  219          {
  220   1        int a, b;
  221   1        int times = 0;
  222   1      }
*** WARNING C47 IN LINE 220 OF main.c: 'a': unreferenced local variable
*** WARNING C47 IN LINE 220 OF main.c: 'b': unreferenced local variable
  223          
  224          
  225          
  226          int g_dianliu = 600;
  227          
  228          
  229          
  230          
  231          
  232          
  233          
  234          char* mystrstr(const char* haystack, const char* needle) {
  235   1          if (*needle == '\0') {
  236   2              return (char*)haystack;
  237   2          }
  238   1      
  239   1          while (*haystack != '\0') {
  240   2              const char* h = haystack;
  241   2              const char* n = needle;
  242   2      
  243   2              while (*n != '\0' && *h == *n) {
  244   3                  h++;
  245   3                  n++;
  246   3              }
  247   2      
  248   2              if (*n == '\0') {
  249   3                  return (char*)haystack; // 子串匹配成功，返回起始位置
  250   3              }
  251   2      
C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 5   

  252   2              haystack++;
  253   2          }
  254   1      
  255   1          return NULL; // 未找到子串，返回NULL
  256   1      }
  257          size_t mystrlen(const char* str) {
  258   1          size_t length = 0;
  259   1          while (str[length] != '\0') {
  260   2              length++;
  261   2          }
  262   1          return length;
  263   1      }
  264          
  265          char* myaddstrstr(const char* haystack, const char* needle)
  266          { 
  267   1        char* result = mystrstr(haystack, needle);
  268   1         if (result != NULL)
  269   1         {
  270   2          result=result+mystrlen(needle);
  271   2         }
  272   1         return result;
  273   1      }
  274          
  275          #define MAX_REGISTERS 10 // 设置最大寄存器数量
  276          
  277          struct Register
  278          {
  279            unsigned int num;
  280            unsigned int value;
  281          };
  282          struct Register registers[MAX_REGISTERS];
  283          int numRegisters = 0;
  284          void showgetzhi()
  285          {
  286   1        unsigned char i;
  287   1        if (i == 0)
  288   1        {
  289   2          printf1("Register not get");
  290   2        }
  291   1        // 遍历并打印所有寄存器的值
  292   1        for (i = 0; i < numRegisters; i++)
  293   1        {
  294   2          printf1("Register %d: %d\n", registers[i].num, registers[i].value);
  295   2        }
  296   1      }
  297          
  298          #define MAXgetzhi 100
  299          int getzhi[MAXgetzhi]={0};
  300          void jixi3(char* input)
  301          {
  302   1        char *p=input;
  303   1        char *p1;
  304   1        int i;
  305   1        numRegisters=0;
  306   1        //1234-2234;333-4;end
  307   1        for( i=0;i<100;i++)
  308   1        {
  309   2          p1=myaddstrstr(p,";"); //找有没有下一个的
  310   2          if(p1==NULL)
  311   2          {
  312   3            break;
  313   3          }
  314   2          registers[numRegisters].num = atoi(p);
  315   2          p=myaddstrstr(p,"-");
  316   2          registers[numRegisters].value = atoi(p);
  317   2          numRegisters++;
C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 6   

  318   2          p=myaddstrstr(p,";");  //指向下一个后面
  319   2        }
  320   1        showgetzhi();
  321   1      }
  322          
  323          int flaginit=0;
  324          void setzhione(int dizhi,int zhi)
  325          {
  326   1        if(flaginit==0)
  327   1        {
  328   2          return ;
  329   2        }
  330   1        push(dizhi,zhi);
  331   1      }
  332          
  333          
  334          
  335          
  336          int setprezhi;
  337          
  338          int dianliusettime=0;
  339          char flagdianliuset=0;
  340          void setdianliusettime(int zhi)
  341          {
  342   1        if(dianliusettime!=0)
  343   1        {
  344   2          return ;
  345   2        }
  346   1        dianliusettime=zhi;
  347   1      }
  348          void changedainliuzhi()
  349          {
  350   1        if(setprezhi!=g_dianliu)
  351   1        {
  352   2          setprezhi=g_dianliu;
  353   2          setdianliusettime(250);
  354   2        }
  355   1      }
  356          
  357          
  358          
  359          char xin[30] = {0};
  360          sbit X0=P1^3;
  361          sbit X1=P1^1;
  362          void shurulvbo(void)
  363          {
  364   1        static u8 keybuf[40] = {
  365   1          0xFF,
  366   1          0xFF,
  367   1          0xFF,
  368   1          0xFF,
  369   1          0xFF,
  370   1          0xFF,
  371   1          0xFF,
  372   1          0xFF,
  373   1          0xFF,
  374   1          0xFF,
  375   1          0xFF,
  376   1          0xFF,
  377   1          0xFF,
  378   1          0xFF,
  379   1          0xFF,
  380   1          0xFF,
  381   1          0xFF,
  382   1          0xFF,
  383   1          0xFF,
C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 7   

  384   1          0xFF,
  385   1          0xFF,
  386   1          0xFF,
  387   1          0xFF,
  388   1          0xFF,
  389   1          0xFF,
  390   1          0xFF,
  391   1          0xFF,
  392   1          0xFF,
  393   1          0xFF,
  394   1          0xFF,
  395   1          0xFF,
  396   1          0xFF,
  397   1          0xFF,
  398   1          0xFF,
  399   1          0xFF,
  400   1          0xFF,
  401   1          0xFF,
  402   1          0xFF,
  403   1          0xFF,
  404   1          0xFF,
  405   1        }; // 矩阵按键扫描缓冲区 8ms
  406   1        unsigned char i;
  407   1        i = X0;
  408   1        keybuf[0] = (keybuf[0] << 1) | i;
  409   1        i = X1;
  410   1        keybuf[1] = (keybuf[1] << 1) | i;
  411   1        // i = X2;
  412   1        // keybuf[2] = (keybuf[2] << 1) | i;
  413   1        // i = X3;
  414   1        // keybuf[3] = (keybuf[3] << 1) | i;
  415   1        for (i = 0; i < 2; i++) // 3按键，所以循环3次
  416   1        {
  417   2          if ((keybuf[i] & 0xFF) == 0x00)
  418   2          {
  419   3            xin[i] = 0;
  420   3          }
  421   2          else if ((keybuf[i] & 0xFF) == 0xFF)
  422   2          { // 连续3次扫描值为1，即1*8ms内都是弹起状态时，可认为按键已稳定的弹起
  423   3            xin[i] = 1;
  424   3          }
  425   2        }
  426   1      }
  427          char flagsetliangdu=0;
  428          void writebuf();
  429          void keydown(int i) // 按键按下的处理、、、
  430          {
  431   1        printf1("keydown %d",i);
  432   1        if(i==0)
  433   1          setzhione(4,g_dianliu);
  434   1        if(i==1)
  435   1        {
  436   2          // if(flagsetliangdu==0)//不能设置值。。变成设置
  437   2          // {
  438   2      
  439   2          // }
  440   2          if(flagsetliangdu==1)//保存记录的值
  441   2          {
  442   3            printf1("flagsetliangdusetzhi %d",g_dianliu);
  443   3            writebuf();   
  444   3          }
  445   2          flagsetliangdu=1-flagsetliangdu;
  446   2        }
  447   1          
  448   1      
  449   1      }
C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 8   

  450          void keyup(int i) // 按键按下的处理、、、
  451          {
  452   1        printf1("keyup %d",i);
  453   1        if(i==0)
  454   1          setzhione(4,0);
  455   1      }
  456          void keyallchuli()
  457          {
  458   1        int i;
  459   1        static char flag[10] = {0};   // 标志记录
  460   1        static int dowmtimes[10] = {0}; // 标志记录
  461   1        for (i = 0; i < 6; i++)
  462   1        {
  463   2          if (xin[i] == 0)
  464   2          {
  465   3            if (flag[i] == 0) // 代表按键第一次按下。。。
  466   3            {
  467   4              flag[i] = 1;
  468   4              keydown(i);
  469   4            }
  470   3          }
  471   2          if (xin[i] == 1)
  472   2          {
  473   3            if (flag[i] == 1) // 代表下去了又上来
  474   3            {
  475   4              keyup(i);
  476   4            }
  477   3            flag[i] = 0;
  478   3            
  479   3          }
  480   2        }
  481   1      }
  482          
  483          int FLASH_SAVE_ADDR=0x000040; 
  484          void STMFLASH_Write(u8 WriteAddr,u16 *pBuffer,u16 NumToWrite) 
  485          {
  486   1        EEPROM_SectorErase(WriteAddr);
  487   1        EEPROM_write_n(WriteAddr,(u8 *)pBuffer,NumToWrite*2);
  488   1      }
  489          void EPPROMwrite()
  490          {
  491   1        g_reg[0]=0x55;
  492   1        STMFLASH_Write(FLASH_SAVE_ADDR,g_reg,30);
*** WARNING C188 IN LINE 492 OF main.c: 'parameter 1': value truncated
  493   1      }
  494          void STMFLASH_Read(u32 ReadAddr,u16 *pBuffer,u16 NumToRead) 
  495          {
  496   1        EEPROM_read_n(ReadAddr,(u8 *)pBuffer,NumToRead*2);
  497   1      }
  498          
  499          void dealorder();
  500          void getdianliupre()
  501          {
  502   1      
  503   1      }
  504          int timereport=0;
  505          
  506          int errpromdizhi=0x000040;
  507          void writebuf()
  508          {
  509   1        u8 get[10];
  510   1        get[0]=55;
  511   1        get[1]=g_dianliu/100;
  512   1        get[2]=g_dianliu%100;
  513   1        EEPROM_SectorErase(errpromdizhi);
  514   1        EEPROM_write_n(errpromdizhi,get,3);
C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 9   

  515   1      }
  516          void showzhi()
  517          {
  518   1        int i;
  519   1        int len2=sizeof(g_reg[0]);
  520   1        int len=sizeof(g_reg);
  521   1        len=len/len2;
  522   1        for(i=0;i<len;i++)
  523   1        {
  524   2          if(g_reg[i]!=0)
  525   2          {
  526   3            printf("[%d-%d]",i,g_reg[i]);
  527   3          }
  528   2        }
  529   1      }
  530          void EPPROMinit()
  531          {        
  532   1        STMFLASH_Read(FLASH_SAVE_ADDR,g_reg,30);
  533   1        if(g_reg[0]!=0x55)
  534   1        {
  535   2          printf("this is First record");
  536   2          memset(g_reg,0,sizeof(g_reg));
  537   2          g_reg[indexTImeAll]=25000;
  538   2          EPPROMwrite();
  539   2        }
  540   1        else
  541   1        {
  542   2          printf("not First record");
  543   2        }
  544   1        showzhi();
  545   1      }
  546          
  547          sbit keyled1=P3^6;
  548          sbit keyled2=P3^5;
  549          #define ledon 0
  550          #define ledclose 1
  551          void showled()
  552          {
  553   1        keyled1=ledclose;
  554   1        keyled2=ledclose;
  555   1        keyled2=ledon;
  556   1      }
  557          void delay_ms(unsigned int ms)
  558          {
  559   1        unsigned int i;
  560   1        do{
  561   2          i = MAIN_Fosc / 6030;
  562   2          while(--i);
  563   2        }while(--ms);
  564   1      }
  565          
  566          void fuwei()
  567          {
  568   1        IAP_CONTR=0x60;
  569   1      }
  570          
  571          int com2jixi2(char* input)
  572          {
  573   1        char flagTrue=0;
  574   1        char *p=input;
  575   1        char *p1;
  576   1        int i;
  577   1        int weizhi;
  578   1        int zhi;
  579   1        int bakweizhi;
  580   1        int bakzhi;
C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 10  

  581   1        for( i=0;i<100;i++)
  582   1        {
  583   2          p1=myaddstrstr(p,";"); //找有没有下一个的
  584   2          if(p1==NULL)
  585   2          {
  586   3            break;
  587   3          }
  588   2          weizhi = atoi(p);
  589   2          p=myaddstrstr(p,"-");
  590   2          zhi = atoi(p);
  591   2              if(i%2==0)
  592   2              {
  593   3                  bakweizhi=weizhi;
  594   3                  bakzhi=zhi;
  595   3              }
  596   2              if(i%2==1)
  597   2              {
  598   3                  if(weizhi==bakweizhi && bakzhi==zhi)
  599   3                  {
  600   4                      VectorPush(VectorDiannao,weizhi,zhi);
  601   4              flagTrue=1;
  602   4                  }
  603   3                  else
  604   3                  {
  605   4              flagTrue=0;
  606   4                      printf("get failed");
  607   4                  }
  608   3              }
  609   2          p=myaddstrstr(p,";");  //指向下一个后面
  610   2        }
  611   1        return flagTrue;
  612   1      }
  613          
  614          int  com2jiexi(char* input)
  615          {
  616   1        char par[1000]={0};
  617   1        char *begin,*end;
  618   1        begin=myaddstrstr(input,"set:");
  619   1        end=myaddstrstr(begin,"end");
  620   1        if(begin!=NULL && end!=NULL)
  621   1        {
  622   2          strcpy(par,begin);
  623   2          return com2jixi2(par);
  624   2        }
  625   1        return 0;
  626   1      }
  627          
  628          
  629          int flag_canset=0;
  630          int precom2check(char *input)
  631          {
  632   1        char *p;
  633   1        p=mystrstr(input,"ruibaokesettingmimaflag"); //找有没有下一个的)
  634   1        if(p!=NULL)
  635   1        {
  636   2          printtoDianao("passwd checkpass,you can set now\n");
  637   2          printtoDianao("\n");
  638   2          printtoDianao("初始电流值 20\n");
  639   2          printtoDianao("已使用寿命 21\n");
  640   2          printtoDianao("总寿命 22\n");
  641   2          printtoDianao("最大电流值 23\n");
  642   2          printtoDianao("使用方式 set:20-601;20-601;end\n");
  643   2          flag_canset=1;
  644   2          return 1;
  645   2        }
  646   1        p=mystrstr(input,"fuwei()"); //找有没有下一个的)
C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 11  

  647   1        if(p!=NULL)
  648   1        {
  649   2          fuwei();
  650   2        }
  651   1        return 0;
  652   1      }
  653          
  654          
  655          int shoumingjisuan(int predianliu)
  656          {
  657   1        int bili;
  658   1        if(g_reg[indexTImeAll]==0)
  659   1        return predianliu;
  660   1        bili=g_reg[indexTImeuse]*100/g_reg[indexTImeAll];
  661   1        if(bili>100)
  662   1        {
  663   2          return 0;
  664   2        }
  665   1        if(bili>90)
  666   1        {
  667   2          return predianliu*0.3;
  668   2        }
  669   1        if(bili>80)
  670   1        {
  671   2          return predianliu*0.5;
  672   2        }
  673   1        if(bili>70)
  674   1        {
  675   2          return predianliu*0.8;
  676   2        }
  677   1        return predianliu;
  678   1      }
  679          // 电流输出计算
  680          int jisuandianliu(int predianliu)
  681          {
  682   1        if(predianliu==0)
  683   1        {
  684   2          return 0;
  685   2        }
  686   1        predianliu=predianliu+g_reg[indexAdddianliu];
  687   1        if(predianliu>2047)
  688   1        {
  689   2          predianliu=2047;
  690   2        }
  691   1        return shoumingjisuan(predianliu);
  692   1      }
  693          void dianliusendtokongzhiban(int zhi)
  694          {
  695   1        char out[30]={0};
  696   1        int weizhi=4;
  697   1        g_dianliu=zhi;
  698   1        zhi=zhi*bili;
  699   1        zhi=jisuandianliu(zhi);
  700   1        sprintf(out,"set:%d-%d;%d-%d;end",weizhi,zhi,weizhi,zhi);
  701   1        printfTopingmu(out);
  702   1        printf("%s",out);
  703   1      }
  704          
  705          
  706          
  707          int isCanSetWeizhi(int weizhi)
  708          {
  709   1        if(weizhi>=indexAdddianliu && weizhi<=indexMAXdianliu)
  710   1        {
  711   2          return 1;
  712   2        }
C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 12  

  713   1        return 0;
  714   1      }
  715          void getlogstr(int weizhi,char* input)
  716          {
  717   1        if(weizhi==indexAdddianliu)
  718   1        {
  719   2          strcpy(input,"初始电流");
  720   2        }
  721   1        if(weizhi==indexAdddianliu+1)
  722   1        {
  723   2          strcpy(input,"已用寿命");
  724   2        }
  725   1        if(weizhi==indexAdddianliu+2)
  726   1        {
  727   2          strcpy(input,"总的寿命");
  728   2        }
  729   1        if(weizhi==indexAdddianliu+3)
  730   1        {
  731   2          strcpy(input,"最大寿命");
  732   2        }
  733   1      }
  734          
  735          // push 指令相关的计算。。
  736          int selfdeal(int weizhi,int zhi)
  737          {
  738   1        char rspstr[100]={0};
  739   1        char rsp2[100]={0};
  740   1        if(flag_canset==0)
  741   1        {
  742   2          return 0;
  743   2        }
  744   1        if(0==isCanSetWeizhi(weizhi))
  745   1        {
  746   2          return 0;
  747   2        }
  748   1        g_reg[weizhi]=zhi;
  749   1        getlogstr(weizhi,rspstr);
  750   1        EPPROMwrite();
  751   1        sprintf(rsp2,"%s设定:%d-%d 成功;",rspstr,weizhi,zhi);
  752   1        printtoDianao(rsp2);
  753   1        return 1;
  754   1      }
  755          int selfdealread(int weizhi,int zhi)
  756          {
  757   1        char rspstr[100]={0};
  758   1        char rsp2[100]={0};
  759   1        if(weizhi<1000)
  760   1        return 0;
  761   1        if(flag_canset==0)
  762   1        {
  763   2          return 0;
  764   2        }
  765   1        weizhi=weizhi-1000;
  766   1        if(0==isCanSetWeizhi(weizhi))
  767   1        {
  768   2          return 0;
  769   2        }
  770   1        getlogstr(weizhi,rspstr);
  771   1        sprintf(rsp2,"%s读取:%d-%d 成功;",rspstr,weizhi,g_reg[weizhi]);
  772   1        printtoDianao(rsp2);
  773   1        return 1;
  774   1      }
*** WARNING C47 IN LINE 755 OF main.c: 'zhi': unreferenced parameter
  775          // 电脑过来的指令，，，处理。。。
  776          // 一样是压进队列。。然后处理就可以了。。。就是这种了。。。
  777          void dealDiannaoOrder()
C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 13  

  778          {
  779   1          int weizhi,zhi;
  780   1          VectorInfo get={0};
  781   1          VectorGet(VectorDiannao,&get);
  782   1          if(get.weizhi==0)
  783   1          {
  784   2              return ;
  785   2          }
  786   1          weizhi=get.weizhi;
  787   1          zhi=get.zhi;
  788   1        if(weizhi==4)//电流设置，等待设置完成后再处理。。。其他设置不用管。。
  789   1        {
  790   2          delay_ms(10);
  791   2          dianliusendtokongzhiban(zhi);
  792   2          delay_ms(10);
  793   2        }
  794   1        else
  795   1        {
  796   2          selfdeal(weizhi,zhi);
  797   2          selfdealread(weizhi,zhi);
  798   2        }
  799   1      }
  800          void diannaoinputset()
  801          {
  802   1        int i;
  803   1        if(1==precom2check(rec2))
  804   1        {
  805   2          return ;
  806   2        }
  807   1        com2jiexi(rec2);
  808   1        if(VectorIsEmpty(VectorDiannao))
  809   1        {
  810   2          printtoDianao("oder format error,pleas check\n");
  811   2          return ;
  812   2        }
  813   1        for(i=0;i<10;i++)
  814   1        {
  815   2          dealDiannaoOrder(); //com过来的电脑命令解析。。。
  816   2        }
  817   1        // ShowInfoToDiannan(1);
  818   1      }
  819          void diannaocheck()
  820          {
  821   1        if(weizhi2==0)
  822   1        {
  823   2          return ;
  824   2        }
  825   1        delay_ms(2);
  826   1        diannaoinputset();
  827   1        memset(rec2, 0, sizeof(rec2));
  828   1        weizhi2 = 0;
  829   1      }
  830          void main(void)
  831          {
  832   1        SYS_Ini();    // STC32初始化设置
  833   1        PWM_Config(); // PWM初始化设置
  834   1        EA = 1;     // 使能EA总中断
  835   1      
  836   1        UartInit();
  837   1        Uart23Init();
  838   1        printf1("system is ok");
  839   1        Timer0Init();
  840   1        printf1("system is overall");
  841   1        keyallchuli();
  842   1        flaginit=1;
  843   1        EPPROMinit();
C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 14  

  844   1        setzhione(4,0);
  845   1        
  846   1        // test3();
  847   1        // 没有什么时序时序要求，，指点函数里面做算了。。
  848   1        // 算了，之前都写成这样了。。不改了。。原有逻辑上面改改就行吧，，
  849   1        while (1)
  850   1        {
  851   2          showled();
  852   2          keyallchuli();
  853   2          showpre(g_dianliu);
  854   2          dealorder();//取缓冲区里面的命令进行发送
  855   2          diannaocheck();
  856   2          
  857   2        }
  858   1      }
  859          
  860          void PWM_ISR() interrupt 26
  861          {
  862   1        if (PWMA_SR1 & 0X02) // 当捕获中断标志置1
  863   1        {
  864   2          cnt_H = PWMA_CCR1H; // 读取计数值高8位
  865   2          cnt_L = PWMA_CCR1L; // 读取计数值低8位
  866   2          PWMA_SR1 &= ~0X02;  // 清零捕获中断标志
  867   2          EC11_Handle();    // 处理EC11数据
  868   2        }
  869   1      }
  870          void PWM_Config() // PWM初始化设置
  871          {
  872   1        PWMA_CCER1 = 0x00; // 关闭通道
  873   1        PWMA_CCMR1 = 0xA1; // 通道模式配置为输入，接编码器 , 滤波器 80 时钟
  874   1        PWMA_CCMR2 = 0xA1; // 通道模式配置为输入，接编码器 , 滤波器 80 时钟
  875   1        PWMA_CCER1 = 0x55; // 使能捕获/比较通道1、通道2
  876   1      
  877   1        //  PWMA_SMCR = 0x01;         // 编码器模式 1
  878   1        //  PWMA_SMCR = 0x02;         // 编码器模式 2
  879   1        PWMA_SMCR = 0x03; // 编码器模式 3
  880   1      
  881   1        PWMA_IER = 0x02;  // 使能中断
  882   1        PWMA_CR1 |= 0x01; // 使能计数器
  883   1        PWMA_PS |= 0x04;  // 选择 PWM2_2 通道
  884   1      }
  885          
  886          // 返回变化的步数
  887          long calculateChange(unsigned int previous, unsigned int current)
  888          {
  889   1        long diff = (current - previous + 65536) % 65536;
*** WARNING C188 IN LINE 889 OF main.c: 'initialization': value truncated
  890   1        return diff;
  891   1      }
  892          
  893          
  894          char flag3 = 0;
  895          int timeleft1, timeleft2, timeleft3, timeleft4;
  896          void chuankou1put(char c)
  897          {
  898   1        rec2[weizhi2++] = c;
  899   1        if (weizhi2 > sizeof(rec2) - 3)
  900   1          weizhi2 = 0;
  901   1        // timeleft3 = 3;
  902   1      }
  903          void chuankou1time()
  904          {
  905   1        if (timeleft3 > 0)
  906   1        {
  907   2          timeleft3--;
  908   2          if (timeleft3 == 0) // 数据一次收完了.
C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 15  

  909   2          {
  910   3            flag3 = 1;
  911   3          }
  912   2        }
  913   1      }
  914          char get1[100];
  915          int weizhi1=0;
  916          void chuliguankji(char *get1)
  917          {
  918   1          char* index;
  919   1          index=mystrstr(get1,"@STCISP#");
  920   1        if(index==0)
  921   1        {
  922   2            return  ;
  923   2        }
  924   1          IAP_CONTR=0x60;
  925   1      }
  926          
  927          void addgetsetzhi(int i)
  928          {
  929   1        int ans;
  930   1        ans=g_dianliu+i;
  931   1        if(ans>=0 && ans<=1023)
  932   1        {
  933   2          g_dianliu=ans;
  934   2        }
  935   1      }
  936          static int timepush=0;
  937          void dealorder()
  938          {
  939   1        Alltongxininfo get;
  940   1        if(timepush>45)
  941   1        {
  942   2          timepush=0;
  943   2          pop2(&get);
  944   2          if(get.weizhi==4)
  945   2          {
  946   3            dianliusendtokongzhiban(get.zhi);
  947   3          }
  948   2        }
  949   1      }
  950          void Timer0() interrupt 1
  951          {
  952   1        timereport++;
  953   1        shurulvbo();
  954   1        chuankou1time();
  955   1        if(!empty())
*** WARNING C140 IN LINE 955 OF main.c: 'empty' undefined; assuming 'extern int empty()'
  956   1        {
  957   2          timepush++;
  958   2        }
  959   1      }
  960          void EC11_Handle() // EC11数据处理函数
  961          {
  962   1        static unsigned int previous = 0;
  963   1        unsigned int nowzhi;
  964   1        long ans;
  965   1        nowzhi = cnt_H * 256 + cnt_L; // 读取当前计数值
  966   1        ans = calculateChange(previous, nowzhi);
  967   1        previous = nowzhi;
  968   1        if(flagsetliangdu==1)
  969   1        {
  970   2          if (ans == 4)
  971   2          {
  972   3            addgetsetzhi(1);
  973   3          }
C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 16  

  974   2          else
  975   2          {
  976   3            addgetsetzhi(-1);
  977   3          }
  978   2          // 设定电流值。。。
  979   2          setzhione(4,g_dianliu);
  980   2          // setzhione(2,1);//开灯。。
  981   2        }
  982   1        
  983   1      }
  984          
  985          int step=0;
  986          void showstep(const char *s)
  987          {
  988   1        printf1("%s\n",s);
  989   1      }
  990          char* my_strstr(const char* haystack, const char* needle) {
  991   1          if (*needle == '\0') {
  992   2              return (char*) haystack;
  993   2          }
  994   1      
  995   1          while (*haystack != '\0') {
  996   2              const char* h = haystack;
  997   2              const char* n = needle;
  998   2      
  999   2              while (*h == *n && *n != '\0') {
 1000   3                  h++;
 1001   3                  n++;
 1002   3              }
 1003   2      
 1004   2              if (*n == '\0') {
 1005   3                  return (char*) haystack;
 1006   3              }
 1007   2      
 1008   2              haystack++;
 1009   2          }
 1010   1      
 1011   1          return NULL;
 1012   1      }
 1013          
 1014          void dealchuankou()
 1015          {
 1016   1      
 1017   1      }
 1018          
 1019          void UARTInterrupt(void) interrupt 4
 1020          {
 1021   1        unsigned char ans;
 1022   1        if (RI)
 1023   1        {
 1024   2          RI = 0;
 1025   2          ans = SBUF;
 1026   2          get1[weizhi1++]=ans;
 1027   2          if(weizhi1>80)
 1028   2          {
 1029   3            weizhi1=0;
 1030   3          }
 1031   2          chuliguankji(get1);
 1032   2          chuankou1put(ans);
 1033   2        }
 1034   1        else
 1035   1        {
 1036   2          TI = 0;
 1037   2        }
 1038   1        if (TI) // 发送中断..
 1039   1        {
C251 COMPILER V5.60.0,  main                                                               06/08/23  15:41:02  PAGE 17  

 1040   2          TI = 0;
 1041   2        }
 1042   1      }
 1043          void Uart3() interrupt 17 using 1
 1044          {
 1045   1        char temp3; 
 1046   1          if (S3CON & S3RI)
 1047   1          {
 1048   2              S3CON &= ~S3RI; //??S3RI?
 1049   2          temp3 = S3BUF;
 1050   2          }
 1051   1          if (S3CON & S3TI)
 1052   1          {
 1053   2              S3CON &= ~S3TI; // 清除S3TI位
 1054   2              busy3 = 0;      // 清忙标志
 1055   2          }
 1056   1      }
 1057          
 1058          // 写个函数，传入两个非负数，计算是前进还是后退了，变化规律 15,16,0,1,2...15,16


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      4150     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =      1067       2285
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      2838     ------
End of Module Information.


C251 COMPILATION COMPLETE.  8 WARNING(S),  0 ERROR(S)
