C251 COMPILER V5.60.0,  main                                                               15/09/23  14:25:37  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\list\main.obj
COMPILER INVOKED BY: D:\keilc251\C251\BIN\C251.EXE ..\User\main.c LARGE INTR2 ROM(HUGE) BROWSE INCDIR(..\Driver\inc;..\U
                    -ser;..\App\inc) DEBUG PRINT(.\list\main.lst) TABS(2) OBJECT(.\list\main.obj) 

stmt  level    source

    1          /*---------------------------------------------------------------------*/
    2          /* --- STC MCU Limited ------------------------------------------------*/
    3          /* --- STC 1T Series MCU Demo Programme -------------------------------*/
    4          /* --- Mobile: (86)13922805190 ----------------------------------------*/
    5          /* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
    6          /* --- Tel: 86-0513-55012928,55012929,55012966 ------------------------*/
    7          /* --- Web: www.STCMCU.com --------------------------------------------*/
    8          /* --- Web: www.STCMCUDATA.com  ---------------------------------------*/
    9          /* --- QQ:  800003751 -------------------------------------------------*/
   10          /* 如果要在程序中使用此代码,请在程序中注明使用了STC的资料及程序            */
   11          /*---------------------------------------------------------------------*/
   12          #include <string.h>
   13          #include "stc32g.h"
   14          #include "config.h"
*** WARNING C317 IN LINE 39 OF ..\User\type_def.h: attempt to redefine macro 'NULL'
   15          
   16          
   17          #include <stdio.h>
   18          #include <stdarg.h>
   19          #include <stdio.h>
   20          
   21          #include <stdlib.h>
   22          #include  "Task.h"
   23          #include  "System_init.h"
   24          #include  "APP.h"
*** WARNING C317 IN LINE 89 OF \瑞宝科\new2\lcd显示屏_24\App\inc\APP_Lamp.h: attempt to redefine macro 'WHITE'
*** WARNING C317 IN LINE 91 OF \瑞宝科\new2\lcd显示屏_24\App\inc\APP_Lamp.h: attempt to redefine macro 'BLUE'
*** WARNING C317 IN LINE 95 OF \瑞宝科\new2\lcd显示屏_24\App\inc\APP_Lamp.h: attempt to redefine macro 'RED'
*** WARNING C317 IN LINE 97 OF \瑞宝科\new2\lcd显示屏_24\App\inc\APP_Lamp.h: attempt to redefine macro 'GREEN'
   25          
   26          #include  "config.h"
   27          #include  "STC32G_GPIO.h"
   28          #include  "STC32G_UART.h"
   29          #include  "STC32G_NVIC.h"
   30          #include  "STC32G_Delay.h"
   31          #include  "STC32G_Switch.h"
   32          #include "uart.h"
*** WARNING C317 IN LINE 17 OF ..\User\uart.h: attempt to redefine macro 'CLR_TI4'
*** WARNING C317 IN LINE 18 OF ..\User\uart.h: attempt to redefine macro 'CLR_RI4'
*** WARNING C317 IN LINE 24 OF ..\User\uart.h: attempt to redefine macro 'MAIN_Fosc'
   33          #include "tongxin2.h"
   34          #include "tongxin.h"
   35          #include "STC32G_EEPROM.h"
   36          
   37          void showhenxiang();
   38          void ledopen(int weizhi);
   39          
   40          int keyon = 0;
   41          int keylow = 1;
   42          int keyok = 2;
   43          int keyup = 3;
   44          
   45          int nowzhi = 0;
   46          int g_dianliu = 0;
   47          sbit X0 = P4 ^ 0;
   48          sbit X3 = P3 ^ 4;
   49          sbit X2 = P3 ^ 6;
   50          sbit X1 = P4 ^ 1;
C251 COMPILER V5.60.0,  main                                                               15/09/23  14:25:37  PAGE 2   

   51          
   52          sbit LED1 = P4 ^ 2;
   53          sbit LED2 = P3 ^ 7;
   54          
   55          sbit LED3 = P3 ^ 5;
   56          sbit LED0 = P3 ^ 3;
   57          
   58          
   59          sbit Y1 =  P4 ^ 2;
   60          sbit Y2 =  P3 ^ 7;
   61          
   62          sbit Y3 =  P3 ^ 5;
   63          sbit Y0 =  P3 ^ 3;
   64          
   65          
   66          
   67          char flagsystemrun = 0;
   68          #define maxsetzhi 2047
   69          
   70          
   71          void  GPIO_confibase(void)
   72          {
   73   1      //  P2_MODE_IO_PU( GPIO_Pin_3 | GPIO_Pin_4 );   //P2 设置为准双向口
   74   1      //  P2_MODE_OUT_PP(GPIO_Pin_2|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7);
   75   1          P2_MODE_IO_PU(GPIO_Pin_All);  
   76   1        
   77   1        P3_MODE_OUT_PP(GPIO_Pin_3|GPIO_Pin_5|GPIO_Pin_7);
   78   1        P3_MODE_IN_HIZ(GPIO_Pin_4|GPIO_Pin_6);
   79   1        
   80   1        P4_MODE_OUT_PP(GPIO_Pin_2|GPIO_Pin_3);
   81   1        P4_MODE_IN_HIZ(GPIO_Pin_0|GPIO_Pin_1);
   82   1      }
   83          
   84          void  GPIO_configcom3(void)
   85          {
   86   1        GPIO_InitTypeDef  GPIO_InitStructure;   //结构定义
   87   1      
   88   1        GPIO_InitStructure.Pin  = GPIO_Pin_0 | GPIO_Pin_1;    //指定要初始化的IO, GPIO_Pin_0 ~ GPIO_Pin_7
   89   1        GPIO_InitStructure.Mode = GPIO_PullUp;  //指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_
             -OUT_PP
   90   1        GPIO_Inilize(GPIO_P5,&GPIO_InitStructure);  //初始化
   91   1      }
   92          
   93          /***************  串口初始化函数 *****************/
   94          void  UART_configcom3(void)
   95          {
   96   1        COMx_InitDefine   COMx_InitStructure;         //结构定义
   97   1      
   98   1        COMx_InitStructure.UART_Mode      = UART_8bit_BRTx; //模式, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UAR
             -T_9bit_BRTx
   99   1        COMx_InitStructure.UART_BRT_Use   = BRT_Timer3;     //选择波特率发生器, BRT_Timer3, BRT_Timer2 (注意: 串口
             -2固定使用BRT_Timer2)
  100   1        COMx_InitStructure.UART_BaudRate  = 115200ul;     //波特率, 一般 110 ~ 115200
  101   1        COMx_InitStructure.UART_RxEnable  = ENABLE;       //接收允许,   ENABLE或DISABLE
  102   1        UART_Configuration(UART3, &COMx_InitStructure);   //初始化串口1 UART1,UART2,UART3,UART4
  103   1        NVIC_UART3_Init(ENABLE,Priority_1);   //中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Pr
             -iority_2,Priority_3
  104   1      
  105   1        UART3_SW(UART3_SW_P50_P51);   //UART3_SW_P00_P01,UART3_SW_P50_P51
  106   1      }
  107          
  108          
  109          static int timepush=0;
  110          void dealorder()
  111          {
  112   1        char out[30]={0};
C251 COMPILER V5.60.0,  main                                                               15/09/23  14:25:37  PAGE 3   

  113   1        Alltongxininfo get;
  114   1        if(timepush>45)
  115   1        {
  116   2          timepush=0;
  117   2          pop2(&get);
  118   2          if(get.weizhi==4)
  119   2          {
  120   3            get.zhi=get.zhi;
*** WARNING C138 IN LINE 120 OF ..\User\main.c: expression with possibly no effect
  121   3          }
  122   2          sprintf(out,"set:%d-%d;end",get.weizhi,get.zhi);
  123   2          print3(out);
  124   2        }
  125   1      }
  126          char flagError=0;
  127          int timeflagError=0;
  128          int timetongxin=0;
  129          void time0() interrupt 1
  130          {
  131   1        if(flagsystemrun==1)
  132   1          timetongxin++;
  133   1        if(flagError==1)
  134   1        {
  135   2          if(timeflagError++>500)
  136   2          {
  137   3            timeflagError=0;
  138   3            LED0 = ~LED0;
  139   3          }
  140   2          
  141   2        }
  142   1            
  143   1        if(!empty())
*** WARNING C140 IN LINE 143 OF ..\User\main.c: 'empty' undefined; assuming 'extern int empty()'
  144   1        {
  145   2          timepush++;
  146   2        }
  147   1        chuankou1time();
  148   1      }
  149          
  150          void Uart3() interrupt 17
  151          {
  152   1        char temp3; 
  153   1          if (S3CON & S3RI)
  154   1          {
  155   2              S3CON &= ~S3RI; //??S3RI?
  156   2          temp3 = S3BUF;
  157   2          chuankou1put(temp3);
  158   2          }
  159   1          if (S3CON & S3TI)
  160   1          {
  161   2              S3CON &= ~S3TI; // 清除S3TI位
  162   2              busy3 = 0;      // 清忙标志
  163   2          }
  164   1      }
  165          
  166          char flag_show = 0;
  167          // 是否能够设置值的状态。。。  ok键按下 即可。。。
  168          char flagcanset = 0;
  169          void setdianliu(int zhi)
  170          {
  171   1        push(4,zhi);
  172   1      }
  173          
  174          
  175          
  176          void setzhichange(int a)
C251 COMPILER V5.60.0,  main                                                               15/09/23  14:25:37  PAGE 4   

  177          {
  178   1        if (flagcanset == 0)
  179   1          return;
  180   1        if (g_dianliu + a < 0)
  181   1        {
  182   2          g_dianliu = 0;
  183   2          // 0的情况也发，保证能够被收到。。
  184   2          flag_show = 1;
  185   2          setdianliu(g_dianliu);
  186   2          // printf("setdianliu%d\r\n",g_dianliu);
  187   2          return;
  188   2        }
  189   1        if (g_dianliu + a > maxsetzhi)
  190   1        {
  191   2          g_dianliu = maxsetzhi;
  192   2          return;
  193   2        }
  194   1        g_dianliu = g_dianliu + a;
  195   1        flag_show = 1;
  196   1        setdianliu(g_dianliu);
  197   1      }
  198          int writedizhi(int dizhi, int zhi)
  199          {
  200   1        push(dizhi,zhi);
  201   1      }
  202          void writebuf();
  203          void keydown(int i) // 按键按下的处理、、、
  204          {
  205   1        printf("key down%d",i);
  206   1        if (i == keyon)
  207   1        {
  208   2          LED0 = ~LED0;
  209   2          // 结束时候关灯， 开机键盘开灯。。。
  210   2          if (flagsystemrun == 0)
  211   2          {
  212   3            flagsystemrun = 1;
  213   3            LCD_ShowString(0, 0, "Circle TAC", WHITE, BLACK, 32, 0);
  214   3            showhenxiang();
  215   3            writedizhi(2,1);
  216   3            delay_ms(30);
  217   3            writedizhi(2,1);
  218   3            delay_ms(30);
  219   3            setdianliu(g_dianliu);
  220   3            delay_ms(10);
  221   3          }
  222   2          else
  223   2          {
  224   3            writedizhi(2,0);
  225   3            delay_ms(100);
  226   3            dealorder();
  227   3            writedizhi(2,0);
  228   3            delay_ms(300);
  229   3            dealorder();
  230   3            IAP_CONTR = 0x60;
  231   3          }
  232   2        }
  233   1        if (flagcanset)
  234   1        {
  235   2          ledopen(i);
  236   2        }
  237   1        if (i == keylow)
  238   1        {
  239   2          setzhichange(-1);
  240   2          return;
  241   2        }
  242   1        if (i == keyup)
C251 COMPILER V5.60.0,  main                                                               15/09/23  14:25:37  PAGE 5   

  243   1        {
  244   2          setzhichange(1);
  245   2          return;
  246   2        }
  247   1        if (i == keyok)
  248   1        {
  249   2          if(flagcanset==1)
  250   2          {
  251   3            writebuf();
  252   3          }
  253   2          flagcanset = 1 - flagcanset;
  254   2          LED2 = ~LED2;
  255   2        }
  256   1      }
  257          int keyshi = 3;
  258          // 按键连续按下多少次的操作。。
  259          int setbizhi(int times)
  260          {
  261   1        if (times < 15 * keyshi)
  262   1        {
  263   2          return 10;
  264   2        }
  265   1        if (times < 50 * keyshi)
  266   1        {
  267   2          return 50;
  268   2        }
  269   1        return 100;
  270   1      }
  271          // 2ms 一次的话，那300ms一次ok的吧。。
  272          void dolongtimes(int i, int times)
  273          {
  274   1        int xielv;
  275   1        times = times - 150;
  276   1        if (times < 0)
  277   1        {
  278   2          return;
  279   2        }
  280   1        xielv = setbizhi(times);
  281   1        if (times % keyshi != 0)
  282   1        {
  283   2          return;
  284   2        }
  285   1        if (i == keylow)
  286   1        {
  287   2          setzhichange(-xielv);
  288   2          return;
  289   2        }
  290   1        if (i == keyup)
  291   1        {
  292   2          setzhichange(xielv);
  293   2          return;
  294   2        }
  295   1      }
  296          void yout_set(char weizhi, char zhi)
  297          {
  298   1        if (weizhi == 0)
  299   1          Y0 = zhi;
  300   1        if (weizhi == 1)
  301   1          Y1 = zhi;
  302   1        if (weizhi == 2)
  303   1          Y2 = zhi;
  304   1        if (weizhi == 3)
  305   1          Y3 = zhi;
  306   1      }
  307          void ledclose(int weizhi)
  308          {
C251 COMPILER V5.60.0,  main                                                               15/09/23  14:25:37  PAGE 6   

  309   1        if (weizhi == keyon || weizhi == keyok)
  310   1        {
  311   2          return;
  312   2        }
  313   1        yout_set(weizhi, 1);
*** WARNING C188 IN LINE 313 OF ..\User\main.c: 'parameter 1': value truncated
  314   1      }
  315          void ledopen(int weizhi)
  316          {
  317   1        if (weizhi == keyon || weizhi == keyok)
  318   1        {
  319   2          return;
  320   2        }
  321   1        yout_set(weizhi, 0);
*** WARNING C188 IN LINE 321 OF ..\User\main.c: 'parameter 1': value truncated
  322   1      }
  323          
  324          
  325          
  326          
  327          
  328          char xin[30] = {0};
  329          void shurulvbo(void)
  330          {
  331   1        static u8 keybuf[40] = {
  332   1          0xFF,
  333   1          0xFF,
  334   1          0xFF,
  335   1          0xFF,
  336   1          0xFF,
  337   1          0xFF,
  338   1          0xFF,
  339   1          0xFF,
  340   1          0xFF,
  341   1          0xFF,
  342   1          0xFF,
  343   1          0xFF,
  344   1          0xFF,
  345   1          0xFF,
  346   1          0xFF,
  347   1          0xFF,
  348   1          0xFF,
  349   1          0xFF,
  350   1          0xFF,
  351   1          0xFF,
  352   1          0xFF,
  353   1          0xFF,
  354   1          0xFF,
  355   1          0xFF,
  356   1          0xFF,
  357   1          0xFF,
  358   1          0xFF,
  359   1          0xFF,
  360   1          0xFF,
  361   1          0xFF,
  362   1          0xFF,
  363   1          0xFF,
  364   1          0xFF,
  365   1          0xFF,
  366   1          0xFF,
  367   1          0xFF,
  368   1          0xFF,
  369   1          0xFF,
  370   1          0xFF,
  371   1          0xFF,
  372   1        }; // 矩阵按键扫描缓冲区 8ms
C251 COMPILER V5.60.0,  main                                                               15/09/23  14:25:37  PAGE 7   

  373   1        unsigned char i;
  374   1        i = X0;
  375   1        keybuf[0] = (keybuf[0] << 1) | i;
  376   1        i = X1;
  377   1        keybuf[1] = (keybuf[1] << 1) | i;
  378   1        i = X2;
  379   1        keybuf[2] = (keybuf[2] << 1) | i;
  380   1        i = X3;
  381   1        keybuf[3] = (keybuf[3] << 1) | i;
  382   1        for (i = 0; i < 10; i++) // 3按键，所以循环3次
  383   1        {
  384   2          if ((keybuf[i] & 0xFF) == 0x00)
  385   2          {
  386   3            xin[i] = 0;
  387   3          }
  388   2          else if ((keybuf[i] & 0xFF) == 0xFF)
  389   2          { // 连续3次扫描值为1，即1*8ms内都是弹起状态时，可认为按键已稳定的弹起
  390   3            xin[i] = 1;
  391   3          }
  392   2        }
  393   1      }
  394          void keyallchuli()
  395          {
  396   1        int i;
  397   1        static char flag[10] = {0};   // 标志记录
  398   1        static int dowmtimes[10] = {0}; // 标志记录
  399   1        for (i = 0; i < 6; i++)
  400   1        {
  401   2          if (xin[i] == 0)
  402   2          {
  403   3            if (flag[i] == 0) // 代表按键第一次按下。。。
  404   3            {
  405   4              flag[i] = 1;
  406   4              keydown(i);
  407   4            }
  408   3      
  409   3            dowmtimes[i]++;
  410   3            dolongtimes(i, dowmtimes[i]);
  411   3          }
  412   2          else
  413   2          {
  414   3            flag[i] = 0;
  415   3            dowmtimes[i] = 0;
  416   3            ledclose(i);
  417   3          }
  418   2        }
  419   1      }
  420          
  421          int tmp = 203; // 温度值
  422          void shownwendu()
  423          {
  424   1        char dataxx[40];
  425   1        // 记得复位
  426   1        if (flagsystemrun == 0)
  427   1        {
  428   2          return;
  429   2        }
  430   1        sprintf(dataxx, "TMP:%3d.%01d  ", tmp / 10, tmp % 10);
  431   1        LCD_ShowString(0, 80, dataxx, WHITE, BLACK, 32, 0);
  432   1      }
  433          
  434          void shownow()
  435          {
  436   1        // char dataxx[40];
  437   1        // sprintf(dataxx,"NOW:%05d",nowzhi);
  438   1        // LCD_ShowString(0,40,dataxx,WHITE,BLACK,32,0);
C251 COMPILER V5.60.0,  main                                                               15/09/23  14:25:37  PAGE 8   

  439   1      }
  440          
  441          #define maxjindu 16
  442          #define qidian 0
  443          
  444          void pingmuclear()
  445          {
  446   1        char dataxx[60] = {0};
  447   1        static int runflag2 = 0;
  448   1        int i;
  449   1        if (runflag2 == 1)
  450   1        {
  451   2          return;
  452   2        }
  453   1        runflag2 = 1;
  454   1        // LCD_Clear(BLACK);
  455   1      
  456   1        sprintf(dataxx, "                     ", 1);
  457   1        for (i = 0; i < 10; i++)
  458   1        {
  459   2          LCD_ShowString(0, i * 30, dataxx, WHITE, BLACK, 32, 0);
  460   2          // delay_ms(1);
  461   2        }
  462   1      }
  463          void showhenxiang()
  464          {
  465   1        int i;
  466   1        char dataxx[60] = {0};
  467   1        static int runflag = 0;
  468   1        if (runflag == 1)
  469   1        {
  470   2          return;
  471   2        }
  472   1        runflag = 1;
  473   1      
  474   1        for (i = 0; i < maxjindu; i++)
  475   1        {
  476   2          dataxx[i] = '-';
  477   2        }
  478   1      
  479   1        LCD_ShowString(qidian, 140, dataxx, WHITE, BLACK, 32, 0);
  480   1        LCD_ShowString(qidian, 140 + 40, dataxx, WHITE, BLACK, 32, 0);
  481   1        LCD_ShowString(qidian, 140 + 40 + 30, "0            12bit          2047", WHITE, BLACK, 16, 0);
  482   1      }
  483          
  484          void showjindtiao()
  485          {
  486   1        int i;
  487   1        char dataxx[60] = {0};
  488   1        int jindu;
  489   1        jindu = g_dianliu * maxjindu / maxsetzhi;
  490   1        for (i = 0; i < maxjindu; i++)
  491   1        {
  492   2          if (i < jindu)
  493   2            dataxx[i] = '>';
  494   2          else
  495   2            dataxx[i] = ' ';
  496   2        }
  497   1        showhenxiang();
  498   1        LCD_ShowString(qidian, 160, dataxx, WHITE, BLACK, 32, 0);
  499   1      }
  500          void showsetzhi()
  501          {
  502   1        char dataxx[40];
  503   1        sprintf(dataxx, "SET:        %04d    ", g_dianliu);
  504   1        LCD_ShowString(0, 120, dataxx, WHITE, BLACK, 32, 0);
C251 COMPILER V5.60.0,  main                                                               15/09/23  14:25:37  PAGE 9   

  505   1        showjindtiao();
  506   1      }
  507          void showdata()
  508          {
  509   1        // 记得复位
  510   1        if (flagsystemrun == 0)
  511   1        {
  512   2          return;
  513   2        }
  514   1        shownow();
  515   1        showsetzhi();
  516   1      }
  517          
  518          void showfen(int error)
  519          {
  520   1        // 记得复位
  521   1        if (flagsystemrun == 0)
  522   1        {
  523   2          return;
  524   2        }
  525   1        if(error==11)
  526   1          LCD_ShowString(0, 40,"ERROR FOR FAN", WHITE, BLACK, 32, 0);
  527   1        if(error==12)
  528   1          LCD_ShowString(0, 40,"ERROR FOR TMP", WHITE, BLACK, 32, 0);
  529   1        if(error==13)
  530   1          LCD_ShowString(0, 40,"ERROR FOR REC CENTER", WHITE, BLACK, 32, 0);
  531   1        if(error==14)
  532   1          LCD_ShowString(0, 40,"ERROR FOR REC LIGHT", WHITE, BLACK, 32, 0);
  533   1        if(error>=11 && error<=14)
  534   1        {
  535   2          flagError=1;
  536   2        }
  537   1      }
  538          
  539          void getzhiandchange()
  540          {
  541   1          int weizhi,zhi;
  542   1          Alltongxininfo2 get={0};
  543   1          pop22(&get);
  544   1          if(get.weizhi==0)
  545   1          {
  546   2              return ;
  547   2          }
  548   1          weizhi=get.weizhi;
  549   1          zhi=get.zhi;
  550   1          printf("getzhiandchange weizhi[%d] zhi[%d]\n",weizhi,zhi);
  551   1        timetongxin=0;
  552   1        if( weizhi== 6 )
  553   1        {
  554   2          tmp=zhi;
  555   2        }
  556   1        if( weizhi== 32 )//网络设置过来的电流。。
  557   1        {
  558   2          g_dianliu=zhi;
  559   2          flag_show=1;
  560   2          writebuf();
  561   2        }
  562   1        showfen(weizhi);
  563   1      }
  564          void readbuf();
  565          
  566          void mainrun()
  567          {
  568   1        int rumtimes = 0;
  569   1        LED0 = ~LED0;
  570   1        readbuf();
C251 COMPILER V5.60.0,  main                                                               15/09/23  14:25:37  PAGE 10  

  571   1        // writedizhi(2,0);
  572   1        writedizhi(4,0);
  573   1        while (1)
  574   1        {
  575   2          delay_ms2(1);
  576   2          shurulvbo();
  577   2          keyallchuli(); 
  578   2          dealorder();
  579   2          dealchuankou();//处理中控板过来的的数据
  580   2          getzhiandchange();//对数据进行处理。。。
  581   2          if (flag_show == 1)
  582   2          {
  583   3            flag_show = 0;
  584   3            showdata();
  585   3            rumtimes = 0;
  586   3          }
  587   2          if(flagsystemrun==1)
  588   2          {
  589   3            if(timetongxin>6000)
  590   3            {
  591   4              timetongxin=0;
  592   4              push2(13,1);
  593   4            }
  594   3          }
  595   2          
  596   2          rumtimes++;
  597   2          if (rumtimes == 15000)
  598   2            showdata();
  599   2          if (rumtimes == 20000)
  600   2          {
  601   3            shownwendu();
  602   3            rumtimes = 0;
  603   3          }
  604   2        }
  605   1      }
  606          void UART1_ISR_Handler (void) interrupt UART1_VECTOR
  607          {
  608   1        if(RI)
  609   1        {
  610   2          RI = 0;
  611   2          printf("rec init now");
  612   2          IAP_CONTR = 0x60;
  613   2        }
  614   1        if(TI)
  615   1        {
  616   2          TI = 0;
  617   2        }
  618   1      }
  619          //========================================================================
  620          // 函数: void main(void)
  621          // 描述: 主函数程序.
  622          // 参数: None.
  623          // 返回: None.
  624          // 版本: V1.0, 2012-10-22
  625          //========================================================================
  626          void test2()
  627          {
  628   1        SCON = 0x50;  // 8位数据,可变波特率
  629   1        AUXR |= 0x40; // 定时器时钟1T模式
  630   1        AUXR &= 0xFE; // 串口1选择定时器1为波特率发生器
  631   1        TMOD &= 0x0F; // 设置定时器模式
  632   1        TL1 = 0xB8;   // 设置定时初始值
  633   1        TH1 = 0xFF;   // 设置定时初始值
  634   1        ET1 = 0;    // 禁止定时器%d中断
  635   1        TR1 = 1;    // 定时器1开始计时
  636   1        ES = 1;
C251 COMPILER V5.60.0,  main                                                               15/09/23  14:25:37  PAGE 11  

  637   1        EA = 1;
  638   1        P_SW1 = 0x00; // RXD/P3.0, TXD/P3.1
  639   1      
  640   1      }
  641          int errpromdizhi=0x000040;
  642          #define u8 unsigned char
  643          void writebuf()
  644          {
  645   1        u8 get[10];
  646   1        get[0]=55;
  647   1        get[1]=g_dianliu/100;
  648   1        get[2]=g_dianliu%100;
  649   1        EEPROM_SectorErase(errpromdizhi);
  650   1        EEPROM_write_n(errpromdizhi,get,3);
  651   1      }
  652          
  653          void readbuf()
  654          {
  655   1        u8 get[10];
  656   1      
  657   1          EEPROM_read_n(errpromdizhi,get,3);
  658   1          if(get[0]==55)
  659   1          {
  660   2              printf("has init\n");
  661   2          g_dianliu=get[1]*100+get[2];
  662   2          if(g_dianliu>=2047)
  663   2          {
  664   3            g_dianliu=2047;
  665   3          }
  666   2          if(g_dianliu<=0)
  667   2          {
  668   3            g_dianliu=0;
  669   3          }
  670   2          printf("has init %d-%d\n",get[1],get[2]);
  671   2          }
  672   1          else
  673   1          {
  674   2              printf("not init\n");
  675   2          get[0]=55;
  676   2          g_dianliu=550;
  677   2            EEPROM_write_n(errpromdizhi,get,1);
  678   2          }
  679   1      }
  680          void main(void)
  681          {
  682   1        WTST = 0;   //设置程序指令延时参数，赋值为0可将CPU执行指令的速度设置为最快
  683   1        EAXSFR();   //扩展SFR(XFR)访问使能 
  684   1        CKCON = 0;      //提高访问XRAM速度
  685   1        
  686   1        XOSCCR = 0xc0;        //启动外部晶振
  687   1        while(!(XOSCCR&1));   //等待时钟稳定
  688   1        CLKDIV = 0x00;        //时钟不分频
  689   1        CLKSEL = 0x0;        //选择外部时钟   
  690   1        GPIO_confibase();
  691   1        SYS_Init();
  692   1        test2();
  693   1        GPIO_configcom3();
  694   1        Uart23Init();
  695   1        P4_MODE_IO_PU(GPIO_Pin_0|GPIO_Pin_1);
  696   1        P3_MODE_IO_PU(GPIO_Pin_6|GPIO_Pin_4);
  697   1        Timer0Init();
  698   1        delay_ms(50);
  699   1      
  700   1        LCD_Init();
  701   1        delay_ms(50);
  702   1        LCD_Fill(0, 0, 320, 240, BLACK);
C251 COMPILER V5.60.0,  main                                                               15/09/23  14:25:37  PAGE 12  

  703   1        delay_ms(50);
  704   1        pingmuclear();
  705   1        delay_ms(50);
  706   1        mainrun();
  707   1      }
*** WARNING C135 IN LINE 201 OF ..\User\main.c: 'writedizhi?': no return value
*** WARNING C135 IN LINE 201 OF ..\User\main.c: 'writedizhi?': no return value


Module Information          Static   Overlayable
------------------------------------------------
  code size            =        12     ------
  ecode size           =      2986     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       132        333
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       739     ------
End of Module Information.


C251 COMPILATION COMPLETE.  14 WARNING(S),  0 ERROR(S)
