C251 COMPILER V5.60.0,  main                                                               23/07/23  06:23:14  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE main.c XSMALL BROWSE DEBUG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.
                    -\Objects\main.obj) 

stmt  level    source

    1          #include "stc32g.h"
    2          #include <intrins.h>
    3          #include <stdio.h>
    4          #include "lcd.h"
    5          #include <string.h>
    6          
    7          #include <stdio.h>
    8          #include <string.h>
    9          #include <stdlib.h>
   10          
   11          #define u8 unsigned char
   12          #define FOSC 24000000UL
   13          #define BRT (65536 - FOSC / 9600 / 4)
   14          int writedizhi(int dizhi, int zhi);
   15          int keyon = 0;
   16          int keylow = 1;
   17          int keyok = 2;
   18          int keyup = 3;
   19          
   20          int nowzhi = 0;
   21          int setzhi = 0;
   22          
   23          char flagsystemrun = 0;
   24          #define maxsetzhi 2047
   25          
   26          void showhenxiang();
   27          void ledopen(int weizhi);
   28          bit busy;
   29          void UartInit() // 24 9600
   30          {
   31   1        SCON = 0x50;  // 8位数据,可变波特率
   32   1        AUXR |= 0x40; // 定时器时钟1T模式
   33   1        AUXR &= 0xFE; // 串口1选择定时器1为波特率发生器
   34   1        TMOD &= 0x0F; // 设置定时器模式
   35   1        TL1 = 0xCC;   // 设置定时初始值
   36   1        TH1 = 0xFF;   // 设置定时初始值
   37   1        ET1 = 0;    // 禁止定时器%d中断
   38   1        TR1 = 1;    // 定时器1开始计时
   39   1        ES = 1;
   40   1        EA = 1;
   41   1        P_SW1 = 0x00; // RXD/P3.0, TXD/P3.1
   42   1      }
   43          void UartSendByte(u8 dat)
   44          {
   45   1        SBUF = dat;
   46   1        while (TI == 0)
   47   1          ;
   48   1        TI = 0;
   49   1      }
   50          char putchar(char dat)
   51          {
   52   1        SBUF = dat;
   53   1        while (TI == 0)
   54   1          ;
   55   1        TI = 0;
   56   1        return (dat);
   57   1      }
   58          
C251 COMPILER V5.60.0,  main                                                               23/07/23  06:23:14  PAGE 2   

   59          void UartSendStr(u8 *str)
   60          {
   61   1        while (*str)
   62   1        {
   63   2          UartSendByte(*str);
   64   2          str++;
   65   2        }
   66   1      }
   67          void Uart2Init()
   68          {
   69   1        S2CON = 0x10;
   70   1        T2L = BRT;
   71   1        T2H = BRT >> 8;
   72   1        AUXR |= 0x14;
   73   1        IE2 = 0x01;
   74   1        EA = 1;
   75   1      }
   76          void Uart2Send(char dat)
   77          {
   78   1        while (busy)
   79   1          ;
   80   1        busy = 1;
   81   1        S2BUF = dat;
   82   1      }
   83          
   84          void Uart2SendStr(char *p)
   85          {
   86   1        while (*p)
   87   1        {
   88   2          Uart2Send(*p++);
   89   2        }
   90   1      }
   91          
   92          void Timer0Init(void) // 2毫秒@11.0592MHz
   93          {
   94   1        AUXR |= 0x80; // 定时器时钟1T模式
   95   1        TMOD &= 0xF0; // 设置定时器模式
   96   1        TL0 = 0x80;   // 设置定时初始值
   97   1        TH0 = 0x44;   // 设置定时初始值
   98   1        TF0 = 0;    // 清除TF0标志
   99   1        TR0 = 1;    // 定时器0开始计时
  100   1        TR0 = 1;    // 定时器0开始计时
  101   1        ET0 = 1;    // 使能定时器0中断
  102   1        PT0 = 1;
  103   1        EA = 1;
  104   1        //    IT0 = 1;                                    //??INT0?????
  105   1        //    EX0 = 1;                                    //??INT0??
  106   1        //    EA = 1;
  107   1        //
  108   1        //  IT1 = 1;                                    //??INT1?????
  109   1        //    EX1 = 1;                                    //??INT1??
  110   1        //    EA = 1;
  111   1      }
  112          
  113          sbit X0 = P2 ^ 3;
  114          sbit X1 = P2 ^ 1;
  115          sbit X2 = P3 ^ 7;
  116          sbit X3 = P3 ^ 5;
  117          
  118          sbit LED3 = P3 ^ 4;
  119          sbit LED2 = P3 ^ 6;
  120          
  121          sbit LED1 = P2 ^ 0;
  122          sbit LED0 = P2 ^ 2;
  123          sbit Y3 = P3 ^ 4;
  124          sbit Y2 = P3 ^ 6;
C251 COMPILER V5.60.0,  main                                                               23/07/23  06:23:14  PAGE 3   

  125          
  126          sbit Y1 = P2 ^ 0;
  127          sbit Y0 = P2 ^ 2;
  128          
  129          char xin[30] = {0};
  130          void shurulvbo(void)
  131          {
  132   1        static u8 keybuf[40] = {
  133   1          0xFF,
  134   1          0xFF,
  135   1          0xFF,
  136   1          0xFF,
  137   1          0xFF,
  138   1          0xFF,
  139   1          0xFF,
  140   1          0xFF,
  141   1          0xFF,
  142   1          0xFF,
  143   1          0xFF,
  144   1          0xFF,
  145   1          0xFF,
  146   1          0xFF,
  147   1          0xFF,
  148   1          0xFF,
  149   1          0xFF,
  150   1          0xFF,
  151   1          0xFF,
  152   1          0xFF,
  153   1          0xFF,
  154   1          0xFF,
  155   1          0xFF,
  156   1          0xFF,
  157   1          0xFF,
  158   1          0xFF,
  159   1          0xFF,
  160   1          0xFF,
  161   1          0xFF,
  162   1          0xFF,
  163   1          0xFF,
  164   1          0xFF,
  165   1          0xFF,
  166   1          0xFF,
  167   1          0xFF,
  168   1          0xFF,
  169   1          0xFF,
  170   1          0xFF,
  171   1          0xFF,
  172   1          0xFF,
  173   1        }; // 矩阵按键扫描缓冲区 8ms
  174   1        unsigned char i;
  175   1        i = X0;
  176   1        keybuf[0] = (keybuf[0] << 1) | i;
  177   1        i = X1;
  178   1        keybuf[1] = (keybuf[1] << 1) | i;
  179   1        i = X2;
  180   1        keybuf[2] = (keybuf[2] << 1) | i;
  181   1        i = X3;
  182   1        keybuf[3] = (keybuf[3] << 1) | i;
  183   1        for (i = 0; i < 10; i++) // 3按键，所以循环3次
  184   1        {
  185   2          if ((keybuf[i] & 0xFF) == 0x00)
  186   2          {
  187   3            xin[i] = 0;
  188   3          }
  189   2          else if ((keybuf[i] & 0xFF) == 0xFF)
  190   2          { // 连续3次扫描值为1，即1*8ms内都是弹起状态时，可认为按键已稳定的弹起
C251 COMPILER V5.60.0,  main                                                               23/07/23  06:23:14  PAGE 4   

  191   3            xin[i] = 1;
  192   3          }
  193   2        }
  194   1      }
  195          char flagsetzhichange = 0;
  196          // 是否能够设置值的状态。。。  ok键按下 即可。。。
  197          char flagcanset = 0;
  198          void setdianliu(int zhi)
  199          {
  200   1        writedizhi(4, zhi);
  201   1      }
  202          void setzhichange(int a)
  203          {
  204   1        if (flagcanset == 0)
  205   1          return;
  206   1        if (setzhi + a < 0)
  207   1        {
  208   2          setzhi = 0;
  209   2          // 0的情况也发，保证能够被收到。。
  210   2          flagsetzhichange = 1;
  211   2          setdianliu(setzhi);
  212   2          // printf("setdianliu%d\r\n",setzhi);
  213   2          return;
  214   2        }
  215   1        if (setzhi + a > maxsetzhi)
  216   1        {
  217   2          setzhi = maxsetzhi;
  218   2          return;
  219   2        }
  220   1        setzhi = setzhi + a;
  221   1        flagsetzhichange = 1;
  222   1        setdianliu(setzhi);
  223   1      }
  224          
  225          void keydown(int i) // 按键按下的处理、、、
  226          {
  227   1        if (i == keyon)
  228   1        {
  229   2          LED0 = ~LED0;
  230   2          // 结束时候关灯， 开机键盘开灯。。。
  231   2          if (flagsystemrun == 0)
  232   2          {
  233   3            flagsystemrun = 1;
  234   3            LCD_ShowString(0, 0, "Circle TAC", RED, WHITE, 32, 0);
  235   3            showhenxiang();
  236   3            writedizhi(2,1);
  237   3            delay_ms(30);
  238   3            writedizhi(2,1);
  239   3            delay_ms(30);
  240   3            setdianliu(setzhi);
  241   3            delay_ms(10);
  242   3          }
  243   2          else
  244   2          {
  245   3            writedizhi(2,0);
  246   3            delay_ms(100);
  247   3            writedizhi(2,0);
  248   3            IAP_CONTR = 0x60;
  249   3          }
  250   2        }
  251   1        if (flagcanset)
  252   1        {
  253   2          ledopen(i);
  254   2        }
  255   1        if (i == keylow)
  256   1        {
C251 COMPILER V5.60.0,  main                                                               23/07/23  06:23:14  PAGE 5   

  257   2          setzhichange(-1);
  258   2          return;
  259   2        }
  260   1        if (i == keyup)
  261   1        {
  262   2          setzhichange(1);
  263   2          return;
  264   2        }
  265   1        if (i == keyok)
  266   1        {
  267   2          flagcanset = 1 - flagcanset;
  268   2          LED2 = ~LED2;
  269   2        }
  270   1      }
  271          int keyshi = 3;
  272          // 按键连续按下多少次的操作。。
  273          int setbizhi(int times)
  274          {
  275   1        if (times < 15 * keyshi)
  276   1        {
  277   2          return 10;
  278   2        }
  279   1        if (times < 50 * keyshi)
  280   1        {
  281   2          return 50;
  282   2        }
  283   1        return 100;
  284   1      }
  285          // 2ms 一次的话，那300ms一次ok的吧。。
  286          void dolongtimes(int i, int times)
  287          {
  288   1        int xielv;
  289   1        times = times - 300;
  290   1        if (times < 0)
  291   1        {
  292   2          return;
  293   2        }
  294   1        xielv = setbizhi(times);
  295   1        if (times % keyshi != 0)
  296   1        {
  297   2          return;
  298   2        }
  299   1        if (i == keylow)
  300   1        {
  301   2          setzhichange(-xielv);
  302   2          return;
  303   2        }
  304   1        if (i == keyup)
  305   1        {
  306   2          setzhichange(xielv);
  307   2          return;
  308   2        }
  309   1      }
  310          void yout_set(char weizhi, char zhi)
  311          {
  312   1        if (weizhi == 0)
  313   1          Y0 = zhi;
  314   1        if (weizhi == 1)
  315   1          Y1 = zhi;
  316   1        if (weizhi == 2)
  317   1          Y2 = zhi;
  318   1        if (weizhi == 3)
  319   1          Y3 = zhi;
  320   1      }
  321          void ledclose(int weizhi)
  322          {
C251 COMPILER V5.60.0,  main                                                               23/07/23  06:23:14  PAGE 6   

  323   1        if (weizhi == keyon || weizhi == keyok)
  324   1        {
  325   2          return;
  326   2        }
  327   1        yout_set(weizhi, 1);
*** WARNING C188 IN LINE 327 OF main.c: 'parameter 1': value truncated
  328   1      }
  329          void ledopen(int weizhi)
  330          {
  331   1        if (weizhi == keyon || weizhi == keyok)
  332   1        {
  333   2          return;
  334   2        }
  335   1        yout_set(weizhi, 0);
*** WARNING C188 IN LINE 335 OF main.c: 'parameter 1': value truncated
  336   1      }
  337          void keyallchuli()
  338          {
  339   1        int i;
  340   1        static char flag[10] = {0};   // 标志记录
  341   1        static int dowmtimes[10] = {0}; // 标志记录
  342   1        for (i = 0; i < 6; i++)
  343   1        {
  344   2          if (xin[i] == 0)
  345   2          {
  346   3            if (flag[i] == 0) // 代表按键第一次按下。。。
  347   3            {
  348   4              flag[i] = 1;
  349   4              keydown(i);
  350   4            }
  351   3      
  352   3            dowmtimes[i]++;
  353   3            dolongtimes(i, dowmtimes[i]);
  354   3          }
  355   2          else
  356   2          {
  357   3            flag[i] = 0;
  358   3            dowmtimes[i] = 0;
  359   3            ledclose(i);
  360   3          }
  361   2        }
  362   1      }
  363          
  364          int tmp = 203; // 温度值
  365          void shownwendu()
  366          {
  367   1        char dataxx[40];
  368   1        sprintf(dataxx, "TMP:%3d.%01d  ", tmp / 10, tmp % 10);
  369   1        LCD_ShowString(0, 80, dataxx, RED, WHITE, 32, 0);
  370   1      }
  371          
  372          void shownow()
  373          {
  374   1        // char dataxx[40];
  375   1        // sprintf(dataxx,"NOW:%05d",nowzhi);
  376   1        // LCD_ShowString(0,40,dataxx,RED,WHITE,32,0);
  377   1      }
  378          
  379          #define maxjindu 16
  380          #define qidian 0
  381          
  382          void pingmuclear()
  383          {
  384   1        char dataxx[60] = {0};
  385   1        static int runflag2 = 0;
  386   1        int i;
C251 COMPILER V5.60.0,  main                                                               23/07/23  06:23:14  PAGE 7   

  387   1        if (runflag2 == 1)
  388   1        {
  389   2          return;
  390   2        }
  391   1        runflag2 = 1;
  392   1        // LCD_Clear(WHITE);
  393   1      
  394   1        sprintf(dataxx, "                     ", 1);
  395   1        for (i = 0; i < 10; i++)
  396   1        {
  397   2          LCD_ShowString(0, i * 30, dataxx, RED, WHITE, 32, 0);
  398   2          delay_ms(10);
  399   2        }
  400   1      }
  401          void showhenxiang()
  402          {
  403   1        int i;
  404   1        char dataxx[60] = {0};
  405   1        static int runflag = 0;
  406   1        if (runflag == 1)
  407   1        {
  408   2          return;
  409   2        }
  410   1        runflag = 1;
  411   1      
  412   1        for (i = 0; i < maxjindu; i++)
  413   1        {
  414   2          dataxx[i] = '-';
  415   2        }
  416   1      
  417   1        LCD_ShowString(qidian, 140, dataxx, RED, WHITE, 32, 0);
  418   1        LCD_ShowString(qidian, 140 + 40, dataxx, RED, WHITE, 32, 0);
  419   1        LCD_ShowString(qidian, 140 + 40 + 30, "0            12bit          2047", RED, WHITE, 16, 0);
  420   1      }
  421          
  422          void showjindtiao()
  423          {
  424   1        int i;
  425   1        char dataxx[60] = {0};
  426   1        int jindu;
  427   1        jindu = setzhi * maxjindu / maxsetzhi;
  428   1        for (i = 0; i < maxjindu; i++)
  429   1        {
  430   2          if (i < jindu)
  431   2            dataxx[i] = '>';
  432   2          else
  433   2            dataxx[i] = ' ';
  434   2        }
  435   1        showhenxiang();
  436   1        LCD_ShowString(qidian, 160, dataxx, RED, WHITE, 32, 0);
  437   1      }
  438          void showsetzhi()
  439          {
  440   1        char dataxx[40];
  441   1        sprintf(dataxx, "SET:        %04d    ", setzhi);
  442   1        LCD_ShowString(0, 120, dataxx, RED, WHITE, 32, 0);
  443   1        showjindtiao();
  444   1      }
  445          void showdata()
  446          {
  447   1        if (flagsystemrun == 0)
  448   1        {
  449   2          return;
  450   2        }
  451   1        shownow();
  452   1        showsetzhi();
C251 COMPILER V5.60.0,  main                                                               23/07/23  06:23:14  PAGE 8   

  453   1        shownwendu();
  454   1      }
  455          int getwendu();
  456          void init();
  457          int readzhi(int dizhi);
  458          int readdianliuzhi()
  459          {
  460   1        int ans;
  461   1        ans= readzhi(4);
  462   1        if(ans>=0 && ans<=2047)
  463   1        {
  464   2          return ans;
  465   2        }
  466   1        return 0;
  467   1      }
  468          void main()
  469          {
  470   1        int rumtimes = 0;
  471   1        init();
  472   1        setzhi = readdianliuzhi();
  473   1        // setzhi=readzhi(4);
  474   1        while (1)
  475   1        {
  476   2          shurulvbo();
  477   2          keyallchuli();
  478   2          delay_ms(1);
  479   2          if (flagsetzhichange == 1)
  480   2          {
  481   3            flagsetzhichange = 0;
  482   3            showdata();
  483   3            rumtimes = 0;
  484   3          }
  485   2          else
  486   2          {
  487   3            rumtimes++;
  488   3          }
  489   2          if (rumtimes++ > 500)
  490   2          {
  491   3            rumtimes = 0;
  492   3      
  493   3            tmp = getwendu();
  494   3            showdata();
  495   3          }
  496   2        }
  497   1      }
  498          int weishu1, weishu2, weishu3, weishu4;
  499          char buf1[300];
  500          int timeleft1, timeleft2, timeleft3, timeleft4;
  501          char falgchuankou1 = 0;
  502          void chuankou1put(char c)
  503          {
  504   1        buf1[weishu1++] = c;
  505   1        if (weishu1 >= sizeof(buf1))
  506   1          weishu1 = 0;
  507   1        timeleft1 = 3;
  508   1      }
  509          static void chuliguankji(char *ans1)
  510          {
  511   1        char *index;
  512   1        index = strstr(ans1, "@STCISP#");
*** WARNING C140 IN LINE 512 OF main.c: 'strstr' undefined; assuming 'extern int strstr()'
*** WARNING C95 IN LINE 512 OF main.c: 'strstr': too many actual parameters
*** WARNING C40 IN LINE 512 OF main.c: 'int' converted to 'far' pointer
  513   1        if (index == 0)
  514   1        {
  515   2          return;
C251 COMPILER V5.60.0,  main                                                               23/07/23  06:23:14  PAGE 9   

  516   2        }
  517   1        printf("rec @STCISP#,researt now");
  518   1        IAP_CONTR = 0x60;
  519   1      }
  520          void clearbuff1()
  521          {
  522   1        memset(buf1, 0, sizeof(buf1));
  523   1        weishu1 = 0;
  524   1        falgchuankou1 = 0;
  525   1      }
  526          
  527          int readzhi(int dizhi)
  528          {
  529   1        int times = 0;
  530   1        int ans;
  531   1        char dataxx[40];
  532   1        sprintf(dataxx, "pingmuGetData getdizhi%d-", dizhi);
  533   1        clearbuff1();
  534   1        printf(dataxx);
  535   1        while (1)
  536   1        {
  537   2          delay_ms(1);
  538   2          if (times++ > 100)
  539   2          {
  540   3            return 0;
  541   3          }
  542   2          if (falgchuankou1)
  543   2          {
  544   3            char *index;
  545   3            index = strstr(buf1, dataxx);
*** WARNING C95 IN LINE 545 OF main.c: 'strstr': too many actual parameters
*** WARNING C40 IN LINE 545 OF main.c: 'int' converted to 'far' pointer
  546   3            if (index != 0)
  547   3            {
  548   4              ans = atoi(index + strlen(dataxx));
  549   4              printf("read ans%d\n", ans);
  550   4              return ans;
  551   4            }
  552   3            clearbuff1();
  553   3          }
  554   2        }
  555   1      }
  556          // 上到下  灰白黑紫
  557          int writedizhi(int dizhi, int zhi)
  558          {
  559   1        int times = 0;
  560   1        int ans;
  561   1        char dataxx[40];
  562   1        sprintf(dataxx, "pingmuSetData setdizhi0%d-%d", dizhi, zhi);
  563   1        clearbuff1();
  564   1        printf(dataxx);
  565   1        while (1)
  566   1        {
  567   2          delay_ms(1);
  568   2          if (times++ > 100)
  569   2          {
  570   3            return 0;
  571   3          }
  572   2          if (falgchuankou1)
  573   2          {
  574   3            char *index;
  575   3            index = strstr(buf1, "pingmuSetData zhi");
*** WARNING C95 IN LINE 575 OF main.c: 'strstr': too many actual parameters
*** WARNING C40 IN LINE 575 OF main.c: 'int' converted to 'far' pointer
  576   3            if (index != 0)
  577   3            {
C251 COMPILER V5.60.0,  main                                                               23/07/23  06:23:14  PAGE 10  

  578   4              return 0;
  579   4            }
  580   3            clearbuff1();
  581   3          }
  582   2        }
  583   1      }
*** WARNING C47 IN LINE 560 OF main.c: 'ans': unreferenced local variable
  584          // 发数据出去，，然后收所有的，检验返回的值。。
  585          void chuankou1time()
  586          {
  587   1        if (timeleft1 > 0)
  588   1        {
  589   2          timeleft1--;
  590   2          if (timeleft1 == 0) // 数据一次收完了.
  591   2          {
  592   3            chuliguankji(buf1);
  593   3            falgchuankou1 = 1;
  594   3          }
  595   2        }
  596   1      }
  597          
  598          // 采用中断和处理分开的方式吧，方便调试。。
  599          int getwendu()
  600          {
  601   1        return readzhi(6);
  602   1      }
  603          void UartIsr() interrupt 4
  604          {
  605   1        if (RI)
  606   1        {
  607   2          RI = 0;
  608   2          chuankou1put(SBUF);
  609   2        }
  610   1      }
  611          
  612          void tm0_isr() interrupt 1
  613          {
  614   1        chuankou1time();
  615   1      }
  616          
  617          void init()
  618          {
  619   1        delay_ms(10);
  620   1        P0M0 = 0x00;
  621   1        P0M1 = 0x02;
  622   1        P1M0 = 0x00;
  623   1        P1M1 = 0x00;
  624   1        P2M0 = 0x00;
  625   1        P2M1 = 0x00;
  626   1        P3M0 = 0x00;
  627   1        P3M1 = 0x00;
  628   1        P4M0 = 0x00;
  629   1        P4M1 = 0x00;
  630   1        P5M0 = 0x00;
  631   1        P5M1 = 0x00;
  632   1        SPCTL = 0x50 | 0x80; //??SPI????
  633   1        SPSTAT = 0xc0;     //?????
  634   1        LCD_LED = 0;
  635   1        LED0 = ~LED0;
  636   1        delay_ms(50);
  637   1      
  638   1        LCD_Init();
  639   1        UartInit();
  640   1      
  641   1        Timer0Init();
  642   1        delay_ms(50);
C251 COMPILER V5.60.0,  main                                                               23/07/23  06:23:14  PAGE 11  

  643   1      
  644   1        LCD_Fill(0, 0, 320, 240, WHITE);
  645   1        printf("system begin\r");
  646   1        delay_ms(50);
  647   1        pingmuclear();
  648   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2047     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       440        348
  bit size             =         1     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       611     ------
End of Module Information.


C251 COMPILATION COMPLETE.  10 WARNING(S),  0 ERROR(S)
