C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc251\C251\BIN\C251.EXE main.c LARGE BROWSE DEBUG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.
                    -\Objects\main.obj) 

stmt  level    source

    1          //  @布丁橘长 2023/03/10
    2          //  PWM编码器模式示例，本示例程序编码器模式1/2/3均支持，SMCR = 1：模式1，SMCR = 2:模式2，SMCR = 3：模式3
    3          //  EC11左旋或右旋，改变数码管亮度
    4          //  EC11引脚定义：A相-P1.0，B相-P5.4
    5          //  MAX7219数码管模块引脚定义：CS = P6^5;DIN = P6^6;CLK = P6^4;（可在MAX7219.h中修改）
    6          //  实验开发板：屠龙刀三.1 @主频12MHz
    7          
    8          
    9          
   10          
   11          
   12          
   13          
   14          
   15          #include <string.h>
   16          #include "stc32g.h"
   17          #include "config.h"
   18          
   19          
   20          #include <stdio.h>
   21          #include <stdarg.h>
   22          #include <stdio.h>
   23          
   24          #include <stdlib.h>
   25          #include "uart.h"
*** WARNING C317 IN LINE 24 OF uart.h: attempt to redefine macro 'MAIN_Fosc'
   26          #include "tongxin.h"
   27          #include "tongxin2.h"
   28          #include "STC32G_EEPROM.h"
   29          
   30          void SYS_Ini();   // STC32初始化设置
   31          void EC11_Handle(); // EC11数据处理
   32                    // 数码管显示
   33          void PWM_Config(); // PWM初始化设置
   34          
   35          u8 cnt_H, cnt_L;   // 计数值高8位、低8位
   36          u16 count, newcount; // 当前计数值、上次计数值
   37                     // 亮度计数值
   38          
   39          
   40          
   41          char rec2[200]={0};
   42          int weizhi2=0;
   43          // 01 是用力啊检查地址的，，默认55
   44          u16 g_reg[40]={0};
   45          #define indexdianniunow 19
   46          #define indexAdddianliu 20
   47          #define indexTImeuse 21
   48          #define indexTImeAll 22
   49          #define indexMAXdianliu 23
   50          
   51          
   52          
   53          // 最后下去到板子的要乘以2，，最后的计算值。。
   54          
   55          
   56          void SYS_Ini() // STC32初始化设置
   57          {
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 2   

   58   1        EAXFR = 1;    // 使能访问 XFR
   59   1        CKCON = 0x00; // 设置外部数据总线速度为最快
   60   1        WTST = 0x00;  // 设置程序代码等待参数，赋值为 0 可将 CPU 执行程序的速度设置为最快
   61   1        P0M1 = 0x00;
   62   1        P0M0 = 0x00; // 设置P0口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   63   1        P1M1 = 0x00;
   64   1        P1M0 = 0x00; // 设置P1口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   65   1        P2M1 = 0x00;
   66   1        P2M0 = 0x00; // 设置P2口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   67   1        P3M1 = 0x00;
   68   1        P3M0 = 0x00; // 设置P3口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   69   1        P4M1 = 0x00;
   70   1        P4M0 = 0x00; // 设置P4口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   71   1        P5M1 = 0x00;
   72   1        P5M0 = 0x00; // 设置P5口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   73   1        P6M1 = 0x00;
   74   1        P6M0 = 0x00; // 设置P6口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   75   1        P7M1 = 0x00;
   76   1        P7M0 = 0x00; // 设置P7口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   77   1      }
   78          
   79          
   80          
   81          void Delay100ms() //@24.000MHz
   82          {
   83   1        unsigned long i;
   84   1      
   85   1        _nop_();
   86   1        _nop_();
   87   1        i = 599998UL;
   88   1        while (i)
   89   1          i--;
   90   1      }
   91          // 定义printf函数
   92          void printf1(const char *fmt, ...)
   93          {
   94   1        char *p;
   95   1        char buf[128]; // 定义一个缓冲区，足够存储输出的字符串
   96   1        va_list args;
   97   1        va_start(args, fmt);
   98   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
   99   1        va_end(args);
  100   1      
  101   1        p = (unsigned char *)buf;
  102   1        while (*p != '\0')
  103   1        {
  104   2          sendbyte1(*p);
  105   2          p++;
  106   2        }
  107   1      }
  108          
  109          // 定义printf函数
  110          void printtoDianao(const char *fmt, ...)
  111          {
  112   1        char *p;
  113   1        char buf[400]={0}; // 定义一个缓冲区，足够存储输出的字符串
  114   1        va_list args;
  115   1        va_start(args, fmt);
  116   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
  117   1        va_end(args);
  118   1        p = (unsigned char *)buf;
  119   1        while (*p != '\0')
  120   1        {
  121   2          sendbyte1(*p);
  122   2          p++;
  123   2        }
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 3   

  124   1      }
  125          
  126          
  127          
  128          
  129          // 定义printf函数
  130          void printfTopingmu(const char *fmt, ...)
  131          {
  132   1        char *p;
  133   1        char buf[128]; // 定义一个缓冲区，足够存储输出的字符串
  134   1        va_list args;
  135   1        va_start(args, fmt);
  136   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
  137   1        va_end(args);
  138   1      
  139   1        p = (unsigned char *)buf;
  140   1        while (*p != '\0')
  141   1        {
  142   2          sendbyte3(*p);
  143   2          p++;
  144   2        }
  145   1      }
  146          
  147          char code duanzhi[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e
             -, 0x79, 0x71, 0x76, 0x00, 0x40, 0xff};
  148          
  149          sbit led4 = P4 ^ 3;
  150          sbit led3 = P4 ^ 4;
  151          sbit led2 = P2 ^ 0;
  152          sbit led1 = P2 ^ 1;
  153          #define Y0 led1
  154          #define Y1 led2
  155          #define Y2 led3
  156          #define Y3 led4
  157          
  158          char yout_set(char weizhi, char zhi)
  159          {
  160   1        if (weizhi == 0)
  161   1          Y0 = zhi;
  162   1        if (weizhi == 1)
  163   1          Y1 = zhi;
  164   1        if (weizhi == 2)
  165   1          Y2 = zhi;
  166   1        if (weizhi == 3)
  167   1          Y3 = zhi;
  168   1      
  169   1        return (0);
  170   1      }
  171          void yout_closeall()
  172          {
  173   1        char i;
  174   1        for (i = 0; i < 4; i++)
  175   1        {
  176   2          yout_set(i, 1);
  177   2        }
  178   1      }
  179          void Delay10us() //@24.000MHz
  180          {
  181   1        unsigned long i;
  182   1      
  183   1        _nop_();
  184   1        _nop_();
  185   1        _nop_();
  186   1        i = 58UL;
  187   1        while (i)
  188   1          i--;
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 4   

  189   1      }
  190          void delay10x(int i)
  191          {
  192   1        while (i-- > 0)
  193   1        {
  194   2          Delay10us();
  195   2        }
  196   1      }
  197          int flag_error=0;
  198          void showpre(int num)
  199          {
  200   1        int i;
  201   1        int a[4];
  202   1        a[0] = num % 10000 / 1000;
  203   1        a[1] = num % 1000 / 100;
  204   1      
  205   1        a[2] = num % 100 / 10;
  206   1        a[3] = num % 10;
  207   1        
  208   1        for (i = 0; i < 4; i++)
  209   1        {
  210   2          yout_closeall();
  211   2          yout_set(i, 0);
*** WARNING C188 IN LINE 211 OF main.c: 'parameter 1': value truncated
  212   2          if(flag_error==1)
  213   2          {
  214   3            if(i==0 )
  215   3            {
  216   4              P0 = ~0x79;
  217   4            }
  218   3            if(i==1 ||i==2)
  219   3            {
  220   4              P0 = ~0x50;
  221   4            }
  222   3            if(i==3)
  223   3            {
  224   4              P0 = ~duanzhi[1];
  225   4            }
  226   3          }
  227   2          else
  228   2          {
  229   3            P0 = ~duanzhi[a[i]];
  230   3          }
  231   2          
  232   2          
  233   2          Delay10us();
  234   2          yout_closeall();
  235   2          P0 = 0xff;
  236   2          Delay10us();
  237   2        }
  238   1      }
  239          
  240          
  241          
  242          
  243          
  244          int g_dianliu = 600;
  245          
  246          
  247          
  248          
  249          
  250          
  251          
  252          char* mystrstr(const char* haystack, const char* needle) {
  253   1          if (*needle == '\0') {
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 5   

  254   2              return (char*)haystack;
  255   2          }
  256   1      
  257   1          while (*haystack != '\0') {
  258   2              const char* h = haystack;
  259   2              const char* n = needle;
  260   2      
  261   2              while (*n != '\0' && *h == *n) {
  262   3                  h++;
  263   3                  n++;
  264   3              }
  265   2      
  266   2              if (*n == '\0') {
  267   3                  return (char*)haystack; // 子串匹配成功，返回起始位置
  268   3              }
  269   2      
  270   2              haystack++;
  271   2          }
  272   1      
  273   1          return NULL; // 未找到子串，返回NULL
  274   1      }
  275          size_t mystrlen(const char* str) {
  276   1          size_t length = 0;
  277   1          while (str[length] != '\0') {
  278   2              length++;
  279   2          }
  280   1          return length;
  281   1      }
  282          
  283          char* myaddstrstr(const char* haystack, const char* needle)
  284          { 
  285   1        char* result = mystrstr(haystack, needle);
  286   1         if (result != NULL)
  287   1         {
  288   2          result=result+mystrlen(needle);
  289   2         }
  290   1         return result;
  291   1      }
  292          
  293          #define MAX_REGISTERS 10 // 设置最大寄存器数量
  294          
  295          struct Register
  296          {
  297            unsigned int num;
  298            unsigned int value;
  299          };
  300          struct Register registers[MAX_REGISTERS];
  301          int numRegisters = 0;
  302          void showgetzhi()
  303          {
  304   1        unsigned char i;
  305   1        if (i == 0)
  306   1        {
  307   2          printf1("Register not get");
  308   2        }
  309   1        // 遍历并打印所有寄存器的值
  310   1        for (i = 0; i < numRegisters; i++)
  311   1        {
  312   2          printf1("Register %d: %d\n", registers[i].num, registers[i].value);
  313   2        }
  314   1      }
  315          
  316          
  317          void jixi3(char* input)
  318          {
  319   1        char *p=input;
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 6   

  320   1        char *p1;
  321   1        int i;
  322   1        numRegisters=0;
  323   1        //1234-2234;333-4;end
  324   1        for( i=0;i<100;i++)
  325   1        {
  326   2          p1=myaddstrstr(p,";"); //找有没有下一个的
  327   2          if(p1==NULL)
  328   2          {
  329   3            break;
  330   3          }
  331   2          registers[numRegisters].num = atoi(p);
  332   2          p=myaddstrstr(p,"-");
  333   2          registers[numRegisters].value = atoi(p);
  334   2          numRegisters++;
  335   2          p=myaddstrstr(p,";");  //指向下一个后面
  336   2        }
  337   1        showgetzhi();
  338   1      }
  339          
  340          int flaginit=0;
  341          void setzhione(int dizhi,int zhi)
  342          {
  343   1        if(flaginit==0)
  344   1        {
  345   2          return ;
  346   2        }
  347   1        push(dizhi,zhi);
  348   1      }
  349          
  350          
  351          
  352          
  353          
  354          
  355          
  356          char xin[30] = {0};
  357          sbit X0=P1^3;
  358          sbit X1=P1^1;
  359          void shurulvbo(void)
  360          {
  361   1        static u8 keybuf[40] = {
  362   1          0xFF,
  363   1          0xFF,
  364   1          0xFF,
  365   1          0xFF,
  366   1          0xFF,
  367   1          0xFF,
  368   1          0xFF,
  369   1          0xFF,
  370   1          0xFF,
  371   1          0xFF,
  372   1          0xFF,
  373   1          0xFF,
  374   1          0xFF,
  375   1          0xFF,
  376   1          0xFF,
  377   1          0xFF,
  378   1          0xFF,
  379   1          0xFF,
  380   1          0xFF,
  381   1          0xFF,
  382   1          0xFF,
  383   1          0xFF,
  384   1          0xFF,
  385   1          0xFF,
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 7   

  386   1          0xFF,
  387   1          0xFF,
  388   1          0xFF,
  389   1          0xFF,
  390   1          0xFF,
  391   1          0xFF,
  392   1          0xFF,
  393   1          0xFF,
  394   1          0xFF,
  395   1          0xFF,
  396   1          0xFF,
  397   1          0xFF,
  398   1          0xFF,
  399   1          0xFF,
  400   1          0xFF,
  401   1          0xFF,
  402   1        }; // 矩阵按键扫描缓冲区 8ms
  403   1        unsigned char i;
  404   1        i = X0;
  405   1        keybuf[0] = (keybuf[0] << 1) | i;
  406   1        i = X1;
  407   1        keybuf[1] = (keybuf[1] << 1) | i;
  408   1        // i = X2;
  409   1        // keybuf[2] = (keybuf[2] << 1) | i;
  410   1        // i = X3;
  411   1        // keybuf[3] = (keybuf[3] << 1) | i;
  412   1        for (i = 0; i < 2; i++) // 3按键，所以循环3次
  413   1        {
  414   2          if ((keybuf[i] & 0xFF) == 0x00)
  415   2          {
  416   3            xin[i] = 0;
  417   3          }
  418   2          else if ((keybuf[i] & 0xFF) == 0xFF)
  419   2          { // 连续3次扫描值为1，即1*8ms内都是弹起状态时，可认为按键已稳定的弹起
  420   3            xin[i] = 1;
  421   3          }
  422   2        }
  423   1      }
  424          char flagsetliangdu=0;
  425          
  426          void EPPROMwrite();
  427          void keydown(int i) // 按键按下的处理、、、
  428          {
  429   1        printf1("keydown %d",i);
  430   1        if(i==0)
  431   1          setzhione(4,g_dianliu);
  432   1        if(i==1)
  433   1        {
  434   2          if(flagsetliangdu==1)//保存记录的值
  435   2          {
  436   3            printf1("flagsetliangdusetzhi %d",g_dianliu);
  437   3            g_reg[indexdianniunow]=g_dianliu;
  438   3            EPPROMwrite();
  439   3          }
  440   2          flagsetliangdu=1-flagsetliangdu;
  441   2        }
  442   1          
  443   1      
  444   1      }
  445          void keyup(int i) // 按键按下的处理、、、
  446          {
  447   1        printf1("keyup %d",i);
  448   1        if(i==0)
  449   1          setzhione(4,0);
  450   1      }
  451          void keyallchuli()
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 8   

  452          {
  453   1        int i;
  454   1        static char flag[10] = {0};   // 标志记录
  455   1        static int dowmtimes[10] = {0}; // 标志记录
  456   1        for (i = 0; i < 6; i++)
  457   1        {
  458   2          if (xin[i] == 0)
  459   2          {
  460   3            if (flag[i] == 0) // 代表按键第一次按下。。。
  461   3            {
  462   4              flag[i] = 1;
  463   4              keydown(i);
  464   4            }
  465   3          }
  466   2          if (xin[i] == 1)
  467   2          {
  468   3            if (flag[i] == 1) // 代表下去了又上来
  469   3            {
  470   4              keyup(i);
  471   4            }
  472   3            flag[i] = 0;
  473   3            
  474   3          }
  475   2        }
  476   1      }
  477          
  478          int FLASH_SAVE_ADDR=0x000040; 
  479          void STMFLASH_Write(u8 WriteAddr,u16 *pBuffer,u16 NumToWrite) 
  480          {
  481   1        EEPROM_SectorErase(WriteAddr);
  482   1        EEPROM_write_n(WriteAddr,(u8 *)pBuffer,NumToWrite*2);
  483   1      }
  484          void EPPROMwrite()
  485          {
  486   1        g_reg[0]=0x55;
  487   1        STMFLASH_Write(FLASH_SAVE_ADDR,g_reg,30);
*** WARNING C188 IN LINE 487 OF main.c: 'parameter 1': value truncated
  488   1      }
  489          void STMFLASH_Read(u32 ReadAddr,u16 *pBuffer,u16 NumToRead) 
  490          {
  491   1        EEPROM_read_n(ReadAddr,(u8 *)pBuffer,NumToRead*2);
  492   1      }
  493          void dealorder();
  494          void getdianliupre()
  495          {
  496   1      
  497   1      }
  498          int timereport=0;
  499          
  500          int errpromdizhi=0x000040;
  501          
  502          void showzhi()
  503          {
  504   1        int i;
  505   1        int len2=sizeof(g_reg[0]);
  506   1        int len=sizeof(g_reg);
  507   1        len=len/len2;
  508   1        for(i=0;i<len;i++)
  509   1        {
  510   2          if(g_reg[i]!=0)
  511   2          {
  512   3            printf("[%d-%d]",i,g_reg[i]);
  513   3          }
  514   2        }
  515   1      }
  516          void formatdianliu()
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 9   

  517          {
  518   1        if (g_dianliu>2047)
  519   1        {
  520   2          g_dianliu=2047;
  521   2        }
  522   1        if (g_dianliu<0)
  523   1        {
  524   2          g_dianliu=0;
  525   2        }
  526   1      }
  527          void EPPROMinit()
  528          {        
  529   1        STMFLASH_Read(FLASH_SAVE_ADDR,g_reg,30);
  530   1        if(g_reg[0]!=0x55)
  531   1        {
  532   2          printf("this is First record");
  533   2          memset(g_reg,0,sizeof(g_reg));
  534   2          g_reg[indexTImeAll]=25000;
  535   2          EPPROMwrite();
  536   2        }
  537   1        else
  538   1        {
  539   2          printf("not First record");
  540   2        }
  541   1        g_dianliu=g_reg[indexdianniunow];
  542   1        formatdianliu();
  543   1        showzhi();
  544   1      }
  545          void systemshowkaiji()
  546          {
  547   1        printtoDianao("system start now ,version 1.0,build 2023.08.06");
  548   1      }
  549          // sbit keyled1=P3^6;
  550          // sbit keyled2=P3^5;
  551          // #define ledon 0
  552          // #define ledclose 1
  553          // void showled()
  554          // {
  555          //  keyled1=ledclose;
  556          //  keyled2=ledclose;
  557          //  keyled2=ledon;
  558          // }
  559          void delay_ms(unsigned int ms)
  560          {
  561   1        unsigned int i;
  562   1        do{
  563   2          i = MAIN_Fosc / 6030;
  564   2          while(--i);
  565   2        }while(--ms);
  566   1      }
  567          
  568          void fuwei()
  569          {
  570   1        IAP_CONTR=0x60;
  571   1      }
  572          
  573          int com2jixi2(char* input)
  574          {
  575   1        char flagTrue=0;
  576   1        char *p=input;
  577   1        char *p1;
  578   1        int i;
  579   1        int weizhi;
  580   1        int zhi;
  581   1        int bakweizhi;
  582   1        int bakzhi;
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 10  

  583   1        for( i=0;i<100;i++)
  584   1        {
  585   2          p1=myaddstrstr(p,";"); //找有没有下一个的
  586   2          if(p1==NULL)
  587   2          {
  588   3            break;
  589   3          }
  590   2          weizhi = atoi(p);
  591   2          p=myaddstrstr(p,"-");
  592   2          zhi = atoi(p);
  593   2              if(i%2==0)
  594   2              {
  595   3                  bakweizhi=weizhi;
  596   3                  bakzhi=zhi;
  597   3              }
  598   2              if(i%2==1)
  599   2              {
  600   3                  if(weizhi==bakweizhi && bakzhi==zhi)
  601   3                  {
  602   4                      VectorPush(VectorDiannao,weizhi,zhi);
  603   4              flagTrue=1;
  604   4                  }
  605   3                  else
  606   3                  {
  607   4              flagTrue=0;
  608   4                      printf("get failed");
  609   4                  }
  610   3              }
  611   2          p=myaddstrstr(p,";");  //指向下一个后面
  612   2        }
  613   1        return flagTrue;
  614   1      }
  615          
  616          int  com2jiexi(char* input)
  617          {
  618   1        char par[1000]={0};
  619   1        char *begin,*end;
  620   1        begin=myaddstrstr(input,"set:");
  621   1        end=myaddstrstr(begin,"end");
  622   1        if(begin!=NULL && end!=NULL)
  623   1        {
  624   2          strcpy(par,begin);
  625   2          return com2jixi2(par);
  626   2        }
  627   1        return 0;
  628   1      }
  629          void getlogstr(int weizhi,char* input)
  630          {
  631   1        if(weizhi==indexAdddianliu)
  632   1        {
  633   2          strcpy(input,"初始电流");
  634   2        }
  635   1        if(weizhi==indexAdddianliu+1)
  636   1        {
  637   2          strcpy(input,"已用寿命");
  638   2        }
  639   1        if(weizhi==indexAdddianliu+2)
  640   1        {
  641   2          strcpy(input,"总的寿命");
  642   2        }
  643   1        if(weizhi==indexAdddianliu+3)
  644   1        {
  645   2          strcpy(input,"风扇速度");
  646   2        }
  647   1      }
  648          
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 11  

  649          int flag_canset=0;
  650          int precom2check(char *input)
  651          {
  652   1        int i;
  653   1        char *p;
  654   1        char outstr[30]={0};
  655   1        char outstr2[30]={0};
  656   1      
  657   1        p=mystrstr(input,"ruibaokesettingmimaflag"); //找有没有下一个的)
  658   1        if(p!=NULL)
  659   1        {
  660   2          printtoDianao("passwd checkpass,you can set now\n");
  661   2          printtoDianao("\n");
  662   2          printtoDianao("初始电流值地址 20\n");
  663   2          printtoDianao("已使用寿命地址 21\n");
  664   2          printtoDianao("总寿命地址 22\n");
  665   2          printtoDianao("风扇速度地址 23\n");
  666   2          printtoDianao("使用方式 设定地址+值\n");
  667   2          printtoDianao("以设定初始电流为例 发送[set:20-601;20-601;end] 其中20代表地址,601代表值\n");
  668   2          for(i=indexAdddianliu;i<indexAdddianliu+4;i++)
  669   2          {
  670   3            getlogstr(i,outstr);
  671   3            sprintf(outstr2,"%s:%d\n",outstr,g_reg[i]);
  672   3            printtoDianao(outstr2);
  673   3          }
  674   2          flag_canset=1;
  675   2          return 1;
  676   2        }
  677   1        p=mystrstr(input,"fuwei()"); //找有没有下一个的)
  678   1        if(p!=NULL)
  679   1        {
  680   2          fuwei();
  681   2        }
  682   1        return 0;
  683   1      
  684   1      }
  685          
  686          
  687          int shoumingjisuan(int predianliu)
  688          {
  689   1        int bili;
  690   1        if(g_reg[indexTImeAll]==0)
  691   1        return predianliu;
  692   1        bili=g_reg[indexTImeuse]*100/g_reg[indexTImeAll];
  693   1        if(bili>100)
  694   1        {
  695   2          return 0;
  696   2        }
  697   1        if(bili>90)
  698   1        {
  699   2          return predianliu*0.3;
  700   2        }
  701   1        if(bili>80)
  702   1        {
  703   2          return predianliu*0.5;
  704   2        }
  705   1        if(bili>70)
  706   1        {
  707   2          return predianliu*0.8;
  708   2        }
  709   1        return predianliu;
  710   1      }
  711          // 电流输出计算
  712          int jisuandianliu(int predianliu)
  713          {
  714   1        if(predianliu==0)
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 12  

  715   1        {
  716   2          return 0;
  717   2        }
  718   1        predianliu=predianliu+g_reg[indexAdddianliu];
  719   1        if(predianliu>2047)
  720   1        {
  721   2          predianliu=2047;
  722   2        }
  723   1        return shoumingjisuan(predianliu);
  724   1      }
  725          
  726          void dianliusendtokongzhiban(int zhi)
  727          {
  728   1        char out[30]={0};
  729   1        int weizhi=4;
  730   1        zhi=jisuandianliu(zhi);
  731   1        sprintf(out,"set:%d-%d;%d-%d;end",weizhi,zhi,weizhi,zhi);
  732   1        printfTopingmu(out);
  733   1        printf("%s",out);
  734   1      }
  735          
  736          
  737          
  738          int isCanSetWeizhi(int weizhi)
  739          {
  740   1        if(weizhi>=indexAdddianliu && weizhi<=indexMAXdianliu)
  741   1        {
  742   2          return 1;
  743   2        }
  744   1        return 0;
  745   1      }
  746          
  747          
  748          // push 指令相关的计算。。
  749          int selfdeal(int weizhi,int zhi)
  750          {
  751   1        char rspstr[100]={0};
  752   1        char rsp2[100]={0};
  753   1        if(flag_canset==0)
  754   1        {
  755   2          return 0;
  756   2        }
  757   1        if(0==isCanSetWeizhi(weizhi))
  758   1        {
  759   2          return 0;
  760   2        }
  761   1        g_reg[weizhi]=zhi;
  762   1        getlogstr(weizhi,rspstr);
  763   1        EPPROMwrite();
  764   1        sprintf(rsp2,"%s设定:%d-%d 成功;",rspstr,weizhi,zhi);
  765   1        printtoDianao(rsp2);
  766   1        return 1;
  767   1      }
  768          int selfdealread(int weizhi,int zhi)
  769          {
  770   1        char rspstr[100]={0};
  771   1        char rsp2[100]={0};
  772   1        if(weizhi<1000)
  773   1        return 0;
  774   1        if(flag_canset==0)
  775   1        {
  776   2          return 0;
  777   2        }
  778   1        weizhi=weizhi-1000;
  779   1        if(0==isCanSetWeizhi(weizhi))
  780   1        {
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 13  

  781   2          return 0;
  782   2        }
  783   1        getlogstr(weizhi,rspstr);
  784   1        sprintf(rsp2,"%s读取:%d-%d 成功;",rspstr,weizhi,g_reg[weizhi]);
  785   1        printtoDianao(rsp2);
  786   1        return 1;
  787   1      }
*** WARNING C47 IN LINE 768 OF main.c: 'zhi': unreferenced parameter
  788          // 电脑过来的指令，，，处理。。。
  789          // 一样是压进队列。。然后处理就可以了。。。就是这种了。。。
  790          void dealDiannaoOrder()
  791          {
  792   1          int weizhi,zhi;
  793   1          VectorInfo get={0};
  794   1          VectorGet(VectorDiannao,&get);
  795   1          if(get.weizhi==0)
  796   1          {
  797   2              return ;
  798   2          }
  799   1          weizhi=get.weizhi;
  800   1          zhi=get.zhi;
  801   1        if(weizhi==4)//电流设置，等待设置完成后再处理。。。其他设置不用管。。
  802   1        {
  803   2          delay_ms(10);
  804   2          g_dianliu=zhi;
  805   2          formatdianliu();
  806   2          dianliusendtokongzhiban(g_dianliu);
  807   2          delay_ms(10);
  808   2        }
  809   1        else
  810   1        {
  811   2          selfdeal(weizhi,zhi);
  812   2          selfdealread(weizhi,zhi);
  813   2        }
  814   1      }
  815          sbit keywendu1=P2^4;
  816          sbit keywendu2=P2^5;
  817          
  818          int iserror()
  819          {
  820   1        if(keywendu1==0)
  821   1        {
  822   2          flag_error=1;
  823   2          return 1;
  824   2        }
  825   1        if(keywendu2==0)
  826   1        {
  827   2          flag_error=1;
  828   2          return 1;
  829   2        }
  830   1        return 0;
  831   1      }
  832          void ShowInfoToDiannan()
  833          {
  834   1        char out[200]={0};
  835   1        if(g_dianliu>0)
  836   1        sprintf(out,"begin;open:%d;",g_dianliu);
  837   1        else
  838   1        sprintf(out,"begin;close:%d;",g_dianliu);
  839   1        if(iserror())
  840   1          {
  841   2            strcat(out,"tmp:error;"); 
  842   2          }
  843   1          else
  844   1          {
  845   2            strcat(out,"tmp:ok;");
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 14  

  846   2          }
  847   1        if(iserror())
  848   1        {
  849   2          strcat(out,"Stat:error;");
  850   2        }
  851   1        else
  852   1        {
  853   2          strcat(out,"Stat:ok;");
  854   2        }
  855   1        strcat(out,"end\n");
  856   1        printtoDianao(out);
  857   1      }
  858          void diannaoinputset()
  859          {
  860   1        int i;
  861   1        if(1==precom2check(rec2))
  862   1        {
  863   2          return ;
  864   2        }
  865   1        com2jiexi(rec2);
  866   1        if(VectorIsEmpty(VectorDiannao))
  867   1        {
  868   2          printtoDianao("oder format error,pleas check[%s]\n",rec2);
  869   2          return ;
  870   2        }
  871   1        for(i=0;i<10;i++)
  872   1        {
  873   2          dealDiannaoOrder(); //com过来的电脑命令解析。。。
  874   2        }
  875   1        ShowInfoToDiannan();
  876   1      }
  877          sbit ledgree=P3^5;
  878          sbit ledgread=P3^6;
  879          void setledisok(int i)
  880          {
  881   1        ledgree=1;
  882   1        ledgread=1;
  883   1        if(i==1)
  884   1        {
  885   2          ledgree=0;
  886   2        }
  887   1        else
  888   1        {
  889   2          ledgread=0;
  890   2        }
  891   1      }
  892          void diannaocheck()
  893          {
  894   1        int i=0;
  895   1        if(weizhi2==0)
  896   1        {
  897   2          return ;
  898   2        }
  899   1        for(i=0;i<5;i++)
  900   1        {
  901   2          delay_ms(2);
  902   2          showpre(g_dianliu);
  903   2        }
  904   1        
  905   1        diannaoinputset();
  906   1        memset(rec2, 0, sizeof(rec2));
  907   1        weizhi2 = 0;
  908   1      }
  909          // 65536 小时
  910          char flagwrie=1;
  911          void shoumingrun()
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 15  

  912          {
  913   1        static long miao=0;
  914   1        miao++;
  915   1        if(miao>60*60)
  916   1        {
  917   2          flagwrie=1;
  918   2          miao=0;
  919   2        }
  920   1      }
  921          void shoumingjilu()
  922          {
  923   1        if(flagwrie==1)
  924   1        {
  925   2          flagwrie=0;
  926   2          g_reg[indexTImeuse]++;
  927   2          EPPROMwrite();
  928   2        }
  929   1      }
  930          void main(void)
  931          {
  932   1        int i=0;
  933   1        SYS_Ini();    // STC32初始化设置
  934   1        PWM_Config(); // PWM初始化设置
  935   1        EA = 1;     // 使能EA总中断
  936   1      
  937   1        UartInit();
  938   1        Uart23Init();
  939   1        printf1("system is ok");
  940   1        Timer0Init();
  941   1        keyallchuli();
  942   1        flaginit=1;
  943   1        delay_ms(40);
  944   1        EPPROMinit();
  945   1        push(4,0);
  946   1        systemshowkaiji();
  947   1        // test3();
  948   1        // 没有什么时序时序要求，，指点函数里面做算了。。
  949   1        // 算了，之前都写成这样了。。不改了。。原有逻辑上面改改就行吧，，
  950   1        keywendu1=1;
  951   1        keywendu2=1;
  952   1        setledisok(0);
  953   1        memset(rec2,0,sizeof(rec2));
  954   1        weizhi2=0;
  955   1        while (1)
  956   1        {
  957   2          keyallchuli();
  958   2          showpre(g_dianliu);
  959   2          dealorder();//取缓冲区里面的命令进行发送
  960   2          diannaocheck();
  961   2          iserror();
  962   2          shoumingjilu();
  963   2          if(i++>10000)
  964   2          {
  965   3            i=0;
  966   3            if(flag_error==1)
  967   3            {
  968   4              setledisok(0);
  969   4              ShowInfoToDiannan();
  970   4              delay_ms(10);
  971   4              push(4,0);
  972   4              printf1("system error");
  973   4            }
  974   3            else
  975   3            {
  976   4              setledisok(1);
  977   4            }
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 16  

  978   3          }
  979   2        }
  980   1      }
  981          
  982          void PWM_ISR() interrupt 26
  983          {
  984   1        if (PWMA_SR1 & 0X02) // 当捕获中断标志置1
  985   1        {
  986   2          cnt_H = PWMA_CCR1H; // 读取计数值高8位
  987   2          cnt_L = PWMA_CCR1L; // 读取计数值低8位
  988   2          PWMA_SR1 &= ~0X02;  // 清零捕获中断标志
  989   2          EC11_Handle();    // 处理EC11数据
  990   2        }
  991   1      }
  992          void PWM_Config() // PWM初始化设置
  993          {
  994   1        PWMA_CCER1 = 0x00; // 关闭通道
  995   1        PWMA_CCMR1 = 0xA1; // 通道模式配置为输入，接编码器 , 滤波器 80 时钟
  996   1        PWMA_CCMR2 = 0xA1; // 通道模式配置为输入，接编码器 , 滤波器 80 时钟
  997   1        PWMA_CCER1 = 0x55; // 使能捕获/比较通道1、通道2
  998   1      
  999   1        //  PWMA_SMCR = 0x01;         // 编码器模式 1
 1000   1        //  PWMA_SMCR = 0x02;         // 编码器模式 2
 1001   1        PWMA_SMCR = 0x03; // 编码器模式 3
 1002   1      
 1003   1        PWMA_IER = 0x02;  // 使能中断
 1004   1        PWMA_CR1 |= 0x01; // 使能计数器
 1005   1        PWMA_PS |= 0x04;  // 选择 PWM2_2 通道
 1006   1      }
 1007          
 1008          // 返回变化的步数
 1009          long calculateChange(unsigned int previous, unsigned int current)
 1010          {
 1011   1        long diff = (current - previous + 65536) % 65536;
*** WARNING C188 IN LINE 1011 OF main.c: 'initialization': value truncated
 1012   1        return diff;
 1013   1      }
 1014          
 1015          
 1016          char flag3 = 0;
 1017          int timeleft1, timeleft2, timeleft3, timeleft4;
 1018          void chuankou1put(char c)
 1019          {
 1020   1        rec2[weizhi2++] = c;
 1021   1        if (weizhi2 > sizeof(rec2) - 3)
 1022   1          weizhi2 = 0;
 1023   1        // timeleft3 = 3;
 1024   1      }
 1025          void chuankou1time()
 1026          {
 1027   1        if (timeleft3 > 0)
 1028   1        {
 1029   2          timeleft3--;
 1030   2          if (timeleft3 == 0) // 数据一次收完了.
 1031   2          {
 1032   3            flag3 = 1;
 1033   3          }
 1034   2        }
 1035   1      }
 1036          char get1[100];
 1037          int weizhi1=0;
 1038          void chuliguankji(char *get1)
 1039          {
 1040   1          char* index;
 1041   1          index=mystrstr(get1,"@STCISP#");
 1042   1        if(index==0)
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 17  

 1043   1        {
 1044   2            return  ;
 1045   2        }
 1046   1          IAP_CONTR=0x60;
 1047   1      }
 1048          
 1049          void addgetsetzhi(int i)
 1050          {
 1051   1        g_dianliu=g_dianliu+i;
 1052   1        formatdianliu(g_dianliu);
*** WARNING C95 IN LINE 1052 OF main.c: 'formatdianliu': too many actual parameters
 1053   1      }
 1054          static int timepush=0;
 1055          void dealorder()
 1056          {
 1057   1        Alltongxininfo get;
 1058   1        if(timepush>45)
 1059   1        {
 1060   2          timepush=0;
 1061   2          pop2(&get);
 1062   2          if(get.weizhi==4)
 1063   2          {
 1064   3            // printf("dealorder %d",get.zhi);
 1065   3            dianliusendtokongzhiban(get.zhi);
 1066   3          }
 1067   2        }
 1068   1      }
 1069          void Timer0() interrupt 1
 1070          {
 1071   1        static int times=0;
 1072   1        if(times++>1000)
 1073   1        {
 1074   2          times=0;
 1075   2          shoumingrun();
 1076   2        }
 1077   1        timereport++;
 1078   1        shurulvbo();
 1079   1        chuankou1time();
 1080   1        if(!empty())
 1081   1        {
 1082   2          timepush++;
 1083   2        }
 1084   1      }
 1085          void EC11_Handle() // EC11数据处理函数
 1086          {
 1087   1        static unsigned int previous = 0;
 1088   1        unsigned int nowzhi;
 1089   1        long ans;
 1090   1        nowzhi = cnt_H * 256 + cnt_L; // 读取当前计数值
 1091   1        ans = calculateChange(previous, nowzhi);
 1092   1        previous = nowzhi;
 1093   1        if(flagsetliangdu==1)
 1094   1        {
 1095   2          if (ans == 4)
 1096   2          {
 1097   3            addgetsetzhi(1);
 1098   3          }
 1099   2          else
 1100   2          {
 1101   3            addgetsetzhi(-1);
 1102   3          }
 1103   2          // 设定电流值。。。
 1104   2          setzhione(4,g_dianliu);
 1105   2          // setzhione(2,1);//开灯。。
 1106   2        }
 1107   1        
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 18  

 1108   1      }
 1109          
 1110          int step=0;
 1111          void showstep(const char *s)
 1112          {
 1113   1        printf1("%s\n",s);
 1114   1      }
 1115          char* my_strstr(const char* haystack, const char* needle) {
 1116   1          if (*needle == '\0') {
 1117   2              return (char*) haystack;
 1118   2          }
 1119   1      
 1120   1          while (*haystack != '\0') {
 1121   2              const char* h = haystack;
 1122   2              const char* n = needle;
 1123   2      
 1124   2              while (*h == *n && *n != '\0') {
 1125   3                  h++;
 1126   3                  n++;
 1127   3              }
 1128   2      
 1129   2              if (*n == '\0') {
 1130   3                  return (char*) haystack;
 1131   3              }
 1132   2      
 1133   2              haystack++;
 1134   2          }
 1135   1      
 1136   1          return NULL;
 1137   1      }
 1138          
 1139          void dealchuankou()
 1140          {
 1141   1      
 1142   1      }
 1143          
 1144          void UARTInterrupt(void) interrupt 4
 1145          {
 1146   1        char ans;
 1147   1        if (RI)
 1148   1        {
 1149   2          RI = 0;
 1150   2          ans = SBUF;
 1151   2          get1[weizhi1++]=ans;
 1152   2          if(weizhi1>80)
 1153   2          {
 1154   3            weizhi1=0;
 1155   3          }
 1156   2          // chuliguankji(get1);
 1157   2          chuankou1put(ans);
 1158   2        }
 1159   1        else
 1160   1        {
 1161   2          TI = 0;
 1162   2        }
 1163   1        if (TI) // 发送中断..
 1164   1        {
 1165   2          TI = 0;
 1166   2        }
 1167   1      }
 1168          void Uart3() interrupt 17 using 1
 1169          {
 1170   1        char temp3; 
 1171   1          if (S3CON & S3RI)
 1172   1          {
 1173   2              S3CON &= ~S3RI; //??S3RI?
C251 COMPILER V5.60.0,  main                                                               07/08/23  21:27:44  PAGE 19  

 1174   2          temp3 = S3BUF;
 1175   2          }
 1176   1          if (S3CON & S3TI)
 1177   1          {
 1178   2              S3CON &= ~S3TI; // 清除S3TI位
 1179   2              busy3 = 0;      // 清忙标志
 1180   2          }
 1181   1      }
 1182          void uart2(void) interrupt 8
 1183          {
 1184   1        char ans;
 1185   1        if (S2CON & S2RI)
 1186   1        {
 1187   2          S2CON &= ~S2RI;
 1188   2          ans = S2BUF;
 1189   2          // chuankou1put(ans);
 1190   2        }
 1191   1        if (S2CON & S2TI)
 1192   1        {
 1193   2          // y1=0;
 1194   2          S2CON &= ~S2TI; // 清除S2TI位
 1195   2          busy2 = 0;    // 清忙标志
 1196   2        }
 1197   1      }
 1198          
 1199          // 写个函数，传入两个非负数，计算是前进还是后退了，变化规律 15,16,0,1,2...15,16


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      4803     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       569       2537
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      3312     ------
End of Module Information.


C251 COMPILATION COMPLETE.  6 WARNING(S),  0 ERROR(S)
