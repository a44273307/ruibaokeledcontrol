C51 COMPILER V9.05   LEDCONTROL                                                            06/04/2023 10:46:46 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE LEDCONTROL
OBJECT MODULE PLACED IN ledcontrol.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ledcontrol.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "stc15f2k60s2.h"           // 单片机STC15F2K60S2头文件,可以不再加入reg51.h
   2          #include <intrins.h>                                    // 加入此头文件后,可使用_nop_库函数
   3          #include "delay.h"                      // 延时函数头文件
   4          #include "uart.h"                               // 串行通信函数头文件
   5          #define  uint unsigned int  
   6          #define  uchar unsigned char    
   7          #include <stdio.h>
   8          #include <string.h>
   9          #include "MODBUS.h"
  10          
  11          #include <stdio.h>
  12          #include <string.h>
  13          #include <stdlib.h>
  14          
  15          bit busy;
  16          void Start()
  17          {uint i=0;
  18   1          busy = 1;
  19   1          I2CMSCR = 0x81;                             //发送START命令
  20   1          while (busy && i < 6000)i++;
  21   1      }
  22          
  23          void SendData(char dat)
  24          {uint i=0;
  25   1          I2CTXD = dat;                               //写数据到数据缓冲区
  26   1          busy = 1;
  27   1          I2CMSCR = 0x82;                             //发送SEND命令
  28   1          while (busy && i < 6000)i++;
  29   1      }
  30          
  31          void RecvACK()
  32          {uint i=0;
  33   1          busy = 1;
  34   1          I2CMSCR = 0x83;                             //发送读ACK命令
  35   1          while (busy && i < 6000)i++;
  36   1      }
  37          
  38          char RecvData()
  39          {uint i=0;
  40   1          busy = 1;
  41   1          I2CMSCR = 0x84;                             //发送RECV命令
  42   1          while (busy && i < 6000)i++;
  43   1          return I2CRXD;
  44   1      }
  45          
  46          void SendACK()
  47          {uint i=0;
  48   1          I2CMSST = 0x00;                             //设置ACK信号
  49   1          busy = 1;
  50   1          I2CMSCR = 0x85;                             //发送ACK命令
  51   1          while (busy && i < 6000)i++;
  52   1      }
  53          
  54          void SendNAK()
  55          {uint i=0;
C51 COMPILER V9.05   LEDCONTROL                                                            06/04/2023 10:46:46 PAGE 2   

  56   1          I2CMSST = 0x01;                             //设置NAK信号
  57   1          busy = 1;
  58   1          I2CMSCR = 0x85;                             //发送ACK命令
  59   1          while (busy && i < 6000)i++;
  60   1      }
  61          
  62          void Stop()
  63          {uint i=0;
  64   1          busy = 1;
  65   1          I2CMSCR = 0x86;                             //发送STOP命令
  66   1          while (busy && i < 6000)i++;
  67   1      }
  68          void I2C_Isr() interrupt 24
  69          {
  70   1          _push_(P_SW2);
  71   1          P_SW2 |= 0x80;
  72   1          if (I2CMSST & 0x40)
  73   1          {
  74   2              I2CMSST &= ~0x40;                       //清中断标志
  75   2              busy = 0;
  76   2          }
  77   1          _pop_(P_SW2);
  78   1      }
  79          
  80          void deanyanpre()
  81           {  
  82   1        uint sw1=2047;
  83   1        uint sw2=3000;
  84   1        sw1=HoldingReg[3];
  85   1        sw2=HoldingReg[4];
  86   1        printf("***%d-%d***\n",sw2/256,sw2%256);
  87   1        Start();        // 发送起始命令
  88   1        SendData(0xc2); // 发送设备地址+写命令
  89   1        RecvACK();
  90   1        SendData(0x60); // 发送存储地址高字节
  91   1        RecvACK();
  92   1        SendData(sw1 / 16); // 发送存储地址低字节
  93   1        RecvACK();
  94   1        SendData((sw1 % 16) << 4); // 写测试数据1
  95   1        RecvACK();
  96   1        Stop(); // 发送停止命令
  97   1      
  98   1        Start();        // 发送起始命令
  99   1        SendData(0xc0); // 发送设备地址+写命令
 100   1        RecvACK();
 101   1        SendData(0x60); // 发送存储地址高字节
 102   1        RecvACK();
 103   1        SendData(sw2 / 16); // 发送存储地址低字节
 104   1        RecvACK();
 105   1        SendData((sw2 % 16) << 4); // 写测试数据1
 106   1        RecvACK();
 107   1        Stop();
 108   1      
 109   1        Start();        // 发送起始命令
 110   1        SendData(0xc2); // 发送设备地址+写命令
 111   1        RecvACK();
 112   1        SendData(0x60); // 发送存储地址高字节
 113   1        RecvACK();
 114   1        SendData(sw1 / 16); // 发送存储地址低字节
 115   1        RecvACK();
 116   1        SendData((sw1 % 16) << 4); // 写测试数据1
 117   1        RecvACK();
C51 COMPILER V9.05   LEDCONTROL                                                            06/04/2023 10:46:46 PAGE 3   

 118   1        Stop(); // 发送停止命令
 119   1      
 120   1        Start();        // 发送起始命令
 121   1        SendData(0xc0); // 发送设备地址+写命令
 122   1        RecvACK();
 123   1        SendData(0x60); // 发送存储地址高字节
 124   1        RecvACK();
 125   1        SendData(sw2 / 16); // 发送存储地址低字节
 126   1        RecvACK();
 127   1        SendData((sw2 % 16) << 4); // 写测试数据1
 128   1        RecvACK();
 129   1        Stop();
 130   1                        
 131   1       }
 132           
 133          sbit led1 = P3 ^ 7;
 134          sbit led2 = P3 ^ 6;
 135           void deanyan()
 136           {
 137   1            led1 = 0;
 138   1            led2 = 1;
 139   1            deanyanpre();
 140   1      
 141   1            led1 = 1;
 142   1            led2 = 0;
 143   1       }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    496    ----
   CONSTANT SIZE    =     13    ----
   XDATA SIZE       =   ----       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
