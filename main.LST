C51 COMPILER V9.05   MAIN                                                                  06/03/2023 22:13:12 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /************************************************************************************
   2             
   3          程序名称： （晶振频率18.432MHz） 
   4          功能说明: 通过串口3发送“Everything is possible!”  
   5                    波特率9600，数据位8，奇偶效验无，停止位1，数据流控制无  
   6          ************************************************************************************/
   7          #include "stc15f2k60s2.h"           // 单片机STC15F2K60S2头文件,可以不再加入reg51.h
   8          #include <intrins.h>                                    // 加入此头文件后,可使用_nop_库函数
   9          #include "delay.h"                      // 延时函数头文件
  10          #include "uart.h"                               // 串行通信函数头文件
  11          #define  uint unsigned int  
  12          #define  uchar unsigned char    
  13          #include <stdio.h>
  14          #include <string.h>
  15          #include "MODBUS.h"
  16          
  17          #include <stdio.h>
  18          #include <string.h>
  19          #include <stdlib.h>
  20          
  21          bit busy;
  22          
  23          uint weishu1,weishu2,weishu3,weishu4;
  24          
  25          uint temp1,temp2,temp3,temp4;
  26          
  27          
  28          
  29          
  30          //sbit x0 = P4^3;
  31          //sbit x1 = P4^4; 
  32          //sbit x2 = P2^0; 
  33          //sbit x3 = P2^1;  
  34          //sbit x4 = P2^2;  
  35          //sbit x5 = P2^3;
  36          //sbit x6 = P2^4; 
  37          //sbit x7 = P2^5;
  38          //sbit x10 = P2^6;
  39          //sbit x11 = P2^7; 
  40          //sbit x12 = P4^5;
  41          //sbit x13 = P4^6;
  42          
  43          sbit x0 = P2^4; 
  44          sbit x1 = P2^5; 
  45          
  46          
  47          sbit x2 = P2^6;  
  48          sbit x3 = P2^7;
  49          
  50          sbit x4 = P4^5; 
  51          sbit x5 = P4^6;
  52          
  53          sbit x6 = P0^2;
  54          sbit x7 = P0^3; 
  55          
C51 COMPILER V9.05   MAIN                                                                  06/03/2023 22:13:12 PAGE 2   

  56          sbit x8 = P0^4; 
  57          sbit x9 = P5^2;
  58          
  59          
  60          
  61          
  62          sbit y0 = P2^3;  
  63          sbit y1 = P2^2; 
  64          sbit y2 = P2^1;
  65          sbit y3 = P2^0;
  66          sbit y4 = P4^4;
  67          sbit y5 = P4^3;
  68          
  69          
  70          
  71          void printf2(char *puts)
  72          {
  73   1               while(*puts) 
  74   1              {
  75   2                      sendbyte2(*puts);
  76   2                      puts++;
  77   2              }
  78   1      }
  79          
  80          void io_inint()
  81          {
  82   1              P0M1 = 0;       P0M0 = 0;       //设置P0.0~P0.7为准双向口
  83   1                  // P1M0 = 0x00;                                //设置P1.0为ADC口
  84   1          // P1M1 = 0x80;
  85   1      
  86   1      
  87   1              // P1M1 = 0;    P1M0 = 0;       //设置P1.0~P1.7为准双向口
  88   1              P2M1 = 0;       P2M0 = 0;       //设置P2.0~P2.7为准双向口 
  89   1                  P3M0 = 0;
  90   1          P3M1 = 0;
  91   1              P4M1 = 0;       P4M0 = 0;       //设置P4.0~P4.7为准双向口
  92   1              P5M1 = 0;       P5M0 = 0;       //设置P5.0~P5.7为准双向口
  93   1      }
  94          
  95          
  96          
  97          
  98          int xinget(int zhi)
  99          {
 100   1              if(zhi==0) return x0;
 101   1              if(zhi==1) return x1;
 102   1              if(zhi==2) return x2;
 103   1              if(zhi==3) return x3;
 104   1              if(zhi==4) return x4;
 105   1              if(zhi==5) return x5;
 106   1              if(zhi==6) return x6;
 107   1              if(zhi==7) return x7;
 108   1              if(zhi==8) return x8;
 109   1              if(zhi==9) return x9;
 110   1      }
 111          void getxin()
 112          {
 113   1              int i;
 114   1              char datatmp[10];
 115   1              for(i=0;i<10;i++)
 116   1              {
 117   2                      sprintf(datatmp,"x%d %d\n",i,xinget(i));
C51 COMPILER V9.05   MAIN                                                                  06/03/2023 22:13:12 PAGE 3   

 118   2                      PrintString(datatmp);
 119   2              }
 120   1      }
 121          void Delay1ms()         //@24.000MHz
 122          {
 123   1              unsigned char i, j;
 124   1      
 125   1              i = 24;
 126   1              j = 85;
 127   1              do
 128   1              {
 129   2                      while (--j);
 130   2              } while (--i);
 131   1      }
 132          
 133          void delay_ms(int m)
 134          {
 135   1              int x;
 136   1              for(x=m;x>0;x--)
 137   1              {
 138   2                      Delay1ms();
 139   2              }
 140   1              
 141   1      }
 142          void Start()
 143          {uint i=0;
 144   1          busy = 1;
 145   1          I2CMSCR = 0x81;                             //发送START命令
 146   1          while (busy)i++;
 147   1      }
 148          
 149          void SendData(char dat)
 150          {uint i=0;
 151   1          I2CTXD = dat;                               //写数据到数据缓冲区
 152   1          busy = 1;
 153   1          I2CMSCR = 0x82;                             //发送SEND命令
 154   1          while (busy)i++;
 155   1      }
 156          
 157          void RecvACK()
 158          {uint i=0;
 159   1          busy = 1;
 160   1          I2CMSCR = 0x83;                             //发送读ACK命令
 161   1          while (busy)i++;
 162   1      }
 163          
 164          char RecvData()
 165          {uint i=0;
 166   1          busy = 1;
 167   1          I2CMSCR = 0x84;                             //发送RECV命令
 168   1          while (busy)i++;
 169   1          return I2CRXD;
 170   1      }
 171          
 172          void SendACK()
 173          {uint i=0;
 174   1          I2CMSST = 0x00;                             //设置ACK信号
 175   1          busy = 1;
 176   1          I2CMSCR = 0x85;                             //发送ACK命令
 177   1          while (busy)i++;
 178   1      }
 179          
C51 COMPILER V9.05   MAIN                                                                  06/03/2023 22:13:12 PAGE 4   

 180          void SendNAK()
 181          {uint i=0;
 182   1          I2CMSST = 0x01;                             //设置NAK信号
 183   1          busy = 1;
 184   1          I2CMSCR = 0x85;                             //发送ACK命令
 185   1          while (busy)i++;
 186   1      }
 187          
 188          void Stop()
 189          {uint i=0;
 190   1          busy = 1;
 191   1          I2CMSCR = 0x86;                             //发送STOP命令
 192   1          while (busy)i++;
 193   1      }
 194          void I2C_Isr() interrupt 24
 195          {
 196   1          _push_(P_SW2);
 197   1          P_SW2 |= 0x80;
 198   1          if (I2CMSST & 0x40)
 199   1          {
 200   2              I2CMSST &= ~0x40;                       //清中断标志
 201   2              busy = 0;
 202   2          }
 203   1          _pop_(P_SW2);
 204   1      }
 205          sbit out1=P1^6;  //
 206          sbit out2=P3^2;
 207          
 208          sbit led1 = P3 ^ 7;
 209          sbit led2 = P3 ^ 6;
 210          
 211          
 212          void deanyan()
 213           {  
 214   1              uint sw1=2000;
 215   1              uint sw2=3000;
 216   1              Start();        // 发送起始命令
 217   1        SendData(0xc2); // 发送设备地址+写命令
 218   1        RecvACK();
 219   1        SendData(0x60); // 发送存储地址高字节
 220   1        RecvACK();
 221   1        SendData(sw1 / 16); // 发送存储地址低字节
 222   1        RecvACK();
 223   1        SendData((sw1 % 16) << 4); // 写测试数据1
 224   1        RecvACK();
 225   1        Stop(); // 发送停止命令
 226   1      
 227   1        Start();        // 发送起始命令
 228   1        SendData(0xc0); // 发送设备地址+写命令
 229   1        RecvACK();
 230   1        SendData(0x60); // 发送存储地址高字节
 231   1        RecvACK();
 232   1        SendData(sw2 / 16); // 发送存储地址低字节
 233   1        RecvACK();
 234   1        SendData((sw2 % 16) << 4); // 写测试数据1
 235   1        RecvACK();
 236   1        Stop();
 237   1      
 238   1        Start();        // 发送起始命令
 239   1        SendData(0xc2); // 发送设备地址+写命令
 240   1        RecvACK();
 241   1        SendData(0x60); // 发送存储地址高字节
C51 COMPILER V9.05   MAIN                                                                  06/03/2023 22:13:12 PAGE 5   

 242   1        RecvACK();
 243   1        SendData(sw1 / 16); // 发送存储地址低字节
 244   1        RecvACK();
 245   1        SendData((sw1 % 16) << 4); // 写测试数据1
 246   1        RecvACK();
 247   1        Stop(); // 发送停止命令
 248   1      
 249   1        Start();        // 发送起始命令
 250   1        SendData(0xc0); // 发送设备地址+写命令
 251   1        RecvACK();
 252   1        SendData(0x60); // 发送存储地址高字节
 253   1        RecvACK();
 254   1        SendData(sw2 / 16); // 发送存储地址低字节
 255   1        RecvACK();
 256   1        SendData((sw2 % 16) << 4); // 写测试数据1
 257   1        RecvACK();
 258   1        Stop();
 259   1              
 260   1                        
 261   1       }
 262          void main()                                                    
 263          {
 264   1              
 265   1              io_inint();
 266   1              Uart23Init();
 267   1              
 268   1              
 269   1              Timer0Init();
 270   1              UartInit();
 271   1              
 272   1              Uart4Init();
 273   1              PrintString("system is ok\n");
 274   1              P_SW2 = 0x80;
 275   1          I2CCFG = 0xe0;                              //使能I2C主机模式
 276   1          I2CMSST = 0x00;
 277   1               EA = 1;
 278   1              out2=1;
 279   1              out1 = 1;
 280   1              delay_ms(10);
 281   1              Modbus_ClearBuff();
 282   1      
 283   1              while (1)
 284   1              {
 285   2                      delay_ms(200);
 286   2                          //  en=1;
 287   2            led1 = 0;
 288   2            led2 = 1;
 289   2            deanyan();
 290   2      
 291   2            led1 = 1;
 292   2            led2 = 0;
 293   2      
 294   2                      PrintString("xxx is ok\n");
 295   2              }
 296   1      
 297   1              while (1)
 298   1              {
 299   2                      delay_ms(2);
 300   2                      // printf("0000000000");
 301   2                      if(recover==1)
 302   2                      {
 303   3                              // deanyan();
C51 COMPILER V9.05   MAIN                                                                  06/03/2023 22:13:12 PAGE 6   

 304   3                              jishouokjisuan();
 305   3                              recover=0;
 306   3                      }
 307   2              }
 308   1      }
 309                   
 310                   
 311          
 312                   
 313                   
 314          uint time,lv_bo;
 315          void Timer0() interrupt 1
 316          {
 317   1              time1msjisuan();
 318   1      }
 319          void UARTInterrupt(void) interrupt 4
 320          {
 321   1              unsigned char ans;
 322   1              if (RI)
 323   1              {
 324   2                      RI = 0;
 325   2                      ans=SBUF;
 326   2                      chuankou1jisuuan(ans);
 327   2              }
 328   1              else
 329   1              {
 330   2                      TI = 0;
 331   2              }
 332   1              if (TI) //发送中断..
 333   1              {
 334   2                      TI = 0;
 335   2              }
 336   1      }
 337          
 338          void uart2(void ) interrupt 8 
 339          {
 340   1        if (S2CON & S2RI)
 341   1              {
 342   2                      S2CON &= ~S2RI;         
 343   2                      temp2 = S2BUF;
 344   2              }
 345   1        if (S2CON & S2TI)
 346   1          {
 347   2                              //y1=0;
 348   2              S2CON &= ~S2TI;         //清除S2TI位
 349   2              busy2 = 0;               //清忙标志
 350   2          }  
 351   1      }
 352          
 353            
 354          
 355          
 356          void Uart3() interrupt 17 using 1
 357          {
 358   1          if (S3CON & S3RI)
 359   1          {
 360   2              S3CON &= ~S3RI;         //??S3RI?
 361   2              temp3 = S3BUF;
 362   2                                      
 363   2         }
 364   1      if (S3CON & S3TI)
 365   1          {
C51 COMPILER V9.05   MAIN                                                                  06/03/2023 22:13:12 PAGE 7   

 366   2              S3CON &= ~S3TI;         //清除S3TI位
 367   2              busy3 = 0;               //清忙标志
 368   2          }
 369   1      }
 370          
 371          void Uart4() interrupt 18 
 372          {
 373   1          if (S4CON & S4RI)
 374   1          {
 375   2              S4CON &= ~S4RI;         //??S4RI?
 376   2              temp4=S4BUF;
 377   2         }
 378   1      if(TI4)
 379   1              {
 380   2                      CLR_TI4();
 381   2                      busy4 = 0;               //清忙标志
 382   2              }
 383   1      }
 384          
 385          
 386          
*** WARNING C291 IN LINE 110 OF main.c: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1023    ----
   CONSTANT SIZE    =     33    ----
   XDATA SIZE       =     20      17
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
