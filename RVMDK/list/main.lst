C251 COMPILER V5.60.0,  main                                                               23/09/23  13:11:16  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\list\main.obj
COMPILER INVOKED BY: D:\keilc251\C251\BIN\C251.EXE ..\User\main.c LARGE INTR2 ROM(HUGE) BROWSE INCDIR(..\Driver\inc;..\U
                    -ser;..\App\inc) DEBUG PRINT(.\list\main.lst) TABS(2) OBJECT(.\list\main.obj) 

stmt  level    source

    1          /*---------------------------------------------------------------------*/
    2          /* --- STC MCU Limited ------------------------------------------------*/
    3          /* --- STC 1T Series MCU Demo Programme -------------------------------*/
    4          /* --- Mobile: (86)13922805190 ----------------------------------------*/
    5          /* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
    6          /* --- Tel: 86-0513-55012928,55012929,55012966 ------------------------*/
    7          /* --- Web: www.STCMCU.com --------------------------------------------*/
    8          /* --- Web: www.STCMCUDATA.com  ---------------------------------------*/
    9          /* --- QQ:  800003751 -------------------------------------------------*/
   10          /* 如果要在程序中使用此代码,请在程序中注明使用了STC的资料及程序            */
   11          /*---------------------------------------------------------------------*/
   12          #include <string.h>
   13          #include "stc32g.h"
   14          #include "config.h"
*** WARNING C317 IN LINE 39 OF ..\User\type_def.h: attempt to redefine macro 'NULL'
   15          
   16          
   17          #include <stdio.h>
   18          #include <stdarg.h>
   19          #include <stdio.h>
   20          
   21          #include <stdlib.h>
   22          #include  "Task.h"
   23          #include  "System_init.h"
   24          #include  "APP.h"
*** WARNING C317 IN LINE 89 OF \瑞宝科\new2\lcd显示屏_33.1776\App\inc\APP_Lamp.h: attempt to redefine macro 'WHITE'
*** WARNING C317 IN LINE 91 OF \瑞宝科\new2\lcd显示屏_33.1776\App\inc\APP_Lamp.h: attempt to redefine macro 'BLUE'
*** WARNING C317 IN LINE 95 OF \瑞宝科\new2\lcd显示屏_33.1776\App\inc\APP_Lamp.h: attempt to redefine macro 'RED'
*** WARNING C317 IN LINE 97 OF \瑞宝科\new2\lcd显示屏_33.1776\App\inc\APP_Lamp.h: attempt to redefine macro 'GREEN'
   25          
   26          #include  "config.h"
   27          #include  "STC32G_GPIO.h"
   28          #include  "STC32G_UART.h"
   29          #include  "STC32G_NVIC.h"
   30          #include  "STC32G_Delay.h"
   31          #include  "STC32G_Switch.h"
   32          #include "uart.h"
*** WARNING C317 IN LINE 17 OF ..\User\uart.h: attempt to redefine macro 'CLR_TI4'
*** WARNING C317 IN LINE 18 OF ..\User\uart.h: attempt to redefine macro 'CLR_RI4'
*** WARNING C317 IN LINE 24 OF ..\User\uart.h: attempt to redefine macro 'MAIN_Fosc'
   33          #include "tongxin2.h"
   34          #include "tongxin.h"
   35          #include "STC32G_EEPROM.h"
   36          
   37          void showhenxiang();
   38          void ledopen(int weizhi);
   39          void pingmuclear2();
   40          int keyon = 0;
   41          int keylow = 1;
   42          int keyok = 2;
   43          int keyup = 3;
   44          
   45          int nowzhi = 0;
   46          int g_dianliu = 0;
   47          
   48          #define modekey 0
   49          #define mode232 1
   50          #define modeTCP 2
C251 COMPILER V5.60.0,  main                                                               23/09/23  13:11:16  PAGE 2   

   51          int g_setmode = modekey;
   52          
   53          sbit X0 = P4 ^ 0;
   54          sbit X3 = P3 ^ 4;
   55          sbit X2 = P3 ^ 6;
   56          sbit X1 = P4 ^ 1;
   57          
   58          sbit LED1 = P4 ^ 2;
   59          sbit LED2 = P3 ^ 7;
   60          
   61          sbit LED3 = P3 ^ 5;
   62          sbit LED0 = P3 ^ 3;
   63          
   64          
   65          sbit Y1 =  P4 ^ 2;
   66          sbit Y2 =  P3 ^ 7;
   67          
   68          sbit Y3 =  P3 ^ 5;
   69          sbit Y0 =  P3 ^ 3;
   70          
   71          
   72          
   73          char flagsystemrun = 0;
   74          #define maxsetzhi 1023
   75          
   76          
   77          void  GPIO_confibase(void)
   78          {
   79   1      //  P2_MODE_IO_PU( GPIO_Pin_3 | GPIO_Pin_4 );   //P2 设置为准双向口
   80   1      //  P2_MODE_OUT_PP(GPIO_Pin_2|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7);
   81   1          P2_MODE_IO_PU(GPIO_Pin_All);  
   82   1        
   83   1        P3_MODE_OUT_PP(GPIO_Pin_3|GPIO_Pin_5|GPIO_Pin_7);
   84   1        P3_MODE_IN_HIZ(GPIO_Pin_4|GPIO_Pin_6);
   85   1        
   86   1        P4_MODE_OUT_PP(GPIO_Pin_2|GPIO_Pin_3);
   87   1        P4_MODE_IN_HIZ(GPIO_Pin_0|GPIO_Pin_1);
   88   1      }
   89          
   90          void  GPIO_configcom3(void)
   91          {
   92   1        GPIO_InitTypeDef  GPIO_InitStructure;   //结构定义
   93   1      
   94   1        GPIO_InitStructure.Pin  = GPIO_Pin_0 | GPIO_Pin_1;    //指定要初始化的IO, GPIO_Pin_0 ~ GPIO_Pin_7
   95   1        GPIO_InitStructure.Mode = GPIO_PullUp;  //指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_
             -OUT_PP
   96   1        GPIO_Inilize(GPIO_P5,&GPIO_InitStructure);  //初始化
   97   1      }
   98          
   99          /***************  串口初始化函数 *****************/
  100          void  UART_configcom3(void)
  101          {
  102   1        COMx_InitDefine   COMx_InitStructure;         //结构定义
  103   1      
  104   1        COMx_InitStructure.UART_Mode      = UART_8bit_BRTx; //模式, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UAR
             -T_9bit_BRTx
  105   1        COMx_InitStructure.UART_BRT_Use   = BRT_Timer3;     //选择波特率发生器, BRT_Timer3, BRT_Timer2 (注意: 串口
             -2固定使用BRT_Timer2)
  106   1        COMx_InitStructure.UART_BaudRate  = 115200ul;     //波特率, 一般 110 ~ 115200
  107   1        COMx_InitStructure.UART_RxEnable  = ENABLE;       //接收允许,   ENABLE或DISABLE
  108   1        UART_Configuration(UART3, &COMx_InitStructure);   //初始化串口1 UART1,UART2,UART3,UART4
  109   1        NVIC_UART3_Init(ENABLE,Priority_1);   //中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Pr
             -iority_2,Priority_3
  110   1      
  111   1        UART3_SW(UART3_SW_P50_P51);   //UART3_SW_P00_P01,UART3_SW_P50_P51
  112   1      }
C251 COMPILER V5.60.0,  main                                                               23/09/23  13:11:16  PAGE 3   

  113          
  114          
  115          static int timepush=0;
  116          void dealorder()
  117          {
  118   1        char out[30]={0};
  119   1        Alltongxininfo get;
  120   1        if(timepush>45)
  121   1        {
  122   2          timepush=0;
  123   2          pop2(&get);
  124   2          if(get.weizhi==4)
  125   2          {
  126   3            get.zhi=get.zhi;
*** WARNING C138 IN LINE 126 OF ..\User\main.c: expression with possibly no effect
  127   3          }
  128   2          sprintf(out,"set:%d-%d;end",get.weizhi,get.zhi);
  129   2          print3(out);
  130   2        }
  131   1      }
  132          char flagError=0;
  133          int timeflagError=0;
  134          int timetongxin=0;
  135          void time0() interrupt 1
  136          {
  137   1        if(flagsystemrun==1)
  138   1          timetongxin++;
  139   1        if(flagError==1)
  140   1        {
  141   2          if(timeflagError++>500)
  142   2          {
  143   3            timeflagError=0;
  144   3            LED0 = ~LED0;
  145   3          }
  146   2          
  147   2        }
  148   1            
  149   1        if(!empty())
*** WARNING C140 IN LINE 149 OF ..\User\main.c: 'empty' undefined; assuming 'extern int empty()'
  150   1        {
  151   2          timepush++;
  152   2        }
  153   1        chuankou1time();
  154   1      }
  155          
  156          void Uart3() interrupt 17
  157          {
  158   1        char temp3; 
  159   1          if (S3CON & S3RI)
  160   1          {
  161   2              S3CON &= ~S3RI; //??S3RI?
  162   2          temp3 = S3BUF;
  163   2          chuankou1put(temp3);
  164   2          }
  165   1          if (S3CON & S3TI)
  166   1          {
  167   2              S3CON &= ~S3TI; // 清除S3TI位
  168   2              busy3 = 0;      // 清忙标志
  169   2          }
  170   1      }
  171          
  172          char flag_show = 0;
  173          // 是否能够设置值的状态。。。  ok键按下 即可。。。
  174          char flagKeyCanSet = 0;
  175          void setdianliu(int zhi)
  176          {
C251 COMPILER V5.60.0,  main                                                               23/09/23  13:11:16  PAGE 4   

  177   1        push(4,zhi);
  178   1      }
  179          
  180          
  181          
  182          void keySetDianliu(int a)
  183          {
  184   1        if (flagKeyCanSet == 0)
  185   1          return;
  186   1        if (g_dianliu + a < 0)
  187   1        {
  188   2          g_dianliu = 0;
  189   2          // 0的情况也发，保证能够被收到。。
  190   2          flag_show = 1;
  191   2          setdianliu(g_dianliu);
  192   2          // printf("setdianliu%d\r\n",g_dianliu);
  193   2          return;
  194   2        }
  195   1        if (g_dianliu + a > maxsetzhi)
  196   1        {
  197   2          g_dianliu = maxsetzhi;
  198   2          return;
  199   2        }
  200   1        g_dianliu = g_dianliu + a;
  201   1        flag_show = 1;
  202   1        setdianliu(g_dianliu);
  203   1      }
  204          int writedizhi(int dizhi, int zhi)
  205          {
  206   1        push(dizhi,zhi);
  207   1      }
  208          void writebuf();
  209          #define showmodeset 1
  210          #define showkeyset 0
  211          // 初始的按键设置状态。。。
  212          int g_showset=showkeyset;
  213          // 用来显示游标处理的。。。就是mode设置的界面
  214          int g_showyoubiao=0;
  215          void g_showyoubiao_set(int zhi)
  216          {
  217   1        int i;
  218   1        if(g_showyoubiao<0 && zhi>0)
  219   1        {
  220   2          g_showyoubiao=0;  
  221   2        }
  222   1        g_showyoubiao+=zhi;
  223   1        if(g_showyoubiao<=0)
  224   1        g_showyoubiao=0;
  225   1        if(g_showyoubiao>=3)
  226   1        g_showyoubiao=3;
  227   1        printf("g_showyoubiao-%d",g_showyoubiao);
  228   1        for(i=0;i<4;i++)
  229   1        LCD_ShowString(160, i*40,"      ", WHITE, BLACK, 32, 0);
  230   1      
  231   1        LCD_ShowString(160, g_showyoubiao*40,"<---  ", WHITE, BLACK, 32, 0);
  232   1      }
  233          
  234          void keylowdeal()
  235          {
  236   1        if(g_showset==showmodeset)
  237   1        {
  238   2          g_showyoubiao_set(-1);
  239   2        }
  240   1        else
  241   1        {
  242   2          keySetDianliu(-1);
C251 COMPILER V5.60.0,  main                                                               23/09/23  13:11:16  PAGE 5   

  243   2        }
  244   1        
  245   1      }
  246          void keyupdeal()
  247          {
  248   1        if(g_showset==showmodeset)
  249   1        {
  250   2          g_showyoubiao_set(1);
  251   2        }
  252   1        else
  253   1        {
  254   2          keySetDianliu(1);
  255   2        }
  256   1        
  257   1      }
  258          void modeshowandsend();
  259          void showbak();
  260          void keyokdeal()
  261          {
  262   1        // mode 界面设置，232等。。。
  263   1        if(g_showset==showmodeset)
  264   1        {
  265   2          // 这里设置了值。。。
  266   2          if(g_showyoubiao<=2)
  267   2          {
  268   3            g_setmode=g_showyoubiao;
  269   3            writebuf();
  270   3          }
  271   2          if(g_showyoubiao>=0)
  272   2          {
  273   3            showbak();
  274   3            modeshowandsend();
  275   3            g_showset=showkeyset;
  276   3          }
  277   2        }
  278   1        else
  279   1        {
  280   2          if(g_setmode!=modekey)
  281   2          {
  282   3            return;
  283   3          }
  284   2          if(flagKeyCanSet==1)
  285   2          {
  286   3            writebuf();
  287   3          }
  288   2          flagKeyCanSet = 1 - flagKeyCanSet;
  289   2          // LED2 = ~LED2;
  290   2        }
  291   1      
  292   1      }
  293          void flagKeyDeal()
  294          {
  295   1        if(g_setmode!=modekey)
  296   1        {
  297   2          flagKeyCanSet=0;
  298   2        }
  299   1        if(flagKeyCanSet==1)
  300   1        {
  301   2          LED2=0;
  302   2        }
  303   1        else
  304   1        {
  305   2          LED2=1;
  306   2        }
  307   1      
  308   1      }
C251 COMPILER V5.60.0,  main                                                               23/09/23  13:11:16  PAGE 6   

  309          
  310          void keydown(int i) // 按键按下的处理、、、
  311          {
  312   1        printf("key down%d",i);
  313   1        if (i == keyon)
  314   1        {
  315   2          LED0 = ~LED0;
  316   2          // 结束时候关灯， 开机键盘开灯。。。
  317   2          if (flagsystemrun == 0)
  318   2          {
  319   3            flagsystemrun = 1;
  320   3            LCD_ShowString(0, 0, "Circle TAC", WHITE, BLACK, 32, 0);
  321   3            
  322   3            showhenxiang();
  323   3            writedizhi(2,1);
  324   3            delay_ms(30);
  325   3            writedizhi(2,1);
  326   3            delay_ms(30);
  327   3            setdianliu(g_dianliu);
  328   3            delay_ms(10);
  329   3          }
  330   2          else
  331   2          {
  332   3            writedizhi(2,0);
  333   3            delay_ms(100);
  334   3            dealorder();
  335   3            writedizhi(2,0);
  336   3            delay_ms(300);
  337   3            dealorder();
  338   3            IAP_CONTR = 0x60;
  339   3          }
  340   2        }
  341   1        if (flagKeyCanSet)
  342   1        {
  343   2          ledopen(i);
  344   2        }
  345   1        if (i == keylow)
  346   1        {
  347   2          keylowdeal();
  348   2          return;
  349   2        }
  350   1        if (i == keyup)
  351   1        {
  352   2          keyupdeal();
  353   2          return;
  354   2        }
  355   1        if (i == keyok)
  356   1        {
  357   2          keyokdeal();
  358   2        }
  359   1      }
  360          int keyshi = 3;
  361          // 按键连续按下多少次的操作。。
  362          int setbizhi(int times)
  363          {
  364   1        if (times < 15 * keyshi)
  365   1        {
  366   2          return 10;
  367   2        }
  368   1        if (times < 50 * keyshi)
  369   1        {
  370   2          return 50;
  371   2        }
  372   1        return 100;
  373   1      }
  374          void modeshowandsend()
C251 COMPILER V5.60.0,  main                                                               23/09/23  13:11:16  PAGE 7   

  375          {
  376   1        if(g_setmode==modekey)
  377   1          LCD_ShowString(200, 0, "KEY  ", WHITE, BLACK, 32, 0);
  378   1        if(g_setmode==mode232)
  379   1          LCD_ShowString(200, 0, "232  ", WHITE, BLACK, 32, 0);
  380   1        if(g_setmode==modeTCP)
  381   1          LCD_ShowString(200, 0, "TCP  ", WHITE, BLACK, 32, 0);
  382   1        push(101,g_setmode);
  383   1      }
  384          void pingmuclear();
  385          void lcdinitshowmode()
  386          {
  387   1        pingmuclear2();
  388   1          LCD_ShowString(0, 0,"KEY", WHITE, BLACK, 32, 0);
  389   1          LCD_ShowString(0, 40,"232", WHITE, BLACK, 32, 0);
  390   1          LCD_ShowString(0, 80,"TCP", WHITE, BLACK, 32, 0);
  391   1        LCD_ShowString(0, 120,"ESC", WHITE, BLACK, 32, 0);
  392   1        LCD_ShowString(160, 0, "<---  ", WHITE, BLACK, 32, 0);
  393   1        g_showyoubiao=-1;
  394   1      }
  395          void showhenxiangbase();
  396          void showbak()
  397          {
  398   1        pingmuclear2();
  399   1        LCD_ShowString(0, 0, "Circle TAC", WHITE, BLACK, 32, 0);
  400   1        showhenxiangbase();
  401   1        g_showyoubiao=0;
  402   1      }
  403          
  404          void chulikeyok(int times)
  405          {
  406   1        if(times > 10000)
  407   1        {
  408   2          if(g_showset==showkeyset)
  409   2          {
  410   3            g_showset=showmodeset;
  411   3            printf("chulikeyok over");
  412   3            lcdinitshowmode();
  413   3          }
  414   2        }
  415   1      }
  416          // 2ms 一次的话，那300ms一次ok的吧。。
  417          void dolongtimes(int i, int times)
  418          {
  419   1        int xielv;
  420   1        times = times - 150;
  421   1        
  422   1        if (times < 0)
  423   1        {
  424   2          return;
  425   2        }
  426   1        // printf("times %d",times);
  427   1        if(i== keyok)
  428   1        {
  429   2          chulikeyok(times);
  430   2          return;
  431   2        }
  432   1        xielv = setbizhi(times);
  433   1        if (times % keyshi != 0)
  434   1        {
  435   2          return;
  436   2        }
  437   1        if(g_showset==showmodeset)
  438   1        {
  439   2          return ;
  440   2        }
C251 COMPILER V5.60.0,  main                                                               23/09/23  13:11:16  PAGE 8   

  441   1        if (i == keylow)
  442   1        {
  443   2          keySetDianliu(-xielv);
  444   2          return;
  445   2        }
  446   1        if (i == keyup)
  447   1        {
  448   2          keySetDianliu(xielv);
  449   2          return;
  450   2        }
  451   1      }
  452          void yout_set(char weizhi, char zhi)
  453          {
  454   1        if (weizhi == 0)
  455   1          Y0 = zhi;
  456   1        if (weizhi == 1)
  457   1          Y1 = zhi;
  458   1        if (weizhi == 2)
  459   1          Y2 = zhi;
  460   1        if (weizhi == 3)
  461   1          Y3 = zhi;
  462   1      }
  463          void ledclose(int weizhi)
  464          {
  465   1        if (weizhi == keyon || weizhi == keyok)
  466   1        {
  467   2          return;
  468   2        }
  469   1        yout_set(weizhi, 1);
*** WARNING C188 IN LINE 469 OF ..\User\main.c: 'parameter 1': value truncated
  470   1      }
  471          void ledopen(int weizhi)
  472          {
  473   1        if (weizhi == keyon || weizhi == keyok)
  474   1        {
  475   2          return;
  476   2        }
  477   1        yout_set(weizhi, 0);
*** WARNING C188 IN LINE 477 OF ..\User\main.c: 'parameter 1': value truncated
  478   1      }
  479          
  480          
  481          
  482          
  483          
  484          char xin[30] = {0};
  485          void shurulvbo(void)
  486          {
  487   1        static u8 keybuf[40] = {
  488   1          0xFF,
  489   1          0xFF,
  490   1          0xFF,
  491   1          0xFF,
  492   1          0xFF,
  493   1          0xFF,
  494   1          0xFF,
  495   1          0xFF,
  496   1          0xFF,
  497   1          0xFF,
  498   1          0xFF,
  499   1          0xFF,
  500   1          0xFF,
  501   1          0xFF,
  502   1          0xFF,
  503   1          0xFF,
  504   1          0xFF,
C251 COMPILER V5.60.0,  main                                                               23/09/23  13:11:16  PAGE 9   

  505   1          0xFF,
  506   1          0xFF,
  507   1          0xFF,
  508   1          0xFF,
  509   1          0xFF,
  510   1          0xFF,
  511   1          0xFF,
  512   1          0xFF,
  513   1          0xFF,
  514   1          0xFF,
  515   1          0xFF,
  516   1          0xFF,
  517   1          0xFF,
  518   1          0xFF,
  519   1          0xFF,
  520   1          0xFF,
  521   1          0xFF,
  522   1          0xFF,
  523   1          0xFF,
  524   1          0xFF,
  525   1          0xFF,
  526   1          0xFF,
  527   1          0xFF,
  528   1        }; // 矩阵按键扫描缓冲区 8ms
  529   1        unsigned char i;
  530   1        i = X0;
  531   1        keybuf[0] = (keybuf[0] << 1) | i;
  532   1        i = X1;
  533   1        keybuf[1] = (keybuf[1] << 1) | i;
  534   1        i = X2;
  535   1        keybuf[2] = (keybuf[2] << 1) | i;
  536   1        i = X3;
  537   1        keybuf[3] = (keybuf[3] << 1) | i;
  538   1        for (i = 0; i < 10; i++) // 3按键，所以循环3次
  539   1        {
  540   2          if ((keybuf[i] & 0xFF) == 0x00)
  541   2          {
  542   3            xin[i] = 0;
  543   3          }
  544   2          else if ((keybuf[i] & 0xFF) == 0xFF)
  545   2          { // 连续3次扫描值为1，即1*8ms内都是弹起状态时，可认为按键已稳定的弹起
  546   3            xin[i] = 1;
  547   3          }
  548   2        }
  549   1      }
  550          void keyallchuli()
  551          {
  552   1        int i;
  553   1        static char flag[10] = {0};   // 标志记录
  554   1        static int dowmtimes[10] = {0}; // 标志记录
  555   1        for (i = 0; i < 6; i++)
  556   1        {
  557   2          if (xin[i] == 0)
  558   2          {
  559   3            if (flag[i] == 0) // 代表按键第一次按下。。。
  560   3            {
  561   4              flag[i] = 1;
  562   4              keydown(i);
  563   4            }
  564   3      
  565   3            dowmtimes[i]++;
  566   3            dolongtimes(i, dowmtimes[i]);
  567   3          }
  568   2          else
  569   2          {
  570   3            flag[i] = 0;
C251 COMPILER V5.60.0,  main                                                               23/09/23  13:11:16  PAGE 10  

  571   3            dowmtimes[i] = 0;
  572   3            ledclose(i);
  573   3          }
  574   2        }
  575   1      }
  576          
  577          int tmp = 203; // 温度值
  578          void shownwendu()
  579          {
  580   1        char dataxx[40];
  581   1        // 记得复位
  582   1        if (flagsystemrun == 0 || g_showset!= showkeyset)
  583   1        {
  584   2          return;
  585   2        }
  586   1        sprintf(dataxx, "TMP:%3d.%01d  ", tmp / 10, tmp % 10);
  587   1        LCD_ShowString(0, 80, dataxx, WHITE, BLACK, 32, 0);
  588   1      }
  589          
  590          void shownow()
  591          {
  592   1        // char dataxx[40];
  593   1        // sprintf(dataxx,"NOW:%05d",nowzhi);
  594   1        // LCD_ShowString(0,40,dataxx,WHITE,BLACK,32,0);
  595   1      }
  596          
  597          #define maxjindu 16
  598          #define qidian 07
  599          void pingmuclear2()
  600          {
  601   1        char dataxx[60] = {0};
  602   1      
  603   1        int i;
  604   1        // LCD_Clear(BLACK);
  605   1      
  606   1        sprintf(dataxx, "                     ", 1);
  607   1        for (i = 0; i < 10; i++)
  608   1        {
  609   2          LCD_ShowString(0, i * 30, dataxx, WHITE, BLACK, 32, 0);
  610   2          // delay_ms(1);
  611   2        }
  612   1      }
  613          void pingmuclear()
  614          {
  615   1        static int runflag2 = 0;
  616   1        if (runflag2 == 1)
  617   1        {
  618   2          return;
  619   2        }
  620   1        runflag2 = 1;
  621   1        pingmuclear2();
  622   1      }
  623          
  624          void showhenxiangbase()
  625          {
  626   1        int i;
  627   1        char dataxx[60] = {0};
  628   1        for (i = 0; i < maxjindu; i++)
  629   1        {
  630   2          dataxx[i] = '-';
  631   2        }
  632   1        LCD_ShowString(qidian, 140, dataxx, WHITE, BLACK, 32, 0);
  633   1        LCD_ShowString(qidian, 140 + 40, dataxx, WHITE, BLACK, 32, 0);
  634   1        LCD_ShowString(qidian, 140 + 40 + 30, "0            12bit          1023", WHITE, BLACK, 16, 0);
  635   1      }
  636          void showhenxiang()
C251 COMPILER V5.60.0,  main                                                               23/09/23  13:11:16  PAGE 11  

  637          {
  638   1        int i;
  639   1        char dataxx[60] = {0};
  640   1        static int runflag = 0;
  641   1        if (runflag == 1)
  642   1        {
  643   2          return;
  644   2        }
  645   1        runflag = 1;
  646   1      
  647   1        for (i = 0; i < maxjindu; i++)
  648   1        {
  649   2          dataxx[i] = '-';
  650   2        }
  651   1        LCD_ShowString(qidian, 140, dataxx, WHITE, BLACK, 32, 0);
  652   1        LCD_ShowString(qidian, 140 + 40, dataxx, WHITE, BLACK, 32, 0);
  653   1        LCD_ShowString(qidian, 140 + 40 + 30, "0            12bit          1023", WHITE, BLACK, 16, 0);
  654   1      }
  655          
  656          void showjindtiao()
  657          {
  658   1        int i;
  659   1        char dataxx[60] = {0};
  660   1        int jindu;
  661   1        jindu = g_dianliu * maxjindu / maxsetzhi;
  662   1        for (i = 0; i < maxjindu; i++)
  663   1        {
  664   2          if (i < jindu)
  665   2            dataxx[i] = '>';
  666   2          else
  667   2            dataxx[i] = ' ';
  668   2        }
  669   1        showhenxiang();
  670   1        LCD_ShowString(qidian, 160, dataxx, WHITE, BLACK, 32, 0);
  671   1      }
  672          void showsetzhi()
  673          {
  674   1        char dataxx[40];
  675   1        sprintf(dataxx, "SET:        %04d    ", g_dianliu);
  676   1        LCD_ShowString(0, 120, dataxx, WHITE, BLACK, 32, 0);
  677   1        showjindtiao();
  678   1      }
  679          void showdata()
  680          {
  681   1        // 记得复位
  682   1        if (flagsystemrun == 0 || g_showset!= showkeyset)
  683   1        {
  684   2          return;
  685   2        }
  686   1        shownow();
  687   1        showsetzhi();
  688   1      }
  689          
  690          void showfen(int error)
  691          {
  692   1        // 记得复位
  693   1        if (flagsystemrun == 0 || g_showset!= showkeyset)
  694   1        {
  695   2          return;
  696   2        }
  697   1        if(error==11)
  698   1          LCD_ShowString(0, 40,"ERROR FOR FAN", WHITE, BLACK, 32, 0);
  699   1        if(error==12)
  700   1          LCD_ShowString(0, 40,"ERROR FOR TMP", WHITE, BLACK, 32, 0);
  701   1        if(error==13)
  702   1          LCD_ShowString(0, 40,"ERROR FOR REC CENTER", WHITE, BLACK, 32, 0);
C251 COMPILER V5.60.0,  main                                                               23/09/23  13:11:16  PAGE 12  

  703   1        if(error==14)
  704   1          LCD_ShowString(0, 40,"ERROR FOR REC LIGHT", WHITE, BLACK, 32, 0);
  705   1        if(error>=11 && error<=14)
  706   1        {
  707   2          flagError=1;
  708   2        }
  709   1      }
  710          
  711          void getzhiandchange()
  712          {
  713   1          int weizhi,zhi;
  714   1          Alltongxininfo2 get={0};
  715   1          pop22(&get);
  716   1          if(get.weizhi==0)
  717   1          {
  718   2              return ;
  719   2          }
  720   1          weizhi=get.weizhi;
  721   1          zhi=get.zhi;
  722   1          printf("getzhiandchange weizhi[%d] zhi[%d]\n",weizhi,zhi);
  723   1        timetongxin=0;
  724   1        if( weizhi== 6 )
  725   1        {
  726   2          tmp=zhi;
  727   2        }
  728   1        if( weizhi== 32 )//网络设置过来的电流。。
  729   1        {
  730   2          g_dianliu=zhi;
  731   2          flag_show=1;
  732   2          writebuf();
  733   2        }
  734   1        showfen(weizhi);
  735   1      }
  736          void readbuf();
  737          
  738          void mainrun()
  739          {
  740   1        int rumtimes = 0;
  741   1        LED0 = ~LED0;
  742   1        readbuf();
  743   1      
  744   1        writedizhi(4,0);
  745   1        modeshowandsend();
  746   1        // keydown(0);
  747   1        
  748   1        while (1)
  749   1        {
  750   2          delay_ms2(1);
  751   2          flagKeyDeal();
  752   2          shurulvbo();
  753   2          keyallchuli(); 
  754   2          dealorder();
  755   2          dealchuankou();//处理中控板过来的的数据
  756   2          getzhiandchange();//对数据进行处理。。。
  757   2          if (flag_show == 1)
  758   2          {
  759   3            flag_show = 0;
  760   3            showdata();
  761   3            rumtimes = 0;
  762   3          }
  763   2          if(flagsystemrun==1)
  764   2          {
  765   3            if(timetongxin>6000)
  766   3            {
  767   4              timetongxin=0;
  768   4              push2(13,1);
C251 COMPILER V5.60.0,  main                                                               23/09/23  13:11:16  PAGE 13  

  769   4            }
  770   3          }
  771   2          
  772   2          rumtimes++;
  773   2          if (rumtimes == 15000)
  774   2            showdata();
  775   2          if (rumtimes == 20000)
  776   2          {
  777   3            shownwendu();
  778   3            rumtimes = 0;
  779   3          }
  780   2        }
  781   1      }
  782          void UART1_ISR_Handler (void) interrupt UART1_VECTOR
  783          {
  784   1        if(RI)
  785   1        {
  786   2          RI = 0;
  787   2          printf("rec init now");
  788   2          IAP_CONTR = 0x60;
  789   2        }
  790   1        if(TI)
  791   1        {
  792   2          TI = 0;
  793   2        }
  794   1      }
  795          //========================================================================
  796          // 函数: void main(void)
  797          // 描述: 主函数程序.
  798          // 参数: None.
  799          // 返回: None.
  800          // 版本: V1.0, 2012-10-22
  801          //========================================================================
  802          void test2()
  803          {
  804   1        SCON = 0x50;  // 8位数据,可变波特率
  805   1        AUXR |= 0x40; // 定时器时钟1T模式
  806   1        AUXR &= 0xFE; // 串口1选择定时器1为波特率发生器
  807   1        TMOD &= 0x0F; // 设置定时器模式
  808   1        TL1 = 0xB8;   // 设置定时初始值
  809   1        TH1 = 0xFF;   // 设置定时初始值
  810   1        ET1 = 0;    // 禁止定时器%d中断
  811   1        TR1 = 1;    // 定时器1开始计时
  812   1        ES = 1;
  813   1        EA = 1;
  814   1        P_SW1 = 0x00; // RXD/P3.0, TXD/P3.1
  815   1      
  816   1      }
  817          int errpromdizhi=0x000040;
  818          #define u8 unsigned char
  819          void writebuf()
  820          {
  821   1        u8 get[10];
  822   1        get[0]=55;
  823   1        get[1]=g_dianliu/100;
  824   1        get[2]=g_dianliu%100;
  825   1        get[3]=g_setmode%100;
  826   1        EEPROM_SectorErase(errpromdizhi);
  827   1        EEPROM_write_n(errpromdizhi,get,4);
  828   1      }
  829          
  830          void readbuf()
  831          {
  832   1        u8 get[10]={0};
  833   1          EEPROM_read_n(errpromdizhi,get,4);
  834   1          if(get[0]==55)
C251 COMPILER V5.60.0,  main                                                               23/09/23  13:11:16  PAGE 14  

  835   1          {
  836   2              printf("has init\n");
  837   2          g_dianliu=get[1]*100+get[2];
  838   2          if(g_dianliu>=1023)
  839   2          {
  840   3            g_dianliu=1023;
  841   3          }
  842   2          if(g_dianliu<=0)
  843   2          {
  844   3            g_dianliu=0;
  845   3          }
  846   2          g_setmode=get[3];
  847   2          if(g_setmode<0 || g_setmode>=3)
  848   2          {
  849   3            g_setmode=0;
  850   3          }
  851   2          printf("has init %d-%d-%d\n",get[1],get[2],get[3]);
  852   2          }
  853   1          else
  854   1          {
  855   2              printf("not init\n");
  856   2          get[0]=55;
  857   2          g_dianliu=550;
  858   2            EEPROM_write_n(errpromdizhi,get,1);
  859   2          }
  860   1      }
  861          void main(void)
  862          {
  863   1        WTST = 0;   //设置程序指令延时参数，赋值为0可将CPU执行指令的速度设置为最快
  864   1        EAXSFR();   //扩展SFR(XFR)访问使能 
  865   1        CKCON = 0;      //提高访问XRAM速度
  866   1        
  867   1        XOSCCR = 0xc0;        //启动外部晶振
  868   1        while(!(XOSCCR&1));   //等待时钟稳定
  869   1        CLKDIV = 0x00;        //时钟不分频
  870   1        CLKSEL = 0x0;        //选择外部时钟   
  871   1        GPIO_confibase();
  872   1        SYS_Init();
  873   1        test2();
  874   1        GPIO_configcom3();
  875   1        Uart23Init();
  876   1        P4_MODE_IO_PU(GPIO_Pin_0|GPIO_Pin_1);
  877   1        P3_MODE_IO_PU(GPIO_Pin_6|GPIO_Pin_4);
  878   1        Timer0Init();
  879   1        delay_ms(50);
  880   1      
  881   1        LCD_Init();
  882   1        delay_ms(50);
  883   1        LCD_Fill(0, 0, 320, 240, BLACK);
  884   1        delay_ms(50);
  885   1        pingmuclear();
  886   1        delay_ms(50);
  887   1        mainrun();
  888   1      }
*** WARNING C135 IN LINE 207 OF ..\User\main.c: 'writedizhi?': no return value
*** WARNING C135 IN LINE 207 OF ..\User\main.c: 'writedizhi?': no return value


Module Information          Static   Overlayable
------------------------------------------------
  code size            =        12     ------
  ecode size           =      4225     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       138        393
  xdata-const size     =    ------     ------
C251 COMPILER V5.60.0,  main                                                               23/09/23  13:11:16  PAGE 15  

  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       914     ------
End of Module Information.


C251 COMPILATION COMPLETE.  14 WARNING(S),  0 ERROR(S)
