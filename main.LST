C51 COMPILER V9.05   MAIN                                                                  06/10/2023 17:40:23 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /************************************************************************************
   2             
   3          程序名称： （晶振频率18.432MHz） 
   4          功能说明: 通过串口3发送“Everything is possible!”  
   5                    波特率9600，数据位8，奇偶效验无，停止位1，数据流控制无  
   6          ************************************************************************************/
   7          #include "stc15f2k60s2.h"           // 单片机STC15F2K60S2头文件,可以不再加入reg51.h
   8          #include <intrins.h>                                    // 加入此头文件后,可使用_nop_库函数
   9          #include "delay.h"                      // 延时函数头文件
  10          #include "uart.h"                               // 串行通信函数头文件
  11          #define  uint unsigned int  
  12          #define  uchar unsigned char    
  13          #include <stdio.h>
  14          #include <string.h>
  15          #include "MODBUS.h"
  16          
  17          #include <stdio.h>
  18          #include <string.h>
  19          #include <stdlib.h>
  20          
  21          uint temp1,temp2,temp3,temp4;
  22          
  23          
  24          void io_inint()
  25          {
  26   1              P0M1 = 0;       P0M0 = 0;       //设置P0.0~P0.7为准双向口
  27   1        P1M0 = 0x00; // 设置P1.0为ADC口
  28   1        P1M1 = 0x80;
  29   1              P2M1 = 0;       P2M0 = 0;       //设置P2.0~P2.7为准双向口 
  30   1                  P3M0 = 0;
  31   1          P3M1 = 0;
  32   1              P4M1 = 0;       P4M0 = 0;       //设置P4.0~P4.7为准双向口
  33   1              // P5M1 = 0;    P5M0 = 0;       //设置P5.0~P5.7为准双向口
  34   1      
  35   1                  P5M0 = 0xff; P5M1 = 0x00; 
  36   1      
  37   1      }
  38          
  39          void Delay1ms()         //@24.000MHz
  40          {
  41   1              unsigned char i, j;
  42   1      
  43   1              i = 24;
  44   1              j = 85;
  45   1              do
  46   1              {
  47   2                      while (--j);
  48   2              } while (--i);
  49   1      }
  50          
  51          void delay_ms(int m)
  52          {
  53   1              int x;
  54   1              for(x=m;x>0;x--)
  55   1              {
C51 COMPILER V9.05   MAIN                                                                  06/10/2023 17:40:23 PAGE 2   

  56   2                      Delay1ms();
  57   2              }
  58   1              
  59   1      }
  60          
  61          sbit out1=P1^6;  //
  62          sbit out2=P3^2;
  63          
  64          extern void deanyan();
  65          sbit fen=P5^4;
  66          void testxx()
  67          {
  68   1              P5M0 = 0x00; P5M1 = 0x00; 
  69   1               while (1)
  70   1               {
  71   2                      PrintString("ddd is ok\n");
  72   2                      P5=~P5;
  73   2                      // fen=;
  74   2                      delay_ms(1000);
  75   2                      
  76   2               }
  77   1      }
  78          
  79          /**************************************
  80          延时5微秒(STC90C52RC@12M)
  81          不同的工作环境,需要调整此函数，注意时钟过快时需要修改
  82          当改用1T的MCU时,请调整此延时函数
  83          **************************************/
  84          void Delay5us()
  85          {
  86   1              unsigned char i;
  87   1      
  88   1              i = 20;
  89   1              while (--i);
  90   1      }
  91          
  92          /**************************************
  93          延时5毫秒(STC90C52RC@12M)
  94          不同的工作环境,需要调整此函数
  95          当改用1T的MCU时,请调整此延时函数
  96          **************************************/
  97          void Delay5ms()
  98          {
  99   1      unsigned char i, j;
 100   1      
 101   1              i = 87;
 102   1              j = 42;
 103   1              do
 104   1              {
 105   2                      while (--j);
 106   2              } while (--i);
 107   1      }
 108          
 109          /**************************************
 110          起始信号
 111          **************************************/
 112          sbit      SCL=P2^5;      //IIC时钟引脚定义
 113          sbit      SDA=P2^4;      //IIC数据引脚定义
 114          typedef   unsigned char BYTE;
 115          
 116          void BH1750_Start()
 117          {
C51 COMPILER V9.05   MAIN                                                                  06/10/2023 17:40:23 PAGE 3   

 118   1          SDA = 1;                    //拉高数据线
 119   1          SCL = 1;                    //拉高时钟线
 120   1          Delay5us();                 //延时
 121   1          SDA = 0;                    //产生下降沿
 122   1          Delay5us();                 //延时
 123   1          SCL = 0;                    //拉低时钟线
 124   1      }
 125          
 126          /**************************************
 127          停止信号
 128          **************************************/
 129          void BH1750_Stop()
 130          {
 131   1          SDA = 0;                    //拉低数据线
 132   1          SCL = 1;                    //拉高时钟线
 133   1          Delay5us();                 //延时
 134   1          SDA = 1;                    //产生上升沿
 135   1          Delay5us();                 //延时
 136   1      }
 137          
 138          /**************************************
 139          发送应答信号
 140          入口参数:ack (0:ACK 1:NAK)
 141          **************************************/
 142          void BH1750_SendACK(bit ack)
 143          {
 144   1          SDA = ack;                  //写应答信号
 145   1          SCL = 1;                    //拉高时钟线
 146   1          Delay5us();                 //延时
 147   1          SCL = 0;                    //拉低时钟线
 148   1          Delay5us();                 //延时
 149   1      }
 150          
 151          /**************************************
 152          接收应答信号
 153          **************************************/
 154          bit BH1750_RecvACK()
 155          {
 156   1          SCL = 1;                    //拉高时钟线
 157   1          Delay5us();                 //延时
 158   1          CY = SDA;                   //读应答信号
 159   1          SCL = 0;                    //拉低时钟线
 160   1          Delay5us();                 //延时
 161   1      
 162   1          return CY;
 163   1      }
 164          
 165          /**************************************
 166          向IIC总线发送一个字节数据
 167          **************************************/
 168          void BH1750_SendByte(BYTE dat)
 169          {
 170   1          BYTE i;
 171   1      
 172   1          for (i=0; i<8; i++)         //8位计数器
 173   1          {
 174   2              dat <<= 1;              //移出数据的最高位
 175   2              SDA = CY;               //送数据口
 176   2              SCL = 1;                //拉高时钟线
 177   2              Delay5us();             //延时
 178   2              SCL = 0;                //拉低时钟线
 179   2              Delay5us();             //延时
C51 COMPILER V9.05   MAIN                                                                  06/10/2023 17:40:23 PAGE 4   

 180   2          }
 181   1          BH1750_RecvACK();
 182   1      }
 183          
 184          /**************************************
 185          从IIC总线接收一个字节数据
 186          **************************************/
 187          BYTE BH1750_RecvByte()
 188          {
 189   1          BYTE i;
 190   1          BYTE dat = 0;
 191   1      
 192   1          SDA = 1;                    //使能内部上拉,准备读取数据,
 193   1          for (i=0; i<8; i++)         //8位计数器
 194   1          {
 195   2              dat <<= 1;
 196   2              SCL = 1;                //拉高时钟线
 197   2              Delay5us();             //延时
 198   2              dat |= SDA;             //读数据               
 199   2              SCL = 0;                //拉低时钟线
 200   2              Delay5us();             //延时
 201   2          }
 202   1          return dat;
 203   1      }
 204          
 205          //*********************************
 206          #define   SlaveAddress   0x46 //定义器件在IIC总线中的从地址,根据ALT  ADDRESS地址引脚不同修改
 207                                        //ALT  ADDRESS引脚接地时地址为0x46，接电源时地址为0xB8
 208          
 209          void Single_Write_BH1750(uchar REG_Address)
 210          {
 211   1          BH1750_Start();                  //起始信号
 212   1          BH1750_SendByte(SlaveAddress);   //发送设备地址+写信号
 213   1          BH1750_SendByte(REG_Address);    //内部寄存器地址，
 214   1        //  BH1750_SendByte(REG_data);       //内部寄存器数据，
 215   1          BH1750_Stop();                   //发送停止信号
 216   1      }
 217          
 218          //********单字节读取*****************************************
 219          /*
 220          uchar Single_Read_BH1750(uchar REG_Address)
 221          {  uchar REG_data;
 222              BH1750_Start();                          //起始信号
 223              BH1750_SendByte(SlaveAddress);           //发送设备地址+写信号
 224              BH1750_SendByte(REG_Address);                   //发送存储单元地址，从0开始 
 225              BH1750_Start();                          //起始信号
 226              BH1750_SendByte(SlaveAddress+1);         //发送设备地址+读信号
 227              REG_data=BH1750_RecvByte();              //读出寄存器数据
 228                  BH1750_SendACK(1);   
 229                  BH1750_Stop();                           //停止信号
 230              return REG_data; 
 231          }
 232          */
 233          //*********************************************************
 234          //
 235          //连续读出BH1750内部数据
 236          //
 237          //*********************************************************
 238          BYTE    BUF[8];                         //接收数据缓存区  
 239          void Multiple_read_BH1750()
 240          {   uchar i;    
 241   1          BH1750_Start();                          //起始信号
C51 COMPILER V9.05   MAIN                                                                  06/10/2023 17:40:23 PAGE 5   

 242   1          BH1750_SendByte(SlaveAddress+1);         //发送设备地址+读信号
 243   1              
 244   1               for (i=0; i<3; i++)                      //连续读取2个地址数据，存储中BUF
 245   1          {
 246   2              BUF[i] = BH1750_RecvByte();          //BUF[0]存储0x32地址中的数据
 247   2              if (i == 3)
 248   2              {
 249   3      
 250   3                 BH1750_SendACK(1);                //最后一个数据需要回NOACK
 251   3              }
 252   2              else
 253   2              {               
 254   3                BH1750_SendACK(0);                //回应ACK
 255   3             }
 256   2         }
 257   1      
 258   1          BH1750_Stop();                          //停止信号
 259   1          Delay5ms();
 260   1      }
 261          
 262          
 263          //初始化BH1750，根据需要请参考pdf进行修改****
 264          void Init_BH1750()
 265          {
 266   1         Single_Write_BH1750(0x01);  
 267   1      
 268   1      }
 269          
 270          
 271          extern void initiic();
 272          int     dis_data;                       //变量
 273          void main()                                                    
 274          {
 275   1              
 276   1              io_inint();
 277   1              Uart23Init();
 278   1              
 279   1              
 280   1              Timer0Init();
 281   1              
 282   1              
 283   1              Uart4Init();
 284   1              
 285   1              P_SW2 = 0x80;
 286   1          I2CCFG = 0xe0;                              //使能I2C主机模式
 287   1          I2CMSST = 0x00;
 288   1               EA = 1;
 289   1              out2=1;
 290   1              out1 = 1;
 291   1              delay_ms(10);
 292   1              Modbus_ClearBuff();
 293   1              out1 = 0;
 294   1              UartInit();
 295   1      
 296   1          initiic();
 297   1          delay_ms(10);
 298   1          PrintString("system isok");
 299   1      
 300   1            Init_BH1750();       //初始化BH1750
 301   1            delay_ms(10);
 302   1          while (1)
 303   1              {
C51 COMPILER V9.05   MAIN                                                                  06/10/2023 17:40:23 PAGE 6   

 304   2                  Single_Write_BH1750(0x01);   // power on
 305   2          Single_Write_BH1750(0x10);   // H- resolution mode
 306   2            delay_ms(180);
 307   2                Multiple_Read_BH1750();       //连续读出数据，存储在BUF中
*** WARNING C206 IN LINE 307 OF main.c: 'Multiple_Read_BH1750': missing function-prototype
 308   2                    dis_data=BUF[0];
 309   2          dis_data=(dis_data<<8)+BUF[1];//合成数据，即光照数据
 310   2              
 311   2              printf("runing %d\n",dis_data);
 312   2              delay_ms(10);
 313   2                      deanyan();
 314   2          }
 315   1              while (1)
 316   1              {
 317   2              
 318   2                      delay_ms(1);
 319   2                      // printf("0000000000");
 320   2                      if(recover==1)
 321   2                      {
 322   3                              // deanyan();
 323   3                              jishouokjisuan();
 324   3                              recover=0;
 325   3                              deanyan();
 326   3                      }
 327   2              }
 328   1      }
 329                   
 330                   
 331          
 332                   
 333                   
 334          uint time,lv_bo;
 335          void Timer0() interrupt 1
 336          {
 337   1              time1msjisuan();
 338   1      }
 339          void UARTInterrupt(void) interrupt 4
 340          {
 341   1              unsigned char ans;
 342   1              if (RI)
 343   1              {
 344   2                      RI = 0;
 345   2                      ans=SBUF;
 346   2                      IAP_CONTR=0x60;
 347   2                      chuankou1jisuuan(ans);
 348   2              }
 349   1              else
 350   1              {
 351   2                      TI = 0;
 352   2              }
 353   1              if (TI) //发送中断..
 354   1              {
 355   2                      TI = 0;
 356   2              }
 357   1      }
 358          
 359          void uart2(void ) interrupt 8 
 360          {
 361   1        if (S2CON & S2RI)
 362   1              {
 363   2                      S2CON &= ~S2RI;         
 364   2                      temp2 = S2BUF;
C51 COMPILER V9.05   MAIN                                                                  06/10/2023 17:40:23 PAGE 7   

 365   2              }
 366   1        if (S2CON & S2TI)
 367   1          {
 368   2                              //y1=0;
 369   2              S2CON &= ~S2TI;         //清除S2TI位
 370   2              busy2 = 0;               //清忙标志
 371   2          }  
 372   1      }
 373          
 374            
 375          
 376          
 377          void Uart3() interrupt 17 using 1
 378          {
 379   1          if (S3CON & S3RI)
 380   1          {
 381   2              S3CON &= ~S3RI;         //??S3RI?
 382   2              temp3 = S3BUF;
 383   2                                      
 384   2         }
 385   1      if (S3CON & S3TI)
 386   1          {
 387   2              S3CON &= ~S3TI;         //清除S3TI位
 388   2              busy3 = 0;               //清忙标志
 389   2          }
 390   1      }
 391          
 392          void Uart4() interrupt 18 
 393          {
 394   1          if (S4CON & S4RI)
 395   1          {
 396   2              S4CON &= ~S4RI;         //??S4RI?
 397   2              temp4=S4BUF;
 398   2         }
 399   1      if(TI4)
 400   1              {
 401   2                      CLR_TI4();
 402   2                      busy4 = 0;               //清忙标志
 403   2              }
 404   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    729    ----
   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =     22    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
