C251 COMPILER V5.60.0,  main                                                               20/07/23  22:33:30  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE main.c LARGE BROWSE DEBUG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\
                    -Objects\main.obj) 

stmt  level    source

    1          //  @布丁橘长 2023/03/10
    2          //  PWM编码器模式示例，本示例程序编码器模式1/2/3均支持，SMCR = 1：模式1，SMCR = 2:模式2，SMCR = 3：模式3
    3          //  EC11左旋或右旋，改变数码管亮度
    4          //  EC11引脚定义：A相-P1.0，B相-P5.4
    5          //  MAX7219数码管模块引脚定义：CS = P6^5;DIN = P6^6;CLK = P6^4;（可在MAX7219.h中修改）
    6          //  实验开发板：屠龙刀三.1 @主频12MHz
    7          
    8          
    9          
   10          
   11          
   12          
   13          
   14          
   15          #include <string.h>
   16          #include "stc32g.h"
   17          #include "config.h"
   18          
   19          
   20          #include <stdio.h>
   21          #include <stdarg.h>
   22          #include <stdio.h>
   23          
   24          #include <stdlib.h>
   25          #include "uart.h"
*** WARNING C317 IN LINE 24 OF uart.h: attempt to redefine macro 'MAIN_Fosc'
   26          
   27          
   28          void SYS_Ini();   // STC32初始化设置
   29          void EC11_Handle(); // EC11数据处理
   30                    // 数码管显示
   31          void PWM_Config(); // PWM初始化设置
   32          
   33          u8 cnt_H, cnt_L;   // 计数值高8位、低8位
   34          u16 count, newcount; // 当前计数值、上次计数值
   35                     // 亮度计数值
   36          
   37          
   38          void SYS_Ini() // STC32初始化设置
   39          {
   40   1        EAXFR = 1;    // 使能访问 XFR
   41   1        CKCON = 0x00; // 设置外部数据总线速度为最快
   42   1        WTST = 0x00;  // 设置程序代码等待参数，赋值为 0 可将 CPU 执行程序的速度设置为最快
   43   1        P0M1 = 0x00;
   44   1        P0M0 = 0x00; // 设置P0口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   45   1        P1M1 = 0x00;
   46   1        P1M0 = 0x00; // 设置P1口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   47   1        P2M1 = 0x00;
   48   1        P2M0 = 0x00; // 设置P2口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   49   1        P3M1 = 0x00;
   50   1        P3M0 = 0x00; // 设置P3口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   51   1        P4M1 = 0x00;
   52   1        P4M0 = 0x00; // 设置P4口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   53   1        P5M1 = 0x00;
   54   1        P5M0 = 0x00; // 设置P5口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   55   1        P6M1 = 0x00;
   56   1        P6M0 = 0x00; // 设置P6口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   57   1        P7M1 = 0x00;
C251 COMPILER V5.60.0,  main                                                               20/07/23  22:33:30  PAGE 2   

   58   1        P7M0 = 0x00; // 设置P7口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   59   1      }
   60          
   61          
   62          
   63          void Delay100ms() //@24.000MHz
   64          {
   65   1        unsigned long i;
   66   1      
   67   1        _nop_();
   68   1        _nop_();
   69   1        i = 599998UL;
   70   1        while (i)
   71   1          i--;
   72   1      }
   73          // 定义printf函数
   74          void printf1(const char *fmt, ...)
   75          {
   76   1        char *p;
   77   1        char buf[128]; // 定义一个缓冲区，足够存储输出的字符串
   78   1        va_list args;
   79   1        va_start(args, fmt);
   80   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
   81   1        va_end(args);
   82   1      
   83   1        p = (unsigned char *)buf;
   84   1        while (*p != '\0')
   85   1        {
   86   2          sendbyte1(*p);
   87   2          p++;
   88   2        }
   89   1      }
   90          // 定义printf函数
   91          void printf3(const char *fmt, ...)
   92          {
   93   1        char *p;
   94   1        char buf[128]; // 定义一个缓冲区，足够存储输出的字符串
   95   1        va_list args;
   96   1        va_start(args, fmt);
   97   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
   98   1        va_end(args);
   99   1      
  100   1        p = (unsigned char *)buf;
  101   1        while (*p != '\0')
  102   1        {
  103   2          sendbyte3(*p);
  104   2          p++;
  105   2        }
  106   1      }
  107          char code duanzhi[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e
             -, 0x79, 0x71, 0x76, 0x00, 0x40, 0xff};
  108          
  109          sbit led4 = P4 ^ 3;
  110          sbit led3 = P4 ^ 4;
  111          sbit led2 = P2 ^ 0;
  112          sbit led1 = P2 ^ 1;
  113          #define Y0 led1
  114          #define Y1 led2
  115          #define Y2 led3
  116          #define Y3 led4
  117          
  118          char yout_set(char weizhi, char zhi)
  119          {
  120   1        if (weizhi == 0)
  121   1          Y0 = zhi;
  122   1        if (weizhi == 1)
C251 COMPILER V5.60.0,  main                                                               20/07/23  22:33:30  PAGE 3   

  123   1          Y1 = zhi;
  124   1        if (weizhi == 2)
  125   1          Y2 = zhi;
  126   1        if (weizhi == 3)
  127   1          Y3 = zhi;
  128   1        // if(weizhi==4)Y4=zhi;
  129   1        // if(weizhi==5)Y5=zhi;
  130   1        return (0);
  131   1      }
  132          void yout_closeall()
  133          {
  134   1        char i;
  135   1        for (i = 0; i < 4; i++)
  136   1        {
  137   2          yout_set(i, 1);
  138   2        }
  139   1      }
  140          void Delay10us() //@24.000MHz
  141          {
  142   1        unsigned long i;
  143   1      
  144   1        _nop_();
  145   1        _nop_();
  146   1        _nop_();
  147   1        i = 58UL;
  148   1        while (i)
  149   1          i--;
  150   1      }
  151          void delay10x(int i)
  152          {
  153   1        while (i-- > 0)
  154   1        {
  155   2          Delay10us();
  156   2        }
  157   1      }
  158          void showpre(int num)
  159          {
  160   1        int i;
  161   1        int a[4];
  162   1        a[0] = num % 10000 / 1000;
  163   1        a[1] = num % 1000 / 100;
  164   1      
  165   1        a[2] = num % 100 / 10;
  166   1        a[3] = num % 10;
  167   1      
  168   1        for (i = 0; i < 4; i++)
  169   1        {
  170   2          yout_closeall();
  171   2          yout_set(i, 0);
*** WARNING C188 IN LINE 171 OF main.c: 'parameter 1': value truncated
  172   2          P0 = ~duanzhi[a[i]];
  173   2          Delay10us();
  174   2          yout_closeall();
  175   2          P0 = 0xff;
  176   2          Delay10us();
  177   2        }
  178   1      }
  179          
  180          void testmain()
  181          {
  182   1        int a, b;
  183   1        int times = 0;
  184   1      }
*** WARNING C47 IN LINE 182 OF main.c: 'a': unreferenced local variable
*** WARNING C47 IN LINE 182 OF main.c: 'b': unreferenced local variable
  185          
C251 COMPILER V5.60.0,  main                                                               20/07/23  22:33:30  PAGE 4   

  186          
  187          void dealchuankou();
  188          int gsetzhi = 600;
  189          
  190          
  191          
  192          
  193          
  194          
  195          
  196          char* mystrstr(const char* haystack, const char* needle) {
  197   1          if (*needle == '\0') {
  198   2              return (char*)haystack;
  199   2          }
  200   1      
  201   1          while (*haystack != '\0') {
  202   2              const char* h = haystack;
  203   2              const char* n = needle;
  204   2      
  205   2              while (*n != '\0' && *h == *n) {
  206   3                  h++;
  207   3                  n++;
  208   3              }
  209   2      
  210   2              if (*n == '\0') {
  211   3                  return (char*)haystack; // 子串匹配成功，返回起始位置
  212   3              }
  213   2      
  214   2              haystack++;
  215   2          }
  216   1      
  217   1          return NULL; // 未找到子串，返回NULL
  218   1      }
  219          size_t mystrlen(const char* str) {
  220   1          size_t length = 0;
  221   1          while (str[length] != '\0') {
  222   2              length++;
  223   2          }
  224   1          return length;
  225   1      }
  226          
  227          char* myaddstrstr(const char* haystack, const char* needle)
  228          { 
  229   1        char* result = mystrstr(haystack, needle);
  230   1         if (result != NULL)
  231   1         {
  232   2          result=result+mystrlen(needle);
  233   2         }
  234   1         return result;
  235   1      }
  236          
  237          #define MAX_REGISTERS 10 // 设置最大寄存器数量
  238          
  239          struct Register
  240          {
  241            unsigned int num;
  242            unsigned int value;
  243          };
  244          struct Register registers[MAX_REGISTERS];
  245          int numRegisters = 0;
  246          void showgetzhi()
  247          {
  248   1        unsigned char i;
  249   1        if (i == 0)
  250   1        {
  251   2          printf1("Register not get");
C251 COMPILER V5.60.0,  main                                                               20/07/23  22:33:30  PAGE 5   

  252   2        }
  253   1        // 遍历并打印所有寄存器的值
  254   1        for (i = 0; i < numRegisters; i++)
  255   1        {
  256   2          printf1("Register %d: %d\n", registers[i].num, registers[i].value);
  257   2        }
  258   1      }
  259          
  260          #define MAXgetzhi 100
  261          int getzhi[MAXgetzhi]={0};
  262          void jixi3(char* input)
  263          {
  264   1        char *p=input;
  265   1        char *p1;
  266   1        int i;
  267   1        numRegisters=0;
  268   1        //1234-2234;333-4;end
  269   1        for( i=0;i<100;i++)
  270   1        {
  271   2          p1=myaddstrstr(p,";"); //找有没有下一个的
  272   2          if(p1==NULL)
  273   2          {
  274   3            break;
  275   3          }
  276   2          registers[numRegisters].num = atoi(p);
  277   2          p=myaddstrstr(p,"-");
  278   2          registers[numRegisters].value = atoi(p);
  279   2          numRegisters++;
  280   2          p=myaddstrstr(p,";");  //指向下一个后面
  281   2        }
  282   1        showgetzhi();
  283   1      }
  284          void jixi2(char* input)
  285          {
  286   1        char *p=input;
  287   1        char *p1;
  288   1        int i;
  289   1        unsigned int weizhi;
  290   1        unsigned int zhi;
  291   1        //1234-2234;333-4;end
  292   1        for( i=0;i<100;i++)
  293   1        {
  294   2          p1=myaddstrstr(p,";"); //找有没有下一个的
  295   2          if(p1==NULL)
  296   2          {
  297   3            break;
  298   3          }
  299   2          weizhi = atoi(p);
  300   2          p=myaddstrstr(p,"-");
  301   2          zhi = atoi(p);
  302   2          if(weizhi<MAXgetzhi)
  303   2          getzhi[weizhi]=zhi;
  304   2          p=myaddstrstr(p,";");  //指向下一个后面
  305   2          printf1("get set%d-%d",weizhi,zhi);
  306   2        }
  307   1      }
  308          void setzhione(int dizhi,int zhi)
  309          {
  310   1        char out[30]={0};
  311   1        zhi=zhi*2;
  312   1        sprintf(out,"set:%d-%d;end",dizhi,zhi);
  313   1        printf3(out);
  314   1      }
  315          void jiexi(char* input)
  316          {
  317   1        char par[500]={0};
C251 COMPILER V5.60.0,  main                                                               20/07/23  22:33:30  PAGE 6   

  318   1        char *begin,end;
  319   1        begin=myaddstrstr(input,"set:");
  320   1        // printf1("input begin%s",begin);
  321   1        end=myaddstrstr(begin,"end");
*** WARNING C161 IN LINE 321 OF main.c: 'far' pointer truncated to 'char'
*** WARNING C10 IN LINE 321 OF main.c: conversion: 'pointer' to 'char'
  322   1        // printf1("input end%s",end);
  323   1        if(begin!=NULL && end!=NULL)
*** WARNING C40 IN LINE 323 OF main.c: 'char' converted to 'far' pointer
  324   1        {
  325   2          strcpy(par,begin);
  326   2          jixi2(par);
  327   2        }
  328   1      }
  329          
  330          
  331          
  332          
  333          int setprezhi;
  334          
  335          int dianliusettime=0;
  336          char flagdianliuset=0;
  337          void setdianliusettime(int zhi)
  338          {
  339   1        if(dianliusettime!=0)
  340   1        {
  341   2          return ;
  342   2        }
  343   1        dianliusettime=zhi;
  344   1      }
  345          void changedainliuzhi()
  346          {
  347   1        if(setprezhi!=gsetzhi)
  348   1        {
  349   2          setprezhi=gsetzhi;
  350   2          setdianliusettime(250);
  351   2        }
  352   1      }
  353          void timechuli()
  354          {
  355   1        if(dianliusettime>0)
  356   1        {
  357   2          dianliusettime--;
  358   2          if(dianliusettime==0)
  359   2          {
  360   3            flagdianliuset=1;
  361   3          }
  362   2        }
  363   1      }
  364          void chulidianliu()
  365          {
  366   1        if(flagdianliuset==1)
  367   1        {
  368   2          flagdianliuset=0;
  369   2          setzhione(4,gsetzhi);
  370   2          printf1("dianliu set%d",gsetzhi);
  371   2        }
  372   1      }
  373          
  374          char xin[30] = {0};
  375          sbit X0=P1^3;
  376          void shurulvbo(void)
  377          {
  378   1        static u8 keybuf[40] = {
  379   1          0xFF,
  380   1          0xFF,
C251 COMPILER V5.60.0,  main                                                               20/07/23  22:33:30  PAGE 7   

  381   1          0xFF,
  382   1          0xFF,
  383   1          0xFF,
  384   1          0xFF,
  385   1          0xFF,
  386   1          0xFF,
  387   1          0xFF,
  388   1          0xFF,
  389   1          0xFF,
  390   1          0xFF,
  391   1          0xFF,
  392   1          0xFF,
  393   1          0xFF,
  394   1          0xFF,
  395   1          0xFF,
  396   1          0xFF,
  397   1          0xFF,
  398   1          0xFF,
  399   1          0xFF,
  400   1          0xFF,
  401   1          0xFF,
  402   1          0xFF,
  403   1          0xFF,
  404   1          0xFF,
  405   1          0xFF,
  406   1          0xFF,
  407   1          0xFF,
  408   1          0xFF,
  409   1          0xFF,
  410   1          0xFF,
  411   1          0xFF,
  412   1          0xFF,
  413   1          0xFF,
  414   1          0xFF,
  415   1          0xFF,
  416   1          0xFF,
  417   1          0xFF,
  418   1          0xFF,
  419   1        }; // 矩阵按键扫描缓冲区 8ms
  420   1        unsigned char i;
  421   1        i = X0;
  422   1        keybuf[0] = (keybuf[0] << 1) | i;
  423   1        // i = X1;
  424   1        // keybuf[1] = (keybuf[1] << 1) | i;
  425   1        // i = X2;
  426   1        // keybuf[2] = (keybuf[2] << 1) | i;
  427   1        // i = X3;
  428   1        // keybuf[3] = (keybuf[3] << 1) | i;
  429   1        for (i = 0; i < 1; i++) // 3按键，所以循环3次
  430   1        {
  431   2          if ((keybuf[i] & 0xFF) == 0x00)
  432   2          {
  433   3            xin[i] = 0;
  434   3          }
  435   2          else if ((keybuf[i] & 0xFF) == 0xFF)
  436   2          { // 连续3次扫描值为1，即1*8ms内都是弹起状态时，可认为按键已稳定的弹起
  437   3            xin[i] = 1;
  438   3          }
  439   2        }
  440   1      }
  441          void keydown(int i) // 按键按下的处理、、、
  442          {
  443   1        printf1("keydown %d",i);
  444   1        setzhione(4,gsetzhi);
  445   1      }
  446          void keyup(int i) // 按键按下的处理、、、
C251 COMPILER V5.60.0,  main                                                               20/07/23  22:33:30  PAGE 8   

  447          {
  448   1        printf1("keyup %d",i);
  449   1        setzhione(4,0);
  450   1      }
  451          void keyallchuli()
  452          {
  453   1        int i;
  454   1        static char flag[10] = {0};   // 标志记录
  455   1        static int dowmtimes[10] = {0}; // 标志记录
  456   1        for (i = 0; i < 6; i++)
  457   1        {
  458   2          if (xin[i] == 0)
  459   2          {
  460   3            if (flag[i] == 0) // 代表按键第一次按下。。。
  461   3            {
  462   4              flag[i] = 1;
  463   4              keydown(i);
  464   4            }
  465   3          }
  466   2          if (xin[i] == 1)
  467   2          {
  468   3            if (flag[i] == 1) // 代表下去了又上来
  469   3            {
  470   4              keyup(i);
  471   4            }
  472   3            flag[i] = 0;
  473   3            
  474   3          }
  475   2        }
  476   1      }
  477          void main(void)
  478          {
  479   1      
  480   1        SYS_Ini();    // STC32初始化设置
  481   1        PWM_Config(); // PWM初始化设置
  482   1        EA = 1;     // 使能EA总中断
  483   1      
  484   1        UartInit();
  485   1        Uart23Init();
  486   1        printf1("system is ok");
  487   1        Timer0Init();
  488   1        printf1("system is overall");
  489   1        while (1)
  490   1        {
  491   2          keyallchuli();
  492   2          showpre(gsetzhi);
  493   2          dealchuankou();
  494   2          changedainliuzhi();
  495   2          chulidianliu();
  496   2        }
  497   1      }
  498          
  499          void PWM_ISR() interrupt 26
  500          {
  501   1        if (PWMA_SR1 & 0X02) // 当捕获中断标志置1
  502   1        {
  503   2          cnt_H = PWMA_CCR1H; // 读取计数值高8位
  504   2          cnt_L = PWMA_CCR1L; // 读取计数值低8位
  505   2          PWMA_SR1 &= ~0X02;  // 清零捕获中断标志
  506   2          EC11_Handle();    // 处理EC11数据
  507   2        }
  508   1      }
  509          void PWM_Config() // PWM初始化设置
  510          {
  511   1        PWMA_CCER1 = 0x00; // 关闭通道
  512   1        PWMA_CCMR1 = 0xA1; // 通道模式配置为输入，接编码器 , 滤波器 80 时钟
C251 COMPILER V5.60.0,  main                                                               20/07/23  22:33:30  PAGE 9   

  513   1        PWMA_CCMR2 = 0xA1; // 通道模式配置为输入，接编码器 , 滤波器 80 时钟
  514   1        PWMA_CCER1 = 0x55; // 使能捕获/比较通道1、通道2
  515   1      
  516   1        //  PWMA_SMCR = 0x01;         // 编码器模式 1
  517   1        //  PWMA_SMCR = 0x02;         // 编码器模式 2
  518   1        PWMA_SMCR = 0x03; // 编码器模式 3
  519   1      
  520   1        PWMA_IER = 0x02;  // 使能中断
  521   1        PWMA_CR1 |= 0x01; // 使能计数器
  522   1        PWMA_PS |= 0x04;  // 选择 PWM2_2 通道
  523   1      }
  524          
  525          // 返回变化的步数
  526          long calculateChange(unsigned int previous, unsigned int current)
  527          {
  528   1        long diff = (current - previous + 65536) % 65536;
*** WARNING C188 IN LINE 528 OF main.c: 'initialization': value truncated
  529   1        return diff;
  530   1      }
  531          
  532          char buf3[500];
  533          char flag3 = 0;
  534          int weishu3;
  535          int timeleft1, timeleft2, timeleft3, timeleft4;
  536          void chuankou1put(char c)
  537          {
  538   1        buf3[weishu3++] = c;
  539   1        if (weishu3 > sizeof(buf3) - 3)
  540   1          weishu3 = 0;
  541   1        timeleft3 = 3;
  542   1      }
  543          void chuankou1time()
  544          {
  545   1        if (timeleft3 > 0)
  546   1        {
  547   2          timeleft3--;
  548   2          if (timeleft3 == 0) // 数据一次收完了.
  549   2          {
  550   3            flag3 = 1;
  551   3          }
  552   2        }
  553   1      }
  554          void UARTInterrupt(void) interrupt 4
  555          {
  556   1        unsigned char ans;
  557   1        if (RI)
  558   1        {
  559   2          RI = 0;
  560   2          ans = SBUF;
  561   2          chuankou1put(ans);
  562   2          // IAP_CONTR=0x60;
  563   2        }
  564   1        else
  565   1        {
  566   2          TI = 0;
  567   2          
  568   2        }
  569   1        if (TI) // 发送中断..
  570   1        {
  571   2          TI = 0;
  572   2        }
  573   1      }
  574          void addgetsetzhi(int i)
  575          {
  576   1        int ans;
  577   1        ans=gsetzhi+i;
C251 COMPILER V5.60.0,  main                                                               20/07/23  22:33:30  PAGE 10  

  578   1        if(ans>=0 && ans<=1023)
  579   1        {
  580   2          gsetzhi=ans;
  581   2        }
  582   1      }
  583          void Timer0() interrupt 1
  584          {
  585   1        // gsetzhi++;
  586   1        shurulvbo();
  587   1        timechuli();
  588   1        chuankou1time();
  589   1      }
  590          void EC11_Handle() // EC11数据处理函数
  591          {
  592   1        static unsigned int previous = 0;
  593   1        unsigned int nowzhi;
  594   1        long ans;
  595   1        nowzhi = cnt_H * 256 + cnt_L; // 读取当前计数值
  596   1        ans = calculateChange(previous, nowzhi);
  597   1        previous = nowzhi;
  598   1        if (ans == 4)
  599   1        {
  600   2          addgetsetzhi(1);
  601   2        }
  602   1        else
  603   1        {
  604   2          addgetsetzhi(-1);
  605   2        }
  606   1      }
  607          
  608          int step=0;
  609          void showstep(const char *s)
  610          {
  611   1        printf1("%s\n",s);
  612   1      }
  613          char* my_strstr(const char* haystack, const char* needle) {
  614   1          if (*needle == '\0') {
  615   2              return (char*) haystack;
  616   2          }
  617   1      
  618   1          while (*haystack != '\0') {
  619   2              const char* h = haystack;
  620   2              const char* n = needle;
  621   2      
  622   2              while (*h == *n && *n != '\0') {
  623   3                  h++;
  624   3                  n++;
  625   3              }
  626   2      
  627   2              if (*n == '\0') {
  628   3                  return (char*) haystack;
  629   3              }
  630   2      
  631   2              haystack++;
  632   2          }
  633   1      
  634   1          return NULL;
  635   1      }
  636          void dealchuankou()
  637          {
  638   1        if (flag3 == 1)
  639   1        {
  640   2          flag3 = 0;
  641   2          jiexi(buf3);
  642   2          memset(buf3, 0, sizeof(buf3));
  643   2          weishu3 = 0;
C251 COMPILER V5.60.0,  main                                                               20/07/23  22:33:30  PAGE 11  

  644   2        }
  645   1      }
  646          
  647          
  648          void Uart3() interrupt 17 using 1
  649          {
  650   1          if (S3CON & S3RI)
  651   1          {
  652   2              S3CON &= ~S3RI; //??S3RI?
  653   2              // temp3 = S3BUF;
  654   2              // chuankou3put(temp3);
  655   2          }
  656   1          if (S3CON & S3TI)
  657   1          {
  658   2              S3CON &= ~S3TI; // 清除S3TI位
  659   2              busy3 = 0;      // 清忙标志
  660   2          }
  661   1      }
  662          // 写个函数，传入两个非负数，计算是前进还是后退了，变化规律 15,16,0,1,2...15,16


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2299     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       870        902
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      1045     ------
End of Module Information.


C251 COMPILATION COMPLETE.  8 WARNING(S),  0 ERROR(S)
