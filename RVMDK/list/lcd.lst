C251 COMPILER V5.60.0,  lcd                                                                27/07/23  16:49:44  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE lcd
OBJECT MODULE PLACED IN .\list\lcd.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil_v5 c251\C251\BIN\C251.EXE ..\App\src\lcd.c XSMALL INTR2 BROWSE INCDIR(.
                    -.\Driver\inc;..\User;..\App\inc) DEBUG PRINT(.\list\lcd.lst) OBJECT(.\list\lcd.obj) 

stmt  level    source

    1          
    2          #include "lcd.h"
    3          #include        "APP_Lamp.h"
    4          #include        "STC32G_GPIO.h"
    5          //#include      "STC32G_SPI.h"
    6          #include        "STC32G_Delay.h"
    7          
    8          //#include "stdlib.h"
    9          #include "font.h" 
   10          //#include "usart.h"     
   11          //#include "delay.h"       
   12          //////////////////////////////////////////////////////////////////////////////////       
   13          u8 DFT_SCAN_DIR;
   14          //////////////////////////////////////////////////////////////////////////////////       
   15                                           
   16          //LCD的画笔颜色和背景色    
   17          u16 POINT_COLOR=0x0000; //画笔颜色
   18          u16 BACK_COLOR=0xFFFF;  //背景色 
   19          
   20          //管理LCD重要参数
   21          //默认为竖屏
   22          _lcd_dev lcddev;
   23                             
   24          //写寄存器函数
   25          //regval:寄存器值
   26          void LCD_WR_REG(u8 REG)
   27          { 
   28   1              u8 i;
   29   1              LCD_CS = 0;
   30   1              
   31   1              LCD_RS = 0;
   32   1              
   33   1              for(i=0; i<8; i++)
   34   1              {
   35   2                      if (REG & 0x80)
   36   2                       LCD_SDA = 1;
   37   2                      else
   38   2                       LCD_SDA = 0;
   39   2                      
   40   2                      REG <<= 1;               
   41   2                      LCD_SCL = 0;              
   42   2                      LCD_SCL = 1;
   43   2              }//送低8位
   44   1              LCD_CS=1;
   45   1      }
   46          //写LCD数据
   47          //data:要写入的值
   48          void LCD_WR_DATA(u16 DATA)
   49          {                                                                                          
   50   1        u8 i;
   51   1              LCD_CS = 0;
   52   1              
   53   1              LCD_RS = 1;
   54   1              
   55   1              for(i=0; i<8; i++)
   56   1              {
   57   2                      if (DATA & 0x80)
   58   2                       LCD_SDA = 1;
C251 COMPILER V5.60.0,  lcd                                                                27/07/23  16:49:44  PAGE 2   

   59   2                      else
   60   2                       LCD_SDA = 0;
   61   2                      
   62   2                      DATA <<= 1;              
   63   2                      LCD_SCL = 0;              
   64   2                      LCD_SCL = 1;
   65   2              }//送低8位
   66   1              LCD_CS=1;
   67   1      }                                          
   68          //写寄存器
   69          //LCD_Reg:寄存器地址
   70          //LCD_RegValue:要写入的数据
   71          void LCD_WriteReg(u8 LCD_Reg, u16 LCD_RegValue)
   72          {       
   73   1              LCD_WR_REG(LCD_Reg);
   74   1              LCD_WR_DATA(LCD_RegValue);
   75   1      }             
   76          //开始写GRAM
   77          void LCD_WriteRAM_Prepare(void)
   78          {
   79   1              LCD_WR_REG(lcddev.wramcmd);
   80   1      }        
   81          //LCD写GRAM
   82          //RGB_Code:颜色值
   83          void LCD_WriteRAM(u16 DAT)
   84          {                                                           
   85   1        u8 i;
   86   1              LCD_CS = 0;
   87   1              
   88   1              LCD_RS = 1;
   89   1              
   90   1              for(i=0; i<16; i++)
   91   1              {
   92   2                      if (DAT & 0x8000)
   93   2                       LCD_SDA = 1;
   94   2                      else
   95   2                       LCD_SDA = 0;
   96   2                      
   97   2                      DAT <<= 1;               
   98   2                      LCD_SCL = 0;              
   99   2                      LCD_SCL = 1;
  100   2              } 
  101   1              LCD_CS=1;
  102   1      }
  103          
  104          //当mdk -O1时间优化时需要设置
  105          //延时i
  106          void opt_delay(u8 i)
  107          {
  108   1              while(i--);
  109   1      }
  110            
  111          //设置光标位置
  112          //Xpos:横坐标
  113          //Ypos:纵坐标
  114          void LCD_SetCursor(u16 Xpos, u16 Ypos)
  115          {        
  116   1              LCD_WR_REG(lcddev.setxcmd); 
  117   1              LCD_WR_DATA(Xpos>>8); 
  118   1              LCD_WR_DATA(Xpos&0XFF); 
  119   1              
  120   1              LCD_WR_REG(lcddev.setycmd); 
  121   1              LCD_WR_DATA(Ypos>>8); 
  122   1              LCD_WR_DATA(Ypos&0XFF);
  123   1      }                
  124          //设置LCD的自动扫描方向
C251 COMPILER V5.60.0,  lcd                                                                27/07/23  16:49:44  PAGE 3   

  125          //注意:其他函数可能会受到此函数设置的影响(尤其是9341/6804这两个奇葩),
  126          //所以,一般设置为L2R_U2D即可,如果设置为其他扫描方式,可能导致显示不正常.
  127          //dir:0~7,代表8个方向(具体定义见lcd.h)
  128          //9320/9325/9328/4531/4535/1505/b505/8989/5408/9341等IC已经实际测试                
  129          void LCD_Scan_Dir(u8 dir)
  130          {
  131   1              u16 regval=0;
  132   1              u8 dirreg=0;
  133   1              //u16 temp;  
  134   1              switch(dir)//方向转换
  135   1              {
  136   2                      case 0:dir=6;break;
  137   2                      case 1:dir=7;break;
  138   2                      case 2:dir=4;break;
  139   2                      case 3:dir=5;break;
  140   2                      case 4:dir=1;break;
  141   2                      case 5:dir=0;break;
  142   2                      case 6:dir=3;break;
  143   2                      case 7:dir=2;break;          
  144   2              }
  145   1              switch(dir)
  146   1              {
  147   2                      case L2R_U2D://从左到右,从上到下
  148   2                              regval|=(0<<7)|(0<<6)|(0<<5); 
  149   2                              break;
  150   2                      case L2R_D2U://从左到右,从下到上
  151   2                              regval|=(1<<7)|(0<<6)|(0<<5); 
  152   2                              break;
  153   2                      case R2L_U2D://从右到左,从上到下
  154   2                              regval|=(0<<7)|(1<<6)|(0<<5); 
  155   2                              break;
  156   2                      case R2L_D2U://从右到左,从下到上
  157   2                              regval|=(1<<7)|(1<<6)|(0<<5); 
  158   2                              break;   
  159   2                      case U2D_L2R://从上到下,从左到右
  160   2                              regval|=(0<<7)|(0<<6)|(1<<5); 
  161   2                              break;
  162   2                      case U2D_R2L://从上到下,从右到左
  163   2                              regval|=(0<<7)|(1<<6)|(1<<5); 
  164   2                              break;
  165   2                      case D2U_L2R://从下到上,从左到右
  166   2                              regval|=(1<<7)|(0<<6)|(1<<5); 
  167   2                              break;
  168   2                      case D2U_R2L://从下到上,从右到左
  169   2                              regval|=(1<<7)|(1<<6)|(1<<5); 
  170   2                              break;   
  171   2              }
  172   1              dirreg=0X36; 
  173   1        regval|=0x00; 
  174   1              LCD_WriteReg(dirreg,regval);
  175   1                              
  176   1              LCD_WR_REG(lcddev.setxcmd); 
  177   1              LCD_WR_DATA(0);LCD_WR_DATA(0);
  178   1              LCD_WR_DATA((lcddev.width-1)>>8);LCD_WR_DATA((lcddev.width-1)&0XFF);
  179   1              LCD_WR_REG(lcddev.setycmd); 
  180   1              LCD_WR_DATA(0);LCD_WR_DATA(0);
  181   1              LCD_WR_DATA((lcddev.height-1)>>8);LCD_WR_DATA((lcddev.height-1)&0XFF);  
  182   1                      
  183   1              
  184   1      }      
  185          //画点
  186          //x,y:坐标
  187          //POINT_COLOR:此点的颜色
  188          void LCD_DrawPoint(u16 x,u16 y)
  189          {
  190   1              LCD_SetCursor(x,y);             //设置光标位置 
C251 COMPILER V5.60.0,  lcd                                                                27/07/23  16:49:44  PAGE 4   

  191   1              LCD_WriteRAM_Prepare(); //开始写入GRAM
  192   1              LCD_WriteRAM(POINT_COLOR); 
  193   1      }
  194          
  195          //设置LCD显示方向（6804不支持横屏显示）
  196          //dir:0,竖屏；1,横屏
  197          void LCD_Display_Dir(u8 dir)
  198          {
  199   1              if(dir==0)                      //竖屏
  200   1              {
  201   2                      lcddev.dir=0;   //竖屏
  202   2                      lcddev.width=240;
  203   2                      lcddev.height=320;
  204   2      
  205   2                      lcddev.wramcmd=0X2C;
  206   2                      lcddev.setxcmd=0X2A;
  207   2                      lcddev.setycmd=0X2B;  
  208   2          DFT_SCAN_DIR=U2D_R2L;               
  209   2      
  210   2              }else                           //横屏
  211   1              {                                       
  212   2                      lcddev.dir=1;   //横屏
  213   2                      lcddev.width=320;
  214   2                      lcddev.height=240;
  215   2      
  216   2                      lcddev.wramcmd=0X2C;
  217   2                      lcddev.setxcmd=0X2A;
  218   2                      lcddev.setycmd=0X2B;  
  219   2          DFT_SCAN_DIR=L2R_U2D;               
  220   2                      
  221   2              } 
  222   1              LCD_Scan_Dir(DFT_SCAN_DIR);     //默认扫描方向
  223   1      }
  224          //初始化lcd
  225          //该初始化函数可以初始化各种ILI93XX液晶,但是其他函数是基于ILI9320的!!!
  226          //在其他型号的驱动芯片上没有测试! 
  227          void LCD_Init(void)
  228          {                                                                                 
  229   1      //      GPIO_InitTypeDef GPIO_InitStructure;
  230   1      //      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB,ENABLE);//使能PORTA A B
  231   1      
  232   1      //      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4;                                 //PA0-
             -4 推挽输出 
  233   1      //      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;                  //推挽输出
  234   1      //      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
  235   1      //      GPIO_Init(GPIOA, &GPIO_InitStructure);
  236   1      //      GPIO_SetBits(GPIOA,GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4);
  237   1      //      
  238   1      //      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;                                     //PB1 推挽输出 
  239   1      //      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;                  //推挽输出
  240   1      //      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
  241   1      //      GPIO_Init(GPIOB, &GPIO_InitStructure);
  242   1              
  243   1        //LCD复位 
  244   1              LCD_RESET = 1;
  245   1              delay_ms(1);
  246   1              LCD_RESET = 0;
  247   1              delay_ms(80);
  248   1              LCD_RESET = 1;
  249   1              delay_ms(10);
  250   1      
  251   1              
  252   1      //************* Start Initial Sequence **********//
  253   1              LCD_WR_REG(0xCF);  
  254   1              LCD_WR_DATA(0x00); 
  255   1              LCD_WR_DATA(0xC1); 
C251 COMPILER V5.60.0,  lcd                                                                27/07/23  16:49:44  PAGE 5   

  256   1              LCD_WR_DATA(0X30); 
  257   1              LCD_WR_REG(0xED);  
  258   1              LCD_WR_DATA(0x64); 
  259   1              LCD_WR_DATA(0x03); 
  260   1              LCD_WR_DATA(0X12); 
  261   1              LCD_WR_DATA(0X81); 
  262   1              LCD_WR_REG(0xE8);  
  263   1              LCD_WR_DATA(0x85); 
  264   1              LCD_WR_DATA(0x10); 
  265   1              LCD_WR_DATA(0x7A); 
  266   1              LCD_WR_REG(0xCB);  
  267   1              LCD_WR_DATA(0x39); 
  268   1              LCD_WR_DATA(0x2C); 
  269   1              LCD_WR_DATA(0x00); 
  270   1              LCD_WR_DATA(0x34); 
  271   1              LCD_WR_DATA(0x02); 
  272   1              LCD_WR_REG(0xF7);  
  273   1              LCD_WR_DATA(0x20); 
  274   1              LCD_WR_REG(0xEA);  
  275   1              LCD_WR_DATA(0x00); 
  276   1              LCD_WR_DATA(0x00); 
  277   1              LCD_WR_REG(0xC0);    //Power control 
  278   1              LCD_WR_DATA(0x1B);   //VRH[5:0] 
  279   1              LCD_WR_REG(0xC1);    //Power control 
  280   1              LCD_WR_DATA(0x01);   //SAP[2:0];BT[3:0] 
  281   1              LCD_WR_REG(0xC5);    //VCM control 
  282   1              LCD_WR_DATA(0x30);       //3F
  283   1              LCD_WR_DATA(0x30);       //3C
  284   1              LCD_WR_REG(0xC7);    //VCM control2 
  285   1              LCD_WR_DATA(0XB7); 
  286   1              LCD_WR_REG(0x36);    // Memory Access Control 
  287   1              LCD_WR_DATA(0x48); 
  288   1              LCD_WR_REG(0x3A);   
  289   1              LCD_WR_DATA(0x55); 
  290   1              LCD_WR_REG(0xB1);   
  291   1              LCD_WR_DATA(0x00);   
  292   1              LCD_WR_DATA(0x1A); 
  293   1              LCD_WR_REG(0xB6);    // Display Function Control 
  294   1              LCD_WR_DATA(0x0A); 
  295   1              LCD_WR_DATA(0xA2); 
  296   1              LCD_WR_REG(0xF2);    // 3Gamma Function Disable 
  297   1              LCD_WR_DATA(0x00); 
  298   1              LCD_WR_REG(0x26);    //Gamma curve selected 
  299   1              LCD_WR_DATA(0x01); 
  300   1              LCD_WR_REG(0xE0);    //Set Gamma 
  301   1              LCD_WR_DATA(0x0F); 
  302   1              LCD_WR_DATA(0x2A); 
  303   1              LCD_WR_DATA(0x28); 
  304   1              LCD_WR_DATA(0x08); 
  305   1              LCD_WR_DATA(0x0E); 
  306   1              LCD_WR_DATA(0x08); 
  307   1              LCD_WR_DATA(0x54); 
  308   1              LCD_WR_DATA(0XA9); 
  309   1              LCD_WR_DATA(0x43); 
  310   1              LCD_WR_DATA(0x0A); 
  311   1              LCD_WR_DATA(0x0F); 
  312   1              LCD_WR_DATA(0x00); 
  313   1              LCD_WR_DATA(0x00); 
  314   1              LCD_WR_DATA(0x00); 
  315   1              LCD_WR_DATA(0x00);               
  316   1              LCD_WR_REG(0XE1);    //Set Gamma 
  317   1              LCD_WR_DATA(0x00); 
  318   1              LCD_WR_DATA(0x15); 
  319   1              LCD_WR_DATA(0x17); 
  320   1              LCD_WR_DATA(0x07); 
  321   1              LCD_WR_DATA(0x11); 
C251 COMPILER V5.60.0,  lcd                                                                27/07/23  16:49:44  PAGE 6   

  322   1              LCD_WR_DATA(0x06); 
  323   1              LCD_WR_DATA(0x2B); 
  324   1              LCD_WR_DATA(0x56); 
  325   1              LCD_WR_DATA(0x3C); 
  326   1              LCD_WR_DATA(0x05); 
  327   1              LCD_WR_DATA(0x10); 
  328   1              LCD_WR_DATA(0x0F); 
  329   1              LCD_WR_DATA(0x3F); 
  330   1              LCD_WR_DATA(0x3F); 
  331   1              LCD_WR_DATA(0x0F); 
  332   1              LCD_WR_REG(0x2B); 
  333   1              LCD_WR_DATA(0x00);
  334   1              LCD_WR_DATA(0x00);
  335   1              LCD_WR_DATA(0x01);
  336   1              LCD_WR_DATA(0x3f);
  337   1              LCD_WR_REG(0x2A); 
  338   1              LCD_WR_DATA(0x00);
  339   1              LCD_WR_DATA(0x00);
  340   1              LCD_WR_DATA(0x00);
  341   1              LCD_WR_DATA(0xef);       
  342   1              LCD_WR_REG(0x11); //Exit Sleep
  343   1              delay_ms(120);
  344   1              LCD_WR_REG(0x29); //display on  
  345   1      
  346   1              LCD_Display_Dir(0);                     //默认为竖屏
  347   1              LCD_BL=1;                                       //点亮背光
  348   1              LCD_Clear(WHITE);
  349   1      }  
  350          //清屏函数
  351          //color:要清屏的填充色
  352          void LCD_Clear(u16 color)
  353          {
  354   1              u32 index=0;      
  355   1              u32 totalpoint=lcddev.width;
  356   1              totalpoint*=lcddev.height;      //得到总点数
  357   1        LCD_SetCursor(0x00,0x0000);   //设置光标位置
  358   1              LCD_WriteRAM_Prepare();     //开始写入GRAM                
  359   1              for(index=0;index<totalpoint;index++)
  360   1              {
  361   2                      LCD_WriteRAM(color);       
  362   2              }
  363   1      }  
  364          //在指定区域内填充单个颜色
  365          //(sx,sy),(ex,ey):填充矩形对角坐标,区域大小为:(ex-sx+1)*(ey-sy+1)   
  366          //color:要填充的颜色
  367          void LCD_Fill(u16 sx,u16 sy,u16 ex,u16 ey,u16 color)
  368          {          
  369   1              u16 i,j;
  370   1              u16 xlen=0;
  371   1              xlen=ex-sx+1;      
  372   1              for(i=sy;i<=ey;i++)
  373   1              {
  374   2                      LCD_SetCursor(sx,i);                                    //设置光标位置 
  375   2                      LCD_WriteRAM_Prepare();                         //开始写入GRAM    
  376   2                      for(j=0;j<xlen;j++)LCD_WriteRAM(color); //设置光标位置      
  377   2              }
  378   1      }  
  379          //在指定区域内填充指定颜色块                     
  380          //(sx,sy),(ex,ey):填充矩形对角坐标,区域大小为:(ex-sx+1)*(ey-sy+1)   
  381          //color:要填充的颜色
  382          void LCD_Color_Fill(u16 sx,u16 sy,u16 ex,u16 ey,u16 *color)
  383          {  
  384   1              u16 height,width;
  385   1              u16 i,j;
  386   1              width=ex-sx+1;          //得到填充的宽度
  387   1              height=ey-sy+1;         //高度
C251 COMPILER V5.60.0,  lcd                                                                27/07/23  16:49:44  PAGE 7   

  388   1              for(i=0;i<height;i++)
  389   1              {
  390   2                      LCD_SetCursor(sx,sy+i);         //设置光标位置 
  391   2                      LCD_WriteRAM_Prepare();     //开始写入GRAM
  392   2                      for(j=0;j<width;j++)LCD_WriteRAM(color[i*height+j]);//写入数据 
  393   2              }         
  394   1      }  
  395          //画线
  396          //x1,y1:起点坐标
  397          //x2,y2:终点坐标  
  398          void LCD_DrawLine(u16 x1, u16 y1, u16 x2, u16 y2)
  399          {
  400   1              u16 t; 
  401   1              int xerr=0,yerr=0,delta_x,delta_y,distance; 
  402   1              int incx,incy,uRow,uCol; 
  403   1              delta_x=x2-x1; //计算坐标增量 
  404   1              delta_y=y2-y1; 
  405   1              uRow=x1; 
  406   1              uCol=y1; 
  407   1              if(delta_x>0)incx=1; //设置单步方向 
  408   1              else if(delta_x==0)incx=0;//垂直线 
  409   1              else {incx=-1;delta_x=-delta_x;} 
  410   1              if(delta_y>0)incy=1; 
  411   1              else if(delta_y==0)incy=0;//水平线 
  412   1              else{incy=-1;delta_y=-delta_y;} 
  413   1              if( delta_x>delta_y)distance=delta_x; //选取基本增量坐标轴 
  414   1              else distance=delta_y; 
  415   1              for(t=0;t<=distance+1;t++ )//画线输出 
  416   1              {  
  417   2                      LCD_DrawPoint(uRow,uCol);//画点 
  418   2                      xerr+=delta_x ; 
  419   2                      yerr+=delta_y ; 
  420   2                      if(xerr>distance) 
  421   2                      { 
  422   3                              xerr-=distance; 
  423   3                              uRow+=incx; 
  424   3                      } 
  425   2                      if(yerr>distance) 
  426   2                      { 
  427   3                              yerr-=distance; 
  428   3                              uCol+=incy; 
  429   3                      } 
  430   2              }  
  431   1      }    
  432          //画矩形          
  433          //(x1,y1),(x2,y2):矩形的对角坐标
  434          void LCD_DrawRectangle(u16 x1, u16 y1, u16 x2, u16 y2)
  435          {
  436   1              LCD_DrawLine(x1,y1,x2,y1);
  437   1              LCD_DrawLine(x1,y1,x1,y2);
  438   1              LCD_DrawLine(x1,y2,x2,y2);
  439   1              LCD_DrawLine(x2,y1,x2,y2);
  440   1      }
  441          //在指定位置画一个指定大小的圆
  442          //(x,y):中心点
  443          //r    :半径
  444          void Draw_Circle(u16 x0,u16 y0,u8 r)
  445          {
  446   1              int a,b;
  447   1              int di;
  448   1              a=0;b=r;          
  449   1              di=3-(r<<1);             //判断下个点位置的标志
  450   1              while(a<=b)
  451   1              {
  452   2                      LCD_DrawPoint(x0+a,y0-b);             //5
  453   2                      LCD_DrawPoint(x0+b,y0-a);             //0           
C251 COMPILER V5.60.0,  lcd                                                                27/07/23  16:49:44  PAGE 8   

  454   2                      LCD_DrawPoint(x0+b,y0+a);             //4               
  455   2                      LCD_DrawPoint(x0+a,y0+b);             //6 
  456   2                      LCD_DrawPoint(x0-a,y0+b);             //1       
  457   2                      LCD_DrawPoint(x0-b,y0+a);             
  458   2                      LCD_DrawPoint(x0-a,y0-b);             //2             
  459   2                      LCD_DrawPoint(x0-b,y0-a);             //7                
  460   2                      a++;
  461   2                      //使用Bresenham算法画圆     
  462   2                      if(di<0)di +=4*a+6;       
  463   2                      else
  464   2                      {
  465   3                              di+=10+4*(a-b);   
  466   3                              b--;
  467   3                      }                                                   
  468   2              }
  469   1      }                                                                         
  470          //在指定位置显示一个字符
  471          //x,y:起始坐标
  472          //num:要显示的字符:" "--->"~"
  473          //size:字体大小 12/16
  474          //mode:叠加方式(1)还是非叠加方式(0)
  475          void LCD_ShowChar(u16 x,u16 y,u8 num,u8 size,u8 mode)
  476          {                                                         
  477   1          u8 temp,t1,t;
  478   1              u16 y0=y;
  479   1              u16 colortemp=POINT_COLOR;                                   
  480   1              //设置窗口                 
  481   1              num=num-' ';//得到偏移后的值
  482   1              if(!mode) //非叠加方式
  483   1              {
  484   2                  for(t=0;t<size;t++)
  485   2                  {   
  486   3                              if(size==12)temp=asc2_1206[num][t];  //调用1206字体
  487   3                              else temp=asc2_1608[num][t];             //调用1608字体                                   
  488   3                      for(t1=0;t1<8;t1++)
  489   3                              {                           
  490   4                              if(temp&0x80)POINT_COLOR=colortemp;
  491   4                                      else POINT_COLOR=BACK_COLOR;
  492   4                                      LCD_DrawPoint(x,y);     
  493   4                                      temp<<=1;
  494   4                                      y++;
  495   4                                      if(x>=lcddev.width){POINT_COLOR=colortemp;return;}//超区域了
  496   4                                      if((y-y0)==size)
  497   4                                      {
  498   5                                              y=y0;
  499   5                                              x++;
  500   5                                              if(x>=lcddev.width){POINT_COLOR=colortemp;return;}//超区域了
  501   5                                              break;
  502   5                                      }
  503   4                              }        
  504   3                  }    
  505   2              }else//叠加方式
  506   1              {
  507   2                  for(t=0;t<size;t++)
  508   2                  {   
  509   3                              if(size==12)temp=asc2_1206[num][t];  //调用1206字体
  510   3                              else temp=asc2_1608[num][t];             //调用1608字体                                   
  511   3                      for(t1=0;t1<8;t1++)
  512   3                              {                           
  513   4                              if(temp&0x80)LCD_DrawPoint(x,y); 
  514   4                                      temp<<=1;
  515   4                                      y++;
  516   4                                      if(x>=lcddev.height){POINT_COLOR=colortemp;return;}//超区域了
  517   4                                      if((y-y0)==size)
  518   4                                      {
  519   5                                              y=y0;
C251 COMPILER V5.60.0,  lcd                                                                27/07/23  16:49:44  PAGE 9   

  520   5                                              x++;
  521   5                                              if(x>=lcddev.width){POINT_COLOR=colortemp;return;}//超区域了
  522   5                                              break;
  523   5                                      }
  524   4                              }        
  525   3                  }     
  526   2              }
  527   1              POINT_COLOR=colortemp;                            
  528   1      }   
  529          //m^n函数
  530          //返回值:m^n次方.
  531          u32 LCD_Pow(u8 m,u8 n)
  532          {
  533   1              u32 result=1;    
  534   1              while(n--)result*=m;    
  535   1              return result;
  536   1      }                        
  537          //显示数字,高位为0,则不显示
  538          //x,y :起点坐标  
  539          //len :数字的位数
  540          //size:字体大小
  541          //color:颜色 
  542          //num:数值(0~4294967295);        
  543          void LCD_ShowNum(u16 x,u16 y,u32 num,u8 len,u8 size)
  544          {               
  545   1              u8 t,temp;
  546   1              u8 enshow=0;                                               
  547   1              for(t=0;t<len;t++)
  548   1              {
  549   2                      temp=(num/LCD_Pow(10,len-t-1))%10;
*** WARNING C188 IN LINE 549 OF ..\App\src\lcd.c: 'parameter 2': value truncated
  550   2                      if(enshow==0&&t<(len-1))
  551   2                      {
  552   3                              if(temp==0)
  553   3                              {
  554   4                                      LCD_ShowChar(x+(size/2)*t,y,' ',size,0);
  555   4                                      continue;
  556   4                              }else enshow=1; 
  557   3                               
  558   3                      }
  559   2                      LCD_ShowChar(x+(size/2)*t,y,temp+'0',size,0); 
*** WARNING C188 IN LINE 559 OF ..\App\src\lcd.c: 'parameter 3': value truncated
  560   2              }
  561   1      } 
  562          //显示数字,高位为0,还是显示
  563          //x,y:起点坐标
  564          //num:数值(0~999999999);         
  565          //len:长度(即要显示的位数)
  566          //size:字体大小
  567          //mode:
  568          //[7]:0,不填充;1,填充0.
  569          //[6:1]:保留
  570          //[0]:0,非叠加显示;1,叠加显示.
  571          void LCD_ShowxNum(u16 x,u16 y,u32 num,u8 len,u8 size,u8 mode)
  572          {  
  573   1              u8 t,temp;
  574   1              u8 enshow=0;                                               
  575   1              for(t=0;t<len;t++)
  576   1              {
  577   2                      temp=(num/LCD_Pow(10,len-t-1))%10;
*** WARNING C188 IN LINE 577 OF ..\App\src\lcd.c: 'parameter 2': value truncated
  578   2                      if(enshow==0&&t<(len-1))
  579   2                      {
  580   3                              if(temp==0)
  581   3                              {
  582   4                                      if(mode&0X80)LCD_ShowChar(x+(size/2)*t,y,'0',size,mode&0X01);  
C251 COMPILER V5.60.0,  lcd                                                                27/07/23  16:49:44  PAGE 10  

  583   4                                      else LCD_ShowChar(x+(size/2)*t,y,' ',size,mode&0X01);  
  584   4                                      continue;
  585   4                              }else enshow=1; 
  586   3                               
  587   3                      }
  588   2                      LCD_ShowChar(x+(size/2)*t,y,temp+'0',size,mode&0X01); 
*** WARNING C188 IN LINE 588 OF ..\App\src\lcd.c: 'parameter 3': value truncated
  589   2              }
  590   1      } 
  591          //显示字符串
  592          //x,y:起点坐标
  593          //width,height:区域大小  
  594          //size:字体大小
  595          //*p:字符串起始地址               
  596          void LCD_ShowString(u16 x,u16 y,u16 width,u16 height,u8 size,u8 *p)
  597          {         
  598   1              u8 x0=x;
  599   1              width+=x;
  600   1              height+=y;
  601   1          while((*p<='~')&&(*p>=' '))//判断是不是非法字符!
  602   1          {       
  603   2              if(x>=width){x=x0;y+=size;}
  604   2              if(y>=height)break;//退出
  605   2              LCD_ShowChar(x,y,*p,size,0);
  606   2              x+=size/2;
  607   2              p++;
  608   2          }  
  609   1      }
  610          
  611          //设置窗口
  612          void LCD_Set_Window(u16 sx,u16 sy,u16 width,u16 height)
  613          {   
  614   1              width=sx+width-1;
  615   1              height=sy+height-1;
  616   1      
  617   1              LCD_WR_REG(lcddev.setxcmd);
  618   1              LCD_WR_DATA(sx>>8);  
  619   1              LCD_WR_DATA(sx&0XFF);     
  620   1              LCD_WR_DATA(width>>8);   
  621   1              LCD_WR_DATA(width&0XFF);   
  622   1              LCD_WR_REG(lcddev.setycmd);
  623   1              LCD_WR_DATA(sy>>8);   
  624   1              LCD_WR_DATA(sy&0XFF);  
  625   1              LCD_WR_DATA(height>>8);   
  626   1              LCD_WR_DATA(height&0XFF);  
  627   1      }
  628          
  629          
  630          
  631          
  632          
  633          
  634          
  635          
  636          
  637          
  638          
  639          
  640          
  641          
  642          
  643          
  644          
  645          
  646          
  647          
C251 COMPILER V5.60.0,  lcd                                                                27/07/23  16:49:44  PAGE 11  



Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3137     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        15         96
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      2672     ------
End of Module Information.


C251 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
