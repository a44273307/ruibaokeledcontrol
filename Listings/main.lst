C251 COMPILER V5.60.0,  main                                                               19/07/23  01:49:18  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE main.c LARGE BROWSE DEBUG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\
                    -Objects\main.obj) 

stmt  level    source

    1          //  @布丁橘长 2023/03/10
    2          //  PWM编码器模式示例，本示例程序编码器模式1/2/3均支持，SMCR = 1：模式1，SMCR = 2:模式2，SMCR = 3：模式3
    3          //  EC11左旋或右旋，改变数码管亮度
    4          //  EC11引脚定义：A相-P1.0，B相-P5.4
    5          //  MAX7219数码管模块引脚定义：CS = P6^5;DIN = P6^6;CLK = P6^4;（可在MAX7219.h中修改）
    6          //  实验开发板：屠龙刀三.1 @主频12MHz
    7          
    8          
    9          
   10          
   11          
   12          
   13          
   14          
   15          #include <string.h>
   16          #include "stc32g.h"
   17          #include "config.h"
   18          
   19          
   20          #include <stdio.h>
   21          #include <stdarg.h>
   22          #include <stdio.h>
   23          
   24          #include <stdlib.h>
   25          #include "uart.h"
*** WARNING C317 IN LINE 24 OF uart.h: attempt to redefine macro 'MAIN_Fosc'
   26          
   27          
   28          void SYS_Ini();   // STC32初始化设置
   29          void EC11_Handle(); // EC11数据处理
   30                    // 数码管显示
   31          void PWM_Config(); // PWM初始化设置
   32          
   33          u8 cnt_H, cnt_L;   // 计数值高8位、低8位
   34          u16 count, newcount; // 当前计数值、上次计数值
   35                     // 亮度计数值
   36          
   37          
   38          void SYS_Ini() // STC32初始化设置
   39          {
   40   1        EAXFR = 1;    // 使能访问 XFR
   41   1        CKCON = 0x00; // 设置外部数据总线速度为最快
   42   1        WTST = 0x00;  // 设置程序代码等待参数，赋值为 0 可将 CPU 执行程序的速度设置为最快
   43   1        P0M1 = 0x00;
   44   1        P0M0 = 0x00; // 设置P0口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   45   1        P1M1 = 0x00;
   46   1        P1M0 = 0x00; // 设置P1口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   47   1        P2M1 = 0x00;
   48   1        P2M0 = 0x00; // 设置P2口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   49   1        P3M1 = 0x00;
   50   1        P3M0 = 0x00; // 设置P3口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   51   1        P4M1 = 0x00;
   52   1        P4M0 = 0x00; // 设置P4口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   53   1        P5M1 = 0x00;
   54   1        P5M0 = 0x00; // 设置P5口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   55   1        P6M1 = 0x00;
   56   1        P6M0 = 0x00; // 设置P6口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   57   1        P7M1 = 0x00;
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:49:18  PAGE 2   

   58   1        P7M0 = 0x00; // 设置P7口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   59   1      }
   60          
   61          
   62          
   63          void Delay100ms() //@24.000MHz
   64          {
   65   1        unsigned long i;
   66   1      
   67   1        _nop_();
   68   1        _nop_();
   69   1        i = 599998UL;
   70   1        while (i)
   71   1          i--;
   72   1      }
   73          // 定义printf函数
   74          void printf1(const char *fmt, ...)
   75          {
   76   1        char *p;
   77   1        char buf[128]; // 定义一个缓冲区，足够存储输出的字符串
   78   1        va_list args;
   79   1        va_start(args, fmt);
   80   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
   81   1        va_end(args);
   82   1      
   83   1        p = (unsigned char *)buf;
   84   1        while (*p != '\0')
   85   1        {
   86   2          sendbyte1(*p);
   87   2          p++;
   88   2        }
   89   1      }
   90          char code duanzhi[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e
             -, 0x79, 0x71, 0x76, 0x00, 0x40, 0xff};
   91          
   92          sbit led4 = P4 ^ 3;
   93          sbit led3 = P4 ^ 4;
   94          sbit led2 = P2 ^ 0;
   95          sbit led1 = P2 ^ 1;
   96          #define Y0 led1
   97          #define Y1 led2
   98          #define Y2 led3
   99          #define Y3 led4
  100          
  101          char yout_set(char weizhi, char zhi)
  102          {
  103   1        if (weizhi == 0)
  104   1          Y0 = zhi;
  105   1        if (weizhi == 1)
  106   1          Y1 = zhi;
  107   1        if (weizhi == 2)
  108   1          Y2 = zhi;
  109   1        if (weizhi == 3)
  110   1          Y3 = zhi;
  111   1        // if(weizhi==4)Y4=zhi;
  112   1        // if(weizhi==5)Y5=zhi;
  113   1        return (0);
  114   1      }
  115          void yout_closeall()
  116          {
  117   1        char i;
  118   1        for (i = 0; i < 4; i++)
  119   1        {
  120   2          yout_set(i, 1);
  121   2        }
  122   1      }
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:49:18  PAGE 3   

  123          void Delay10us() //@24.000MHz
  124          {
  125   1        unsigned long i;
  126   1      
  127   1        _nop_();
  128   1        _nop_();
  129   1        _nop_();
  130   1        i = 58UL;
  131   1        while (i)
  132   1          i--;
  133   1      }
  134          void delay10x(int i)
  135          {
  136   1        while (i-- > 0)
  137   1        {
  138   2          Delay10us();
  139   2        }
  140   1      }
  141          void showpre(int num)
  142          {
  143   1        int i;
  144   1        int a[4];
  145   1        a[0] = num % 10000 / 1000;
  146   1        a[1] = num % 1000 / 100;
  147   1      
  148   1        a[2] = num % 100 / 10;
  149   1        a[3] = num % 10;
  150   1      
  151   1        for (i = 0; i < 4; i++)
  152   1        {
  153   2          yout_closeall();
  154   2          yout_set(i, 0);
*** WARNING C188 IN LINE 154 OF main.c: 'parameter 1': value truncated
  155   2          P0 = ~duanzhi[a[i]];
  156   2          Delay10us();
  157   2          yout_closeall();
  158   2          P0 = 0xff;
  159   2          Delay10us();
  160   2        }
  161   1      }
  162          
  163          void testmain()
  164          {
  165   1        int a, b;
  166   1        int times = 0;
  167   1      }
*** WARNING C47 IN LINE 165 OF main.c: 'a': unreferenced local variable
*** WARNING C47 IN LINE 165 OF main.c: 'b': unreferenced local variable
  168          
  169          
  170          void dealchuankou();
  171          int gsetzhi = 1234;
  172          
  173          
  174          
  175          
  176          
  177          
  178          
  179          char* mystrstr(const char* haystack, const char* needle) {
  180   1          if (*needle == '\0') {
  181   2              return (char*)haystack;
  182   2          }
  183   1      
  184   1          while (*haystack != '\0') {
  185   2              const char* h = haystack;
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:49:18  PAGE 4   

  186   2              const char* n = needle;
  187   2      
  188   2              while (*n != '\0' && *h == *n) {
  189   3                  h++;
  190   3                  n++;
  191   3              }
  192   2      
  193   2              if (*n == '\0') {
  194   3                  return (char*)haystack; // 子串匹配成功，返回起始位置
  195   3              }
  196   2      
  197   2              haystack++;
  198   2          }
  199   1      
  200   1          return NULL; // 未找到子串，返回NULL
  201   1      }
  202          size_t mystrlen(const char* str) {
  203   1          size_t length = 0;
  204   1          while (str[length] != '\0') {
  205   2              length++;
  206   2          }
  207   1          return length;
  208   1      }
  209          
  210          char* myaddstrstr(const char* haystack, const char* needle)
  211          { 
  212   1        char* result = mystrstr(haystack, needle);
  213   1         if (result != NULL)
  214   1         {
  215   2          result=result+mystrlen(needle);
  216   2         }
  217   1         return result;
  218   1      }
  219          
  220          #define MAX_REGISTERS 10 // 设置最大寄存器数量
  221          
  222          struct Register
  223          {
  224            unsigned int num;
  225            unsigned int value;
  226          };
  227          struct Register registers[MAX_REGISTERS];
  228          int numRegisters = 0;
  229          void showgetzhi()
  230          {
  231   1        unsigned char i;
  232   1        if (i == 0)
  233   1        {
  234   2          printf1("Register not get");
  235   2        }
  236   1        // 遍历并打印所有寄存器的值
  237   1        for (i = 0; i < numRegisters; i++)
  238   1        {
  239   2          printf1("Register %d: %d\n", registers[i].num, registers[i].value);
  240   2        }
  241   1      }
  242          
  243          #define MAXgetzhi 100
  244          int getzhi[MAXgetzhi]={0};
  245          void jixi3(char* input)
  246          {
  247   1        char *p=input;
  248   1        char *p1;
  249   1        int i;
  250   1        numRegisters=0;
  251   1        //1234-2234;333-4;end
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:49:18  PAGE 5   

  252   1        for( i=0;i<100;i++)
  253   1        {
  254   2          p1=myaddstrstr(p,";"); //找有没有下一个的
  255   2          if(p1==NULL)
  256   2          {
  257   3            break;
  258   3          }
  259   2          registers[numRegisters].num = atoi(p);
  260   2          p=myaddstrstr(p,"-");
  261   2          registers[numRegisters].value = atoi(p);
  262   2          numRegisters++;
  263   2          p=myaddstrstr(p,";");  //指向下一个后面
  264   2        }
  265   1        showgetzhi();
  266   1      }
  267          void jixi2(char* input)
  268          {
  269   1        char *p=input;
  270   1        char *p1;
  271   1        int i;
  272   1        unsigned int weizhi;
  273   1        unsigned int zhi;
  274   1        //1234-2234;333-4;end
  275   1        for( i=0;i<100;i++)
  276   1        {
  277   2          p1=myaddstrstr(p,";"); //找有没有下一个的
  278   2          if(p1==NULL)
  279   2          {
  280   3            break;
  281   3          }
  282   2          weizhi = atoi(p);
  283   2          p=myaddstrstr(p,"-");
  284   2          zhi = atoi(p);
  285   2          if(weizhi<MAXgetzhi)
  286   2          getzhi[weizhi]=zhi;
  287   2          p=myaddstrstr(p,";");  //指向下一个后面
  288   2          printf1("get set%d-%d",weizhi,zhi);
  289   2        }
  290   1      }
  291          void setzhione(int dizhi,int zhi)
  292          {
  293   1        char out[30]={0};
  294   1        sprintf(out,"set:%d-%d;end",dizhi,zhi);
  295   1        printf1(out);
  296   1      }
  297          void jiexi(char* input)
  298          {
  299   1        char par[500]={0};
  300   1        char *begin,end;
  301   1        begin=myaddstrstr(input,"set:");
  302   1        // printf1("input begin%s",begin);
  303   1        end=myaddstrstr(begin,"end");
*** WARNING C161 IN LINE 303 OF main.c: 'far' pointer truncated to 'char'
*** WARNING C10 IN LINE 303 OF main.c: conversion: 'pointer' to 'char'
  304   1        // printf1("input end%s",end);
  305   1        if(begin!=NULL && end!=NULL)
*** WARNING C40 IN LINE 305 OF main.c: 'char' converted to 'far' pointer
  306   1        {
  307   2          strcpy(par,begin);
  308   2          jixi2(par);
  309   2        }
  310   1      }
  311          int mainxx() {
  312   1      
  313   1        const char* haystack = "sdsdset:1234-2234;333-4;endsdsdsd";
  314   1        jiexi(haystack);
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:49:18  PAGE 6   

  315   1        
  316   1        setzhione(4,20);
  317   1      
  318   1        return 0;
  319   1      }
  320          
  321          
  322          int mainxx2() {
  323   1          const char* haystack = "Hello, world!";
  324   1          const char* needle = "world";
  325   1          char* result = mystrstr(haystack, needle);
  326   1      
  327   1          if (result != NULL) {
  328   2              printf("'%s' found in '%s' at index %ld\n", needle, haystack, result - haystack);
  329   2          } else {
  330   2              printf("'%s' not found in '%s'\n", needle, haystack);
  331   2          }
  332   1      
  333   1          return 0;
  334   1      }
  335          
  336          
  337          int mainxxx() {
  338   1          const char* str = "Hello, world!";
  339   1          size_t length = mystrlen(str);
  340   1          printf("Length of '%s' is %d\n", str, length);
  341   1          return 0;
  342   1      }
  343          
  344          
  345          void main(void)
  346          {
  347   1      
  348   1        SYS_Ini();    // STC32初始化设置
  349   1        PWM_Config(); // PWM初始化设置
  350   1        EA = 1;     // 使能EA总中断
  351   1      
  352   1        UartInit();
  353   1        // Uart23Init();
  354   1        printf1("system is ok");
  355   1        Timer0Init();
  356   1        mainxx();
  357   1        while (1)
  358   1        {
  359   2          showpre(gsetzhi);
  360   2          dealchuankou();
  361   2        }
  362   1      }
  363          
  364          void PWM_ISR() interrupt 26
  365          {
  366   1        if (PWMA_SR1 & 0X02) // 当捕获中断标志置1
  367   1        {
  368   2          cnt_H = PWMA_CCR1H; // 读取计数值高8位
  369   2          cnt_L = PWMA_CCR1L; // 读取计数值低8位
  370   2          PWMA_SR1 &= ~0X02;  // 清零捕获中断标志
  371   2          EC11_Handle();    // 处理EC11数据
  372   2        }
  373   1      }
  374          void PWM_Config() // PWM初始化设置
  375          {
  376   1        PWMA_CCER1 = 0x00; // 关闭通道
  377   1        PWMA_CCMR1 = 0xA1; // 通道模式配置为输入，接编码器 , 滤波器 80 时钟
  378   1        PWMA_CCMR2 = 0xA1; // 通道模式配置为输入，接编码器 , 滤波器 80 时钟
  379   1        PWMA_CCER1 = 0x55; // 使能捕获/比较通道1、通道2
  380   1      
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:49:18  PAGE 7   

  381   1        //  PWMA_SMCR = 0x01;         // 编码器模式 1
  382   1        //  PWMA_SMCR = 0x02;         // 编码器模式 2
  383   1        PWMA_SMCR = 0x03; // 编码器模式 3
  384   1      
  385   1        PWMA_IER = 0x02;  // 使能中断
  386   1        PWMA_CR1 |= 0x01; // 使能计数器
  387   1        PWMA_PS |= 0x04;  // 选择 PWM2_2 通道
  388   1      }
  389          
  390          // 返回变化的步数
  391          long calculateChange(unsigned int previous, unsigned int current)
  392          {
  393   1        long diff = (current - previous + 65536) % 65536;
*** WARNING C188 IN LINE 393 OF main.c: 'initialization': value truncated
  394   1        return diff;
  395   1      }
  396          
  397          char buf3[500];
  398          char flag3 = 0;
  399          int weishu3;
  400          int timeleft1, timeleft2, timeleft3, timeleft4;
  401          void chuankou1put(char c)
  402          {
  403   1        buf3[weishu3++] = c;
  404   1        if (weishu3 > sizeof(buf3) - 3)
  405   1          weishu3 = 0;
  406   1        timeleft3 = 3;
  407   1      }
  408          void chuankou1time()
  409          {
  410   1        if (timeleft3 > 0)
  411   1        {
  412   2          timeleft3--;
  413   2          if (timeleft3 == 0) // 数据一次收完了.
  414   2          {
  415   3            flag3 = 1;
  416   3          }
  417   2        }
  418   1      }
  419          void UARTInterrupt(void) interrupt 4
  420          {
  421   1        unsigned char ans;
  422   1        if (RI)
  423   1        {
  424   2          RI = 0;
  425   2          ans = SBUF;
  426   2          chuankou1put(ans);
  427   2          // IAP_CONTR=0x60;
  428   2        }
  429   1        else
  430   1        {
  431   2          TI = 0;
  432   2          
  433   2        }
  434   1        if (TI) // 发送中断..
  435   1        {
  436   2          TI = 0;
  437   2        }
  438   1      }
  439          
  440          void Timer0() interrupt 1
  441          {
  442   1        // gsetzhi++;
  443   1        chuankou1time();
  444   1      }
  445          void EC11_Handle() // EC11数据处理函数
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:49:18  PAGE 8   

  446          {
  447   1        static unsigned int previous = 0;
  448   1        unsigned int nowzhi;
  449   1        long ans;
  450   1        nowzhi = cnt_H * 256 + cnt_L; // 读取当前计数值
  451   1        ans = calculateChange(previous, nowzhi);
  452   1        previous = nowzhi;
  453   1        if (ans == 4)
  454   1        {
  455   2          gsetzhi++;
  456   2        }
  457   1        else
  458   1        {
  459   2          gsetzhi--;
  460   2        }
  461   1      }
  462          
  463          int step=0;
  464          void showstep(const char *s)
  465          {
  466   1        printf1("%s\n",s);
  467   1      }
  468          char* my_strstr(const char* haystack, const char* needle) {
  469   1          if (*needle == '\0') {
  470   2              return (char*) haystack;
  471   2          }
  472   1      
  473   1          while (*haystack != '\0') {
  474   2              const char* h = haystack;
  475   2              const char* n = needle;
  476   2      
  477   2              while (*h == *n && *n != '\0') {
  478   3                  h++;
  479   3                  n++;
  480   3              }
  481   2      
  482   2              if (*n == '\0') {
  483   3                  return (char*) haystack;
  484   3              }
  485   2      
  486   2              haystack++;
  487   2          }
  488   1      
  489   1          return NULL;
  490   1      }
  491          void dealchuankou()
  492          {
  493   1        if (flag3 == 1)
  494   1        {
  495   2          flag3 = 0;
  496   2          jiexi(buf3);
  497   2          memset(buf3, 0, sizeof(buf3));
  498   2          weishu3 = 0;
  499   2        }
  500   1      }
  501          
  502          // 写个函数，传入两个非负数，计算是前进还是后退了，变化规律 15,16,0,1,2...15,16


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1994     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       765        734
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:49:18  PAGE 9   

  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       993     ------
End of Module Information.


C251 COMPILATION COMPLETE.  8 WARNING(S),  0 ERROR(S)
