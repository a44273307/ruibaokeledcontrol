C51 COMPILER V9.05   MAIN                                                                  06/03/2023 21:26:09 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /************************************************************************************
   2             
   3          程序名称： （晶振频率18.432MHz） 
   4          功能说明: 通过串口3发送“Everything is possible!”  
   5                    波特率9600，数据位8，奇偶效验无，停止位1，数据流控制无  
   6          ************************************************************************************/
   7          #include "stc15f2k60s2.h"           // 单片机STC15F2K60S2头文件,可以不再加入reg51.h
   8          #include <intrins.h>                                    // 加入此头文件后,可使用_nop_库函数
   9          #include "delay.h"                      // 延时函数头文件
  10          #include "uart.h"                               // 串行通信函数头文件
  11          #define  uint unsigned int  
  12          #define  uchar unsigned char    
  13          #include <stdio.h>
  14          #include <string.h>
  15          #include "MODBUS.h"
  16          
  17          #include <stdio.h>
  18          #include <string.h>
  19          #include <stdlib.h>
  20          
  21          bit busy;
  22          
  23          uint weishu1,weishu2,weishu3,weishu4;
  24          
  25          uint temp1,temp2,temp3,temp4;
  26          
  27          
  28          
  29          
  30          //sbit x0 = P4^3;
  31          //sbit x1 = P4^4; 
  32          //sbit x2 = P2^0; 
  33          //sbit x3 = P2^1;  
  34          //sbit x4 = P2^2;  
  35          //sbit x5 = P2^3;
  36          //sbit x6 = P2^4; 
  37          //sbit x7 = P2^5;
  38          //sbit x10 = P2^6;
  39          //sbit x11 = P2^7; 
  40          //sbit x12 = P4^5;
  41          //sbit x13 = P4^6;
  42          
  43          sbit x0 = P2^4; 
  44          sbit x1 = P2^5; 
  45          
  46          
  47          sbit x2 = P2^6;  
  48          sbit x3 = P2^7;
  49          
  50          sbit x4 = P4^5; 
  51          sbit x5 = P4^6;
  52          
  53          sbit x6 = P0^2;
  54          sbit x7 = P0^3; 
  55          
C51 COMPILER V9.05   MAIN                                                                  06/03/2023 21:26:09 PAGE 2   

  56          sbit x8 = P0^4; 
  57          sbit x9 = P5^2;
  58          
  59          
  60          
  61          
  62          sbit y0 = P2^3;  
  63          sbit y1 = P2^2; 
  64          sbit y2 = P2^1;
  65          sbit y3 = P2^0;
  66          sbit y4 = P4^4;
  67          sbit y5 = P4^3;
  68          
  69          
  70          
  71          void printf2(char *puts)
  72          {
  73   1               while(*puts) 
  74   1              {
  75   2                      sendbyte2(*puts);
  76   2                      puts++;
  77   2              }
  78   1      }
  79          
  80          void io_inint()
  81          {
  82   1              P0M1 = 0;       P0M0 = 0;       //设置P0.0~P0.7为准双向口
  83   1                  P1M0 = 0x00;                                //设置P1.0为ADC口
  84   1          P1M1 = 0x80;
  85   1      
  86   1      
  87   1              // P1M1 = 0;    P1M0 = 0;       //设置P1.0~P1.7为准双向口
  88   1              P2M1 = 0;       P2M0 = 0;       //设置P2.0~P2.7为准双向口 
  89   1                  P3M0 = 0;
  90   1          P3M1 = 0;
  91   1              P4M1 = 0;       P4M0 = 0;       //设置P4.0~P4.7为准双向口
  92   1              P5M1 = 0;       P5M0 = 0;       //设置P5.0~P5.7为准双向口
  93   1      }
  94          
  95          
  96          
  97          
  98          int xinget(int zhi)
  99          {
 100   1              if(zhi==0) return x0;
 101   1              if(zhi==1) return x1;
 102   1              if(zhi==2) return x2;
 103   1              if(zhi==3) return x3;
 104   1              if(zhi==4) return x4;
 105   1              if(zhi==5) return x5;
 106   1              if(zhi==6) return x6;
 107   1              if(zhi==7) return x7;
 108   1              if(zhi==8) return x8;
 109   1              if(zhi==9) return x9;
 110   1      }
 111          void getxin()
 112          {
 113   1              int i;
 114   1              char datatmp[10];
 115   1              for(i=0;i<10;i++)
 116   1              {
 117   2                      sprintf(datatmp,"x%d %d\n",i,xinget(i));
C51 COMPILER V9.05   MAIN                                                                  06/03/2023 21:26:09 PAGE 3   

 118   2                      PrintString(datatmp);
 119   2              }
 120   1      }
 121          void Delay1ms()         //@24.000MHz
 122          {
 123   1              unsigned char i, j;
 124   1      
 125   1              i = 24;
 126   1              j = 85;
 127   1              do
 128   1              {
 129   2                      while (--j);
 130   2              } while (--i);
 131   1      }
 132          
 133          void delay_ms(int m)
 134          {
 135   1              int x;
 136   1              for(x=m;x>0;x--)
 137   1              {
 138   2                      Delay1ms();
 139   2              }
 140   1              
 141   1      }
 142          void Start()
 143          {uint i=0;
 144   1          busy = 1;
 145   1          I2CMSCR = 0x81;                             //发送START命令
 146   1          while (busy&&i<6000)i++;
 147   1      }
 148          
 149          void SendData(char dat)
 150          {uint i=0;
 151   1          I2CTXD = dat;                               //写数据到数据缓冲区
 152   1          busy = 1;
 153   1          I2CMSCR = 0x82;                             //发送SEND命令
 154   1          while (busy&&i<6000)i++;
 155   1      }
 156          
 157          void RecvACK()
 158          {uint i=0;
 159   1          busy = 1;
 160   1          I2CMSCR = 0x83;                             //发送读ACK命令
 161   1          while (busy&&i<6000)i++;
 162   1      }
 163          
 164          char RecvData()
 165          {uint i=0;
 166   1          busy = 1;
 167   1          I2CMSCR = 0x84;                             //发送RECV命令
 168   1          while (busy&&i<6000)i++;
 169   1          return I2CRXD;
 170   1      }
 171          
 172          void SendACK()
 173          {uint i=0;
 174   1          I2CMSST = 0x00;                             //设置ACK信号
 175   1          busy = 1;
 176   1          I2CMSCR = 0x85;                             //发送ACK命令
 177   1          while (busy&&i<6000)i++;
 178   1      }
 179          
C51 COMPILER V9.05   MAIN                                                                  06/03/2023 21:26:09 PAGE 4   

 180          void SendNAK()
 181          {uint i=0;
 182   1          I2CMSST = 0x01;                             //设置NAK信号
 183   1          busy = 1;
 184   1          I2CMSCR = 0x85;                             //发送ACK命令
 185   1          while (busy&&i<6000)i++;
 186   1      }
 187          
 188          void Stop()
 189          {uint i=0;
 190   1          busy = 1;
 191   1          I2CMSCR = 0x86;                             //发送STOP命令
 192   1          while (busy&&i<6000)i++;
 193   1      }
 194          void I2C_Isr() interrupt 24
 195          {
 196   1          _push_(P_SW2);
 197   1          P_SW2 |= 0x80;
 198   1          if (I2CMSST & 0x40)
 199   1          {
 200   2              I2CMSST &= ~0x40;                       //清中断标志
 201   2              busy = 0;
 202   2          }
 203   1          _pop_(P_SW2);
 204   1      }
 205          sbit out1=P1^6;  //
 206          sbit out2=P3^2;
 207          void deanyan()
 208           {  
 209   1              int sw1=2000;
 210   1              int sw2=3000;
 211   1              Start();                                    //发送起始命令
 212   1          SendData(0xc2);                             //发送设备地址+写命令
 213   1          RecvACK();
 214   1          SendData(0x60);                             //发送存储地址高字节
 215   1          RecvACK();
 216   1          SendData(sw1/16);                             //发送存储地址低字节
 217   1          RecvACK();
 218   1          SendData((sw1%16)<<4);                             //写测试数据1
 219   1          RecvACK();
 220   1          Stop();                                     //发送停止命令
 221   1      
 222   1          Start();                                    //发送起始命令
 223   1          SendData(0xc0);                             //发送设备地址+写命令
 224   1          RecvACK();
 225   1          SendData(0x60);                             //发送存储地址高字节
 226   1          RecvACK();
 227   1          SendData(sw2/16);                             //发送存储地址低字节
 228   1          RecvACK();
 229   1          SendData((sw2%16)<<4);                             //写测试数据1
 230   1          RecvACK();
 231   1          Stop();
 232   1                      
 233   1                      Start();                                    //发送起始命令
 234   1          SendData(0xc2);                             //发送设备地址+写命令
 235   1          RecvACK();
 236   1          SendData(0x60);                             //发送存储地址高字节
 237   1          RecvACK();
 238   1          SendData(sw1/16);                             //发送存储地址低字节
 239   1          RecvACK();
 240   1          SendData((sw1%16)<<4);                             //写测试数据1
 241   1          RecvACK();
C51 COMPILER V9.05   MAIN                                                                  06/03/2023 21:26:09 PAGE 5   

 242   1          Stop();                                     //发送停止命令
 243   1      
 244   1          Start();                                    //发送起始命令
 245   1          SendData(0xc0);                             //发送设备地址+写命令
 246   1          RecvACK();
 247   1          SendData(0x60);                             //发送存储地址高字节
 248   1          RecvACK();
 249   1          SendData(sw2/16);                             //发送存储地址低字节
 250   1          RecvACK();
 251   1          SendData((sw2%16)<<4);                             //写测试数据1
 252   1          RecvACK();
 253   1          Stop();
 254   1              
 255   1                        
 256   1       }
 257          void main()                                                    
 258          {
 259   1              
 260   1              io_inint();
 261   1              Uart23Init();
 262   1              
 263   1              
 264   1              Timer0Init();
 265   1              UartInit();
 266   1              
 267   1              Uart4Init();
 268   1              PrintString("system is ok\n");
 269   1              P_SW2 = 0x80;
 270   1          I2CCFG = 0xe0;                              //使能I2C主机模式
 271   1          I2CMSST = 0x00;
 272   1               EA = 1;
 273   1              out2=1;
 274   1              delay_ms(10);
 275   1              Modbus_ClearBuff();
 276   1      delay_ms(200);
 277   1      deanyan();
 278   1              while (1)
 279   1              {
 280   2                      delay_ms(2);
 281   2                      // printf("0000000000");
 282   2                      if(recover==1)
 283   2                      {
 284   3                              // deanyan();
 285   3                              jishouokjisuan();
 286   3                              recover=0;
 287   3                      }
 288   2              }
 289   1      }
 290                   
 291                   
 292          
 293                   
 294                   
 295          uint time,lv_bo;
 296          void Timer0() interrupt 1
 297          {
 298   1              time1msjisuan();
 299   1      }
 300          void UARTInterrupt(void) interrupt 4
 301          {
 302   1              unsigned char ans;
 303   1              if (RI)
C51 COMPILER V9.05   MAIN                                                                  06/03/2023 21:26:09 PAGE 6   

 304   1              {
 305   2                      RI = 0;
 306   2                      ans=SBUF;
 307   2                      chuankou1jisuuan(ans);
 308   2              }
 309   1              else
 310   1              {
 311   2                      TI = 0;
 312   2              }
 313   1              if (TI) //发送中断..
 314   1              {
 315   2                      TI = 0;
 316   2              }
 317   1      }
 318          
 319          void uart2(void ) interrupt 8 
 320          {
 321   1        if (S2CON & S2RI)
 322   1              {
 323   2                      S2CON &= ~S2RI;         
 324   2                      temp2 = S2BUF;
 325   2              }
 326   1        if (S2CON & S2TI)
 327   1          {
 328   2                              //y1=0;
 329   2              S2CON &= ~S2TI;         //清除S2TI位
 330   2              busy2 = 0;               //清忙标志
 331   2          }  
 332   1      }
 333          
 334            
 335          
 336          
 337          void Uart3() interrupt 17 using 1
 338          {
 339   1          if (S3CON & S3RI)
 340   1          {
 341   2              S3CON &= ~S3RI;         //??S3RI?
 342   2              temp3 = S3BUF;
 343   2                                      
 344   2         }
 345   1      if (S3CON & S3TI)
 346   1          {
 347   2              S3CON &= ~S3TI;         //清除S3TI位
 348   2              busy3 = 0;               //清忙标志
 349   2          }
 350   1      }
 351          
 352          void Uart4() interrupt 18 
 353          {
 354   1          if (S4CON & S4RI)
 355   1          {
 356   2              S4CON &= ~S4RI;         //??S4RI?
 357   2              temp4=S4BUF;
 358   2         }
 359   1      if(TI4)
 360   1              {
 361   2                      CLR_TI4();
 362   2                      busy4 = 0;               //清忙标志
 363   2              }
 364   1      }
 365          
C51 COMPILER V9.05   MAIN                                                                  06/03/2023 21:26:09 PAGE 7   

 366          
 367          
*** WARNING C291 IN LINE 110 OF main.c: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1123    ----
   CONSTANT SIZE    =     22    ----
   XDATA SIZE       =     20      17
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
