C51 COMPILER V9.00   MAIN                                                                  07/27/2023 07:51:47 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil2\C51\BIN\C51.EXE main.c LARGE ROM(COMPACT) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /************************************************************************************
   2             
   3          程序名称： （晶振频率18.432MHz） 
   4          功能说明: 通过串口3发送“Everything is possible!”  
   5                    波特率9600，数据位8，奇偶效验无，停止位1，数据流控制无  
   6          ************************************************************************************/
   7          #include "stc15f2k60s2.h"           // 单片机STC15F2K60S2头文件,可以不再加入reg51.h
   8          #include <intrins.h>                                    // 加入此头文件后,可使用_nop_库函数
   9          #include "delay.h"                      // 延时函数头文件
  10          #include "uart.h"                               // 串行通信函数头文件
  11          #define  uint unsigned int  
  12          #define  uchar unsigned char    
  13          #include <stdio.h>
  14          #include <string.h>
  15          #include "MODBUS.h"
  16          
  17          #include <stdio.h>
  18          #include <string.h>
  19          #include <stdlib.h>
  20          #include "tongxin2.h"
  21          
  22          char buf3[60];
  23          char flag3 = 0;
  24          int weishu3;
  25          int timeleft1, timeleft2, timeleft3, timeleft4;
  26          void com1clearbuf()
  27          {
  28   1          memset(buf3, 0, sizeof(buf3));
  29   1              weishu3 = 0;
  30   1      }
  31          void chuankou1put(char c)
  32          {
  33   1              buf3[weishu3++] = c;
  34   1              if (weishu3 > sizeof(buf3) - 3)
  35   1                      weishu3 = 0;
  36   1              timeleft3 = 3;
  37   1      }
  38          void dealchuankou();    
  39          void chuliguankji();
  40          void chuankou1time()
  41          {
  42   1              if (timeleft3 > 0)
  43   1              {
  44   2                      timeleft3--;
  45   2                      if (timeleft3 == 0) // 数据一次收完了.
  46   2                      {
  47   3                              flag3 = 1;
  48   3                  dealchuankou();     
  49   3                      }
  50   2              }
  51   1      }
  52          
  53          
  54          
  55          
C51 COMPILER V9.00   MAIN                                                                  07/27/2023 07:51:47 PAGE 2   

  56          char* mystrstr(const char* haystack, const char* needle) {
  57   1          if (*needle == '\0') {
  58   2              return (char*)haystack;
  59   2          }
  60   1      
  61   1          while (*haystack != '\0') {
  62   2              const char* h = haystack;
  63   2              const char* n = needle;
  64   2      
  65   2              while (*n != '\0' && *h == *n) {
  66   3                  h++;
  67   3                  n++;
  68   3              }
  69   2      
  70   2              if (*n == '\0') {
  71   3                  return (char*)haystack; // 子串匹配成功，返回起始位置
  72   3              }
  73   2      
  74   2              haystack++;
  75   2          }
  76   1      
  77   1          return NULL; // 未找到子串，返回NULL
  78   1      }
  79          size_t mystrlen(const char* str) {
  80   1          size_t length = 0;
  81   1          while (str[length] != '\0') {
  82   2              length++;
  83   2          }
  84   1          return length;
  85   1      }
  86          
  87          char* myaddstrstr(const char* haystack, const char* needle)
  88          {       
  89   1              char* result = mystrstr(haystack, needle);
  90   1               if (result != NULL)
  91   1               {
  92   2                      result=result+mystrlen(needle);
  93   2               }
  94   1               return result;
  95   1      }
  96          void jixi2(char* input)
  97          {
  98   1              char *p=input;
  99   1              char *p1;
 100   1              int i;
 101   1              unsigned int weizhi;
 102   1              unsigned int zhi;
 103   1              //1234-2234;333-4;end
 104   1          printf("input %s",input);
 105   1              for( i=0;i<100;i++)
 106   1              {
 107   2                      p1=myaddstrstr(p,";"); //找有没有下一个的
 108   2                      if(p1==NULL)
 109   2                      {
 110   3                              break;
 111   3                      }
 112   2                      weizhi = atoi(p);
 113   2                      p=myaddstrstr(p,"-");
 114   2                      zhi = atoi(p);
 115   2              printf("get set%d-%d",weizhi,zhi);
 116   2              push2(weizhi,zhi);
 117   2                      p=myaddstrstr(p,";");  //指向下一个后面
C51 COMPILER V9.00   MAIN                                                                  07/27/2023 07:51:47 PAGE 3   

 118   2                      
 119   2              }
 120   1      }
 121          void jiexi(char* input)
 122          {
 123   1              char par[100]={0};
 124   1              char *begin;
 125   1              char *end;
 126   1              begin=myaddstrstr(input,"set:");
 127   1              // printf("input begin%s",begin);
 128   1              end=myaddstrstr(begin,"end");
 129   1              // printf("input end%s",end);
 130   1              if(begin!=NULL && end!=NULL)
 131   1              {
 132   2                      strcpy(par,begin);
 133   2                      jixi2(par);
 134   2              }
 135   1      }
 136          
 137          char* my_strstr(const char* haystack, const char* needle) {
 138   1          if (*needle == '\0') {
 139   2              return (char*) haystack;
 140   2          }
 141   1      
 142   1          while (*haystack != '\0') {
 143   2              const char* h = haystack;
 144   2              const char* n = needle;
 145   2      
 146   2              while (*h == *n && *n != '\0') {
 147   3                  h++;
 148   3                  n++;
 149   3              }
 150   2      
 151   2              if (*n == '\0') {
 152   3                  return (char*) haystack;
 153   3              }
 154   2      
 155   2              haystack++;
 156   2          }
 157   1      
 158   1          return NULL;
 159   1      }
 160          
 161          // 串口的处理，，开机，解析等等。
 162          void dealchuankou()
 163          {
 164   1          chuliguankji();
 165   1              jiexi(buf3);
 166   1              memset(buf3, 0, sizeof(buf3));
 167   1              weishu3 = 0;
 168   1      }
 169          
 170          
 171          
 172          
 173          
 174          
 175          
 176          
 177          
 178          
 179          
C51 COMPILER V9.00   MAIN                                                                  07/27/2023 07:51:47 PAGE 4   

 180          
 181          
 182          
 183          
 184          int delay_mszhi;
 185          uint temp1,temp2,temp3,temp4;
 186          
 187          
 188          void io_inint()
 189          {
 190   1              P0M1 = 0;       P0M0 = 0;       //设置P0.0~P0.7为准双向口
 191   1        P1M0 = 0x00; // 设置P1.0为ADC口
 192   1        P1M1 = 0x80;
 193   1              P2M1 = 0;       P2M0 = 0;       //设置P2.0~P2.7为准双向口 
 194   1                  P3M0 = 0;
 195   1          P3M1 = 0;
 196   1              P4M1 = 0;       P4M0 = 0;       //设置P4.0~P4.7为准双向口
 197   1              // P5M1 = 0;    P5M0 = 0;       //设置P5.0~P5.7为准双向口
 198   1      
 199   1                  P5M0 = 0xff; P5M1 = 0x00; 
 200   1      
 201   1      }
 202          
 203          
 204          void delay_ms(int m);
 205          
 206          
 207          
 208          sbit out2=P3^2;
 209          
 210          extern void deanyan();
 211          sbit fen=P5^4;
 212          
 213          #define Iapid 0x0000
 214          uchar p1, a_a;
 215          void IapIdle()
 216          {
 217   1        IAP_CONTR = 0;    // ??±?IAP????
 218   1        IAP_CMD = 0;      // ?????ü???????÷
 219   1        IAP_TRIG = 0;     // ??????・??????÷
 220   1        IAP_ADDRH = 0x80; // ?????・?è????・?IAP???ò
 221   1        IAP_ADDRL = 0;
 222   1      }
 223          
 224          uint8_t IapRead(int addr)
 225          {
 226   1        uint8_t dat;
 227   1      
 228   1        IAP_CONTR = 0x80;      // ????IAP
 229   1        IAP_TPS = 40;          // ?è??????????12MHz
 230   1        IAP_CMD = 1;           // ?è??IAP???ü??
 231   1        IAP_ADDRL = addr;      // ?è??IAP?????・
 232   1        IAP_ADDRH = addr >> 8; // ?è??IAP?????・
 233   1        IAP_TRIG = 0x5a;       // ????・??ü??(0x5a)
 234   1        IAP_TRIG = 0xa5;       // ????・??ü??(0xa5)
 235   1        _nop_();
 236   1        dat = IAP_DATA; // ??IAP????
 237   1        IapIdle();      // ??±?IAP????
 238   1      
 239   1        return dat;
 240   1      }
 241          
C51 COMPILER V9.00   MAIN                                                                  07/27/2023 07:51:47 PAGE 5   

 242          void IapProgram(int addr, char dat)
 243          {
 244   1        IAP_CONTR = 0x80;      // ????IAP
 245   1        IAP_TPS = 40;          // ?è??????????12MHz
 246   1        IAP_CMD = 2;           // ?è??IAP???ü??
 247   1        IAP_ADDRL = addr;      // ?è??IAP?????・
 248   1        IAP_ADDRH = addr >> 8; // ?è??IAP?????・
 249   1        IAP_DATA = dat;        // ??IAP????
 250   1        IAP_TRIG = 0x5a;       // ????・??ü??(0x5a)
 251   1        IAP_TRIG = 0xa5;       // ????・??ü??(0xa5)
 252   1        _nop_();
 253   1        IapIdle(); // ??±?IAP????
 254   1      }
 255          
 256          void IapErase(int addr)
 257          {
 258   1        IAP_CONTR = 0x80;      // ????IAP
 259   1        IAP_TPS = 40;          // ?è??????????12MHz
 260   1        IAP_CMD = 3;           // ?è??IAP?????ü??
 261   1        IAP_ADDRL = addr;      // ?è??IAP?????・
 262   1        IAP_ADDRH = addr >> 8; // ?è??IAP?????・
 263   1        IAP_TRIG = 0x5a;       // ????・??ü??(0x5a)
 264   1        IAP_TRIG = 0xa5;       // ????・??ü??(0xa5)
 265   1        _nop_();               //
 266   1        IapIdle();             // ??±?IAP????
 267   1      }
 268          
 269          //
 270          void write_eeprom()
 271          {
 272   1        IapErase(Iapid); // ????????
 273   1        IapProgram(Iapid + 1, p1);
 274   1      
 275   1        IapProgram(Iapid + 60, a_a);
 276   1      }
 277          /******************°????????????ú????eeprom????????*****************/
 278          void read_eeprom()
 279          {
 280   1        
 281   1        p1 = IapRead(Iapid + 1);
 282   1        a_a = IapRead(Iapid + 60);
 283   1      }
 284          /**************???ú×??ìeeprom??????*****************/
 285          void init_eeprom()
 286          {
 287   1        read_eeprom();
 288   1        if (a_a != 6) // ?????????ú?????????ú????eeprom
 289   1        {
 290   2      
 291   2          p1 = 0;
 292   2          a_a = 6;
 293   2      
 294   2          write_eeprom(); // ±???????
 295   2        }
 296   1      }
 297          void Exxwrite(int addr, uint dat)
 298          {
 299   1          // IapErase(Iapid); // ????????
 300   1          addr=addr*2;
 301   1          IapProgram(addr,dat/256);
 302   1          IapProgram(addr+1,dat%256);
 303   1      }
C51 COMPILER V9.00   MAIN                                                                  07/27/2023 07:51:47 PAGE 6   

 304          uint ExxRead(int addr)
 305          {
 306   1          uint dat;
 307   1          addr=addr*2;
 308   1          dat=IapRead(addr);
 309   1          dat=dat*256;
 310   1          dat=dat+IapRead(addr+1);
 311   1          return dat;
 312   1      }
 313          void writebuf();
 314          void initbuf()
 315          {
 316   1          int i;
 317   1          uint zhi;
 318   1          int dizhi=Iapid+1;
 319   1          
 320   1          for ( i = 0; i < len_HoldingReg; i++)
 321   1          {
 322   2              HoldingReg[i]=0;
 323   2          }
 324   1          zhi=ExxRead(dizhi);
 325   1          // printf("errprom init zhi%d",zhi);
 326   1          if(123!=zhi)//没有初始化，初始化一次。。
 327   1          {
 328   2              printf("IS FISRTINIT\n");
 329   2              Exxwrite(dizhi,123);
 330   2              writebuf();
 331   2          }
 332   1          else
 333   1          {
 334   2              printf("IS not FISRTINIT\n");
 335   2          }
 336   1          for ( i = 0; i < len_HoldingReg; i++)
 337   1          {
 338   2              dizhi=dizhi+1;
 339   2              HoldingReg[i]=ExxRead(dizhi);
 340   2              delay_ms(4);
 341   2              // if(0!=HoldingReg[i] && -1 !=HoldingReg[i])
 342   2              // {
 343   2                  printf("HoldingReg[%d]-[%d]\n",i,HoldingReg[i]);
 344   2              // }
 345   2          }
 346   1      }
 347          void writebuf()
 348          {
 349   1          int i;
 350   1          int dizhi=Iapid+1;
 351   1          for ( i = 0; i < len_HoldingReg; i++)
 352   1          {
 353   2              dizhi=dizhi+1;
 354   2              Exxwrite(dizhi,HoldingReg[i]);
 355   2              delay_ms(4);
 356   2          }
 357   1      }
 358          // 比较值是否发生了变化。。
 359          uint16_t bufcheck[len_HoldingReg]={0};
 360          void buffchecktongbu()
 361          {
 362   1          int i;
 363   1          for ( i = 0; i < len_HoldingReg; i++)
 364   1          {
 365   2              bufcheck[i]=HoldingReg[i];
C51 COMPILER V9.00   MAIN                                                                  07/27/2023 07:51:47 PAGE 7   

 366   2          }
 367   1      }
 368          int IsbuffcheckFailed()
 369          {
 370   1          int i;
 371   1          for ( i = 0; i < len_HoldingReg; i++)
 372   1          {
 373   2             if(bufcheck[i]!=HoldingReg[i])
 374   2             {
 375   3                return 1;
 376   3             }
 377   2          }
 378   1          return 0;
 379   1      }
 380          
 381          int timereport=0;
 382          void sendzhi(int weizhi,int zhi)
 383          {
 384   1          char out[30]={0};
 385   1          sprintf(out,"set:%d-%d;end",weizhi,zhi);
 386   1              printf(out);
 387   1      }
 388          void runreport()
 389          {
 390   1          if(timereport>300)
 391   1          {
 392   2              timereport=0;
 393   2              sendzhi(4,HoldingReg[4]);
 394   2          }
 395   1      }
 396          void chuliguankji()
 397          {
 398   1          char* index;
 399   1          index=strstr(buf3,"@STCISP#");
 400   1              if(index==NULL)
 401   1              {
 402   2                  return  ;
 403   2              }
 404   1          IAP_CONTR=0x60;
 405   1      }
 406          void getzhiandchange()
 407          {
 408   1          int weizhi,zhi;
 409   1          Alltongxininfo2 get={0};
 410   1          pop22(&get);
 411   1          if(get.weizhi==0)
 412   1          {
 413   2              return ;
 414   2          }
 415   1          weizhi=get.weizhi;
 416   1          zhi=get.zhi;
 417   1          printf("getzhiandchange weizhi[%d] zhi[%d]\n",weizhi,zhi);
 418   1          if(weizhi<len_HoldingReg)
 419   1          {
 420   2              HoldingReg[weizhi]=zhi;
 421   2          }
 422   1          if(weizhi==4 || weizhi==2)
 423   1              {
 424   2                      deanyan();
 425   2              }
 426   1          if(IsbuffcheckFailed())
 427   1          {
C51 COMPILER V9.00   MAIN                                                                  07/27/2023 07:51:47 PAGE 8   

 428   2              printf("xiugaidata begin\n");
 429   2              delay_mszhi=0;
 430   2              buffchecktongbu();
 431   2              writebuf();
 432   2              printf("xiugaidata end %d\n",delay_mszhi);
 433   2          }
 434   1      }
 435          void test2()
 436          {
 437   1        IapErase(Iapid); // ????????
 438   1        IapProgram(Iapid + 1, 3);
 439   1      
 440   1      //   IapProgram(Iapid + 60, a_a);
 441   1      }
 442          void main()                                                    
 443          {
 444   1              io_inint();
 445   1          UartInit();
 446   1              Uart23Init();
 447   1              Timer0Init();
 448   1              Uart4Init();
 449   1              P_SW2 = 0x80;
 450   1          I2CCFG = 0xe0;                              //使能I2C主机模式
 451   1          I2CMSST = 0x00;
 452   1              EA = 1;
 453   1              out2=1;
 454   1              Modbus_ClearBuff();
 455   1          deanyan();
 456   1              delay_ms(100);
 457   1          printf("system init ok\n");
 458   1          initbuf();
 459   1          buffchecktongbu();
 460   1          printf("system init ok1");
 461   1          HoldingReg[2]=1;
 462   1          com1clearbuf();
 463   1          while (1)
 464   1              {
 465   2              // runreport();
 466   2              getzhiandchange();
 467   2              }
 468   1      } 
 469          int delay_mszhi;         
 470          uint time,lv_bo;
 471          void delay_ms(int m)
 472          {
 473   1          delay_mszhi=0;
 474   1          while (delay_mszhi<=m*2)
 475   1          {
 476   2              
 477   2          }
 478   1      }
 479          void Timer0() interrupt 1
 480          {
 481   1          chuankou1time();
 482   1              delay_mszhi++;
 483   1          timereport++;
 484   1      }
 485          void UARTInterrupt(void) interrupt 4
 486          {
 487   1              unsigned char ans;
 488   1              if (RI)
 489   1              {
C51 COMPILER V9.00   MAIN                                                                  07/27/2023 07:51:47 PAGE 9   

 490   2                      RI = 0;
 491   2                      ans=SBUF;
 492   2              chuankou1put(ans);
 493   2              }
 494   1              else
 495   1              {
 496   2                      TI = 0;
 497   2              }
 498   1              if (TI) //发送中断..
 499   1              {
 500   2                      TI = 0;
 501   2              }
 502   1      }
 503          
 504          void uart2(void ) interrupt 8 
 505          {
 506   1        if (S2CON & S2RI)
 507   1              {
 508   2                      S2CON &= ~S2RI;         
 509   2                      temp2 = S2BUF;
 510   2              }
 511   1        if (S2CON & S2TI)
 512   1          {
 513   2                              //y1=0;
 514   2              S2CON &= ~S2TI;         //清除S2TI位
 515   2              busy2 = 0;               //清忙标志
 516   2          }  
 517   1      }
 518          
 519            
 520          
 521          
 522          void Uart3() interrupt 17 using 1
 523          {
 524   1          if (S3CON & S3RI)
 525   1          {
 526   2              S3CON &= ~S3RI;         //??S3RI?
 527   2              temp3 = S3BUF;
 528   2                                      
 529   2         }
 530   1      if (S3CON & S3TI)
 531   1          {
 532   2              S3CON &= ~S3TI;         //清除S3TI位
 533   2              busy3 = 0;               //清忙标志
 534   2          }
 535   1      }
 536          
 537          void Uart4() interrupt 18 
 538          {
 539   1          if (S4CON & S4RI)
 540   1          {
 541   2              S4CON &= ~S4RI;         //??S4RI?
 542   2              temp4=S4BUF;
 543   2         }
 544   1      if(TI4)
 545   1              {
 546   2                      CLR_TI4();
 547   2                      busy4 = 0;               //清忙标志
 548   2              }
 549   1      }


C51 COMPILER V9.00   MAIN                                                                  07/27/2023 07:51:47 PAGE 10  

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2637    ----
   CONSTANT SIZE    =    352    ----
   XDATA SIZE       =    109     217
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
