C51 COMPILER V9.00   MAIN                                                                  08/06/2023 20:18:59 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil2\C51\BIN\C51.EXE main.c LARGE ROM(COMPACT) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /************************************************************************************
   2             
   3          程序名称： （晶振频率18.432MHz） 
   4          功能说明: 通过串口3发送“Everything is possible!”  
   5                    波特率9600，数据位8，奇偶效验无，停止位1，数据流控制无  
   6          ************************************************************************************/
   7          #include "stc15f2k60s2.h"           // 单片机STC15F2K60S2头文件,可以不再加入reg51.h
   8          #include <intrins.h>                                    // 加入此头文件后,可使用_nop_库函数
   9          #include "delay.h"                      // 延时函数头文件
  10          #include "uart.h"                               // 串行通信函数头文件
  11          #define  uint unsigned int  
  12          #define  uchar unsigned char    
  13          #include <stdio.h>
  14          #include <string.h>
  15          #include "MODBUS.h"
  16          
  17          #include <stdio.h>
  18          #include <string.h>
  19          #include <stdlib.h>
  20          #include "tongxin2.h"
  21          #include "EEPROM.h"
  22          char buf3[60];
  23          char flag3 = 0;
  24          int weishu3;
  25          int timeleft1, timeleft2, timeleft3, timeleft4;
  26          void com1clearbuf()
  27          {
  28   1          memset(buf3, 0, sizeof(buf3));
  29   1              weishu3 = 0;
  30   1      }
  31          void chuankou1put(char c)
  32          {
  33   1              buf3[weishu3++] = c;
  34   1              if (weishu3 > sizeof(buf3) - 3)
  35   1                      weishu3 = 0;
  36   1              timeleft3 = 3;
  37   1      }
  38          void dealchuankou();    
  39          void chuliguankji();
  40          void chuankou1time()
  41          {
  42   1              if (timeleft3 > 0)
  43   1              {
  44   2                      timeleft3--;
  45   2                      if (timeleft3 == 0) // 数据一次收完了.
  46   2                      {
  47   3                              flag3 = 1;
  48   3                  dealchuankou();     
  49   3                      }
  50   2              }
  51   1      }
  52          
  53          
  54          
  55          
C51 COMPILER V9.00   MAIN                                                                  08/06/2023 20:18:59 PAGE 2   

  56          char* mystrstr(const char* haystack, const char* needle) {
  57   1          if (*needle == '\0') {
  58   2              return (char*)haystack;
  59   2          }
  60   1      
  61   1          while (*haystack != '\0') {
  62   2              const char* h = haystack;
  63   2              const char* n = needle;
  64   2      
  65   2              while (*n != '\0' && *h == *n) {
  66   3                  h++;
  67   3                  n++;
  68   3              }
  69   2      
  70   2              if (*n == '\0') {
  71   3                  return (char*)haystack; // 子串匹配成功，返回起始位置
  72   3              }
  73   2      
  74   2              haystack++;
  75   2          }
  76   1      
  77   1          return NULL; // 未找到子串，返回NULL
  78   1      }
  79          size_t mystrlen(const char* str) {
  80   1          size_t length = 0;
  81   1          while (str[length] != '\0') {
  82   2              length++;
  83   2          }
  84   1          return length;
  85   1      }
  86          
  87          char* myaddstrstr(const char* haystack, const char* needle)
  88          {       
  89   1              char* result = mystrstr(haystack, needle);
  90   1               if (result != NULL)
  91   1               {
  92   2                      result=result+mystrlen(needle);
  93   2               }
  94   1               return result;
  95   1      }
  96          int bakweizhi;
  97          int bakzhi;
  98          void jixi2(char* input)
  99          {
 100   1              char *p=input;
 101   1              char *p1;
 102   1              int i;
 103   1              unsigned int weizhi;
 104   1              unsigned int zhi;
 105   1              //554-2234;333-4;end
 106   1          printf("input %s",input);
 107   1              for( i=0;i<100;i++)
 108   1              {
 109   2                      p1=myaddstrstr(p,";"); //找有没有下一个的
 110   2                      if(p1==NULL)
 111   2                      {
 112   3                              break;
 113   3                      }
 114   2                      weizhi = atoi(p);
 115   2                      p=myaddstrstr(p,"-");
 116   2                      zhi = atoi(p);
 117   2              if(i%2==0)
C51 COMPILER V9.00   MAIN                                                                  08/06/2023 20:18:59 PAGE 3   

 118   2              {
 119   3                  bakweizhi=weizhi;
 120   3                  bakzhi=zhi;
 121   3              }
 122   2              if(i%2==1)
 123   2              {
 124   3                  if(weizhi==bakweizhi && bakzhi==zhi)
 125   3                  {
 126   4                      printf("get set%d-%d",weizhi,zhi);
 127   4                      push2(weizhi,zhi);
 128   4                  }
 129   3                  else
 130   3                  {
 131   4                      printf("get failed");
 132   4                  }
 133   3              }
 134   2                      p=myaddstrstr(p,";");  //指向下一个后面
 135   2                      
 136   2              }
 137   1      }
 138          void jiexi(char* input)
 139          {
 140   1              char par[100]={0};
 141   1              char *begin;
 142   1              char *end;
 143   1              begin=myaddstrstr(input,"set:");
 144   1              // printf("input begin%s",begin);
 145   1              end=myaddstrstr(begin,"end");
 146   1              // printf("input end%s",end);
 147   1              if(begin!=NULL && end!=NULL)
 148   1              {
 149   2                      strcpy(par,begin);
 150   2                      jixi2(par);
 151   2              }
 152   1      }
 153          
 154          char* my_strstr(const char* haystack, const char* needle) {
 155   1          if (*needle == '\0') {
 156   2              return (char*) haystack;
 157   2          }
 158   1      
 159   1          while (*haystack != '\0') {
 160   2              const char* h = haystack;
 161   2              const char* n = needle;
 162   2      
 163   2              while (*h == *n && *n != '\0') {
 164   3                  h++;
 165   3                  n++;
 166   3              }
 167   2      
 168   2              if (*n == '\0') {
 169   3                  return (char*) haystack;
 170   3              }
 171   2      
 172   2              haystack++;
 173   2          }
 174   1      
 175   1          return NULL;
 176   1      }
 177          
 178          // 串口的处理，，开机，解析等等。
 179          void dealchuankou()
C51 COMPILER V9.00   MAIN                                                                  08/06/2023 20:18:59 PAGE 4   

 180          {
 181   1          chuliguankji();
 182   1              jiexi(buf3);
 183   1              memset(buf3, 0, sizeof(buf3));
 184   1              weishu3 = 0;
 185   1      }
 186          
 187          
 188          int delay_mszhi;
 189          uint temp1,temp2;
 190          
 191          
 192          void io_inint()
 193          {
 194   1              P0M1 = 0;       P0M0 = 0;       //设置P0.0~P0.7为准双向口
 195   1        P1M0 = 0x00; // 设置P1.0为ADC口
 196   1        P1M1 = 0x80;
 197   1              P2M1 = 0;       P2M0 = 0;       //设置P2.0~P2.7为准双向口 
 198   1                  P3M0 = 0;
 199   1          P3M1 = 0;
 200   1              P4M1 = 0;       P4M0 = 0;       //设置P4.0~P4.7为准双向口
 201   1              // P5M1 = 0;    P5M0 = 0;       //设置P5.0~P5.7为准双向口
 202   1      
 203   1                  P5M0 = 0xff; P5M1 = 0x00; 
 204   1      
 205   1      }
 206          
 207          
 208          void delay_ms(int m);
 209          
 210          
 211          
 212          sbit out2=P3^2;
 213          
 214          extern void deanyan();
 215          sbit fen=P5^4;
 216          
 217          
 218          #define Iapid 0x0000
 219          void IapErase(int addr);
 220          void Exxwrite(int addr, uint dat);
 221          void writebuf()
 222          {
 223   1          int i;
 224   1          int dizhi=Iapid;
 225   1          IapErase(Iapid); // ????????
 226   1          Exxwrite(dizhi,55);
 227   1          for ( i = 0; i < len_HoldingReg; i++)
 228   1          {
 229   2              dizhi=dizhi+1;
 230   2              Exxwrite(dizhi,HoldingReg[i]);
 231   2          }
 232   1      }
 233          // 比较值是否发生了变化。。
 234          int bufcheck[len_HoldingReg]={0};
 235          void buffchecktongbu()
 236          {
 237   1          int i;
 238   1          for ( i = 0; i < len_HoldingReg; i++)
 239   1          {
 240   2              bufcheck[i]=HoldingReg[i];
 241   2          }
C51 COMPILER V9.00   MAIN                                                                  08/06/2023 20:18:59 PAGE 5   

 242   1      }
 243          int IsbuffcheckFailed()
 244          {
 245   1          int i;
 246   1          for ( i = 0; i < len_HoldingReg; i++)
 247   1          {
 248   2             if(bufcheck[i]!=HoldingReg[i])
 249   2             {
 250   3                return 1;
 251   3             }
 252   2          }
 253   1          return 0;
 254   1      }
 255          
 256          int timereport=0;
 257          void sendzhi(int weizhi,int zhi)
 258          {
 259   1          char out[30]={0};
 260   1          sprintf(out,"set:%d-%d;end",weizhi,zhi);
 261   1              printf(out);
 262   1      }
 263          void runreport()
 264          {
 265   1          if(timereport>1000)
 266   1          {
 267   2              timereport=0;
 268   2              sendzhi(4,HoldingReg[4]);
 269   2          }
 270   1      }
 271          void chuliguankji()
 272          {
 273   1          char* index;
 274   1          index=strstr(buf3,"@STCISP#");
 275   1              if(index==NULL)
 276   1              {
 277   2                  return  ;
 278   2              }
 279   1          IAP_CONTR=0x60;
 280   1      }
 281          
 282          void IapIdle()
 283          {
 284   1          IAP_CONTR = 0;                              //关闭IAP功能
 285   1          IAP_CMD = 0;                                //清除命令寄存器
 286   1          IAP_TRIG = 0;                               //清除触发寄存器
 287   1          IAP_ADDRH = 0x80;                           //将地址设置到非IAP区域
 288   1          IAP_ADDRL = 0;
 289   1      }
 290          
 291          uchar IapRead(int addr)
 292          {
 293   1          uchar dat;
 294   1      
 295   1          IAP_CONTR = 0x80;                           //使能IAP
 296   1          IAP_TPS = 40;                               //设置等待参数12MHz
 297   1          IAP_CMD = 1;                                //设置IAP读命令
 298   1          IAP_ADDRL = addr;                           //设置IAP低地址
 299   1          IAP_ADDRH = addr >> 8;                      //设置IAP高地址
 300   1          IAP_TRIG = 0x5a;                            //写触发命令(0x5a)
 301   1          IAP_TRIG = 0xa5;                            //写触发命令(0xa5)
 302   1          _nop_();
 303   1          dat = IAP_DATA;                             //读IAP数据
C51 COMPILER V9.00   MAIN                                                                  08/06/2023 20:18:59 PAGE 6   

 304   1          IapIdle();                                  //关闭IAP功能
 305   1      
 306   1          return dat;
 307   1      }
 308          
 309          void IapProgram(int addr, char dat)
 310          {
 311   1          IAP_CONTR = 0x80;                           //使能IAP
 312   1          IAP_TPS = 40;                               //设置等待参数12MHz
 313   1          IAP_CMD = 2;                                //设置IAP写命令
 314   1          IAP_ADDRL = addr;                           //设置IAP低地址
 315   1          IAP_ADDRH = addr >> 8;                      //设置IAP高地址
 316   1          IAP_DATA = dat;                             //写IAP数据
 317   1          IAP_TRIG = 0x5a;                            //写触发命令(0x5a)
 318   1          IAP_TRIG = 0xa5;                            //写触发命令(0xa5)
 319   1          _nop_();
 320   1          IapIdle();                                  //关闭IAP功能
 321   1      }
 322          
 323          void IapErase(int addr)
 324          {
 325   1          IAP_CONTR = 0x80;                           //使能IAP
 326   1          IAP_TPS = 40;                               //设置等待参数12MHz
 327   1          IAP_CMD = 3;                                //设置IAP擦除命令
 328   1          IAP_ADDRL = addr;                           //设置IAP低地址
 329   1          IAP_ADDRH = addr >> 8;                      //设置IAP高地址
 330   1          IAP_TRIG = 0x5a;                            //写触发命令(0x5a)
 331   1          IAP_TRIG = 0xa5;                            //写触发命令(0xa5)
 332   1          _nop_();                                    //
 333   1          IapIdle();                                  //关闭IAP功能
 334   1      }
 335          
 336          
 337          
 338          void Exxwrite(int addr, uint dat)
 339          {
 340   1          addr=addr*2;
 341   1          IapProgram(addr,dat/256);
 342   1          IapProgram(addr+1,dat%256);
 343   1      }
 344          
 345          int ExxRead(int addr)
 346          {
 347   1          uint dat1,dat2;
 348   1          int dat3;
 349   1          addr=addr*2;
 350   1          dat1=IapRead(addr);
 351   1          // printf("ExxRead[%d]\n",dat1);
 352   1      
 353   1          
 354   1          dat2=IapRead(addr+1);
 355   1          // printf("ExxRead[%d]\n",dat2);
 356   1          dat3=dat1*256+dat2;
 357   1          // printf("ExxRead[%d]\n",dat3);
 358   1          return dat3; 
 359   1      }
 360          
 361          void readbuf()
 362          {
 363   1          int i;
 364   1          int zhi;
 365   1          int dizhi=Iapid;
C51 COMPILER V9.00   MAIN                                                                  08/06/2023 20:18:59 PAGE 7   

 366   1          zhi=ExxRead(dizhi);
 367   1          if(zhi==55)
 368   1          {
 369   2              printf("has init\n");
 370   2          }
 371   1          else
 372   1          {
 373   2              printf("not init\n");
 374   2              HoldingReg[4]=600;
 375   2              writebuf();
 376   2          }
 377   1          for ( i = 0; i < len_HoldingReg; i++)
 378   1          {
 379   2              dizhi=dizhi+1;
 380   2              HoldingReg[i]=ExxRead(dizhi);
 381   2              // delay_ms(4);
 382   2              zhi=HoldingReg[i];
 383   2              printf("HoldingReg[%d]-[%d]\n",i,zhi);
 384   2          }
 385   1      }
 386          void initbuf()
 387          {
 388   1          int i;
 389   1          for ( i = 0; i < len_HoldingReg; i++)
 390   1          {
 391   2              HoldingReg[i]=0;
 392   2          }
 393   1          // readbuf();
 394   1      }
 395          
 396          void getzhiandchange()
 397          {
 398   1          int weizhi,zhi;
 399   1          Alltongxininfo2 get={0};
 400   1          pop22(&get);
 401   1          if(get.weizhi==0)
 402   1          {
 403   2              return ;
 404   2          }
 405   1          weizhi=get.weizhi;
 406   1          zhi=get.zhi;
 407   1          printf("getzhiandchange weizhi[%d] zhi[%d]\n",weizhi,zhi);
 408   1          if(weizhi<len_HoldingReg)
 409   1          {
 410   2              HoldingReg[weizhi]=zhi;
 411   2          }
 412   1          if(weizhi==4 || weizhi==2)
 413   1              {
 414   2                      deanyan();
 415   2              }
 416   1          // if(IsbuffcheckFailed())
 417   1          // {
 418   1          //     // printf("xiugaidata begin\n");
 419   1          //     delay_mszhi=0;
 420   1          //     buffchecktongbu();
 421   1          //     writebuf();
 422   1          //     // printf("HoldingReg[4] %d",HoldingReg[4]);
 423   1          //     // printf("xiugaidata end %d\n",delay_mszhi);
 424   1          //     readbuf();
 425   1          // }
 426   1      }
 427          
C51 COMPILER V9.00   MAIN                                                                  08/06/2023 20:18:59 PAGE 8   

 428          //sbit out2 = P3 ^ 2;
 429          void main()                                                    
 430          {
 431   1              io_inint();
 432   1          UartInit();
 433   1              Uart23Init();
 434   1              Timer0Init();
 435   1              Uart4Init();
 436   1              P_SW2 = 0x80;
 437   1          I2CCFG = 0xe0;                              //使能I2C主机模式
 438   1          I2CMSST = 0x00;
 439   1              EA = 1;
 440   1              out2=1;
 441   1              Modbus_ClearBuff();
 442   1          deanyan();
 443   1              delay_ms(100);
 444   1          printf("system init ok\n");
 445   1          initbuf();
 446   1          buffchecktongbu();
 447   1          printf("system init ok1");
 448   1          HoldingReg[2]=1;
 449   1          com1clearbuf();
 450   1          P3M0 = 0x06;
 451   1        P3M1 = 0x08;
 452   1        out2 = 1;
 453   1          while (1)
 454   1              {
 455   2              runreport();
 456   2              getzhiandchange();
 457   2              }
 458   1      } 
 459          int delay_mszhi;         
 460          uint time,lv_bo;
 461          void delay_ms(int m)
 462          {
 463   1          delay_mszhi=0;
 464   1          while (delay_mszhi<=m*2)
 465   1          {
 466   2              
 467   2          }
 468   1      }
 469          void Timer0() interrupt 1
 470          {
 471   1          chuankou1time();
 472   1              delay_mszhi++;
 473   1          timereport++;
 474   1      }
 475          void UARTInterrupt(void) interrupt 4
 476          {
 477   1              unsigned char ans;
 478   1              if (RI)
 479   1              {
 480   2                      RI = 0;
 481   2                      ans=SBUF;
 482   2              chuankou1put(ans);
 483   2              }
 484   1              else
 485   1              {
 486   2                      TI = 0;
 487   2              }
 488   1              if (TI) //发送中断..
 489   1              {
C51 COMPILER V9.00   MAIN                                                                  08/06/2023 20:18:59 PAGE 9   

 490   2                      TI = 0;
 491   2              }
 492   1      }
 493          
 494          void uart2(void ) interrupt 8 
 495          {
 496   1        if (S2CON & S2RI)
 497   1              {
 498   2                      S2CON &= ~S2RI;         
 499   2                      temp2 = S2BUF;
 500   2              }
 501   1        if (S2CON & S2TI)
 502   1          {
 503   2                              //y1=0;
 504   2              S2CON &= ~S2TI;         //清除S2TI位
 505   2              busy2 = 0;               //清忙标志
 506   2          }  
 507   1      }
 508          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2509    ----
   CONSTANT SIZE    =    314    ----
   XDATA SIZE       =    107     219
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
