C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc251\C251\BIN\C251.EXE main.c LARGE BROWSE DEBUG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.
                    -\Objects\main.obj) 

stmt  level    source

    1          //  @布丁橘长 2023/03/10
    2          //  PWM编码器模式示例，本示例程序编码器模式1/2/3均支持，SMCR = 1：模式1，SMCR = 2:模式2，SMCR = 3：模式3
    3          //  EC11左旋或右旋，改变数码管亮度
    4          //  EC11引脚定义：A相-P1.0，B相-P5.4
    5          //  MAX7219数码管模块引脚定义：CS = P6^5;DIN = P6^6;CLK = P6^4;（可在MAX7219.h中修改）
    6          //  实验开发板：屠龙刀三.1 @主频12MHz
    7          
    8          
    9          
   10          
   11          
   12          
   13          
   14          
   15          #include <string.h>
   16          #include "stc32g.h"
   17          #include "config.h"
   18          
   19          
   20          #include <stdio.h>
   21          #include <stdarg.h>
   22          #include <stdio.h>
   23          
   24          #include <stdlib.h>
   25          #include "uart.h"
*** WARNING C317 IN LINE 24 OF uart.h: attempt to redefine macro 'MAIN_Fosc'
   26          #include "tongxin.h"
   27          #include "tongxin2.h"
   28          #include "STC32G_EEPROM.h"
   29          
   30          void SYS_Ini();   // STC32初始化设置
   31          void EC11_Handle(); // EC11数据处理
   32                    // 数码管显示
   33          void PWM_Config(); // PWM初始化设置
   34          
   35          u8 cnt_H, cnt_L;   // 计数值高8位、低8位
   36          u16 count, newcount; // 当前计数值、上次计数值
   37                     // 亮度计数值
   38          
   39          
   40          
   41          char rec2[200]={0};
   42          int weizhi2=0;
   43          // 01 是用力啊检查地址的，，默认55
   44          u16 g_reg[40]={0};
   45          #define indexAdddianliu 20
   46          #define indexTImeuse 21
   47          #define indexTImeAll 22
   48          #define indexMAXdianliu 23
   49          
   50          
   51          
   52          // 最后下去到板子的要乘以2，，最后的计算值。。
   53          
   54          
   55          void SYS_Ini() // STC32初始化设置
   56          {
   57   1        EAXFR = 1;    // 使能访问 XFR
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 2   

   58   1        CKCON = 0x00; // 设置外部数据总线速度为最快
   59   1        WTST = 0x00;  // 设置程序代码等待参数，赋值为 0 可将 CPU 执行程序的速度设置为最快
   60   1        P0M1 = 0x00;
   61   1        P0M0 = 0x00; // 设置P0口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   62   1        P1M1 = 0x00;
   63   1        P1M0 = 0x00; // 设置P1口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   64   1        P2M1 = 0x00;
   65   1        P2M0 = 0x00; // 设置P2口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   66   1        P3M1 = 0x00;
   67   1        P3M0 = 0x00; // 设置P3口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   68   1        P4M1 = 0x00;
   69   1        P4M0 = 0x00; // 设置P4口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   70   1        P5M1 = 0x00;
   71   1        P5M0 = 0x00; // 设置P5口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   72   1        P6M1 = 0x00;
   73   1        P6M0 = 0x00; // 设置P6口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   74   1        P7M1 = 0x00;
   75   1        P7M0 = 0x00; // 设置P7口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   76   1      }
   77          
   78          
   79          
   80          void Delay100ms() //@24.000MHz
   81          {
   82   1        unsigned long i;
   83   1      
   84   1        _nop_();
   85   1        _nop_();
   86   1        i = 599998UL;
   87   1        while (i)
   88   1          i--;
   89   1      }
   90          // 定义printf函数
   91          void printf1(const char *fmt, ...)
   92          {
   93   1        char *p;
   94   1        char buf[128]; // 定义一个缓冲区，足够存储输出的字符串
   95   1        va_list args;
   96   1        va_start(args, fmt);
   97   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
   98   1        va_end(args);
   99   1      
  100   1        p = (unsigned char *)buf;
  101   1        while (*p != '\0')
  102   1        {
  103   2          sendbyte1(*p);
  104   2          p++;
  105   2        }
  106   1      }
  107          
  108          // 定义printf函数
  109          void printtoDianao(const char *fmt, ...)
  110          {
  111   1        char *p;
  112   1        char buf[400]={0}; // 定义一个缓冲区，足够存储输出的字符串
  113   1        va_list args;
  114   1        va_start(args, fmt);
  115   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
  116   1        va_end(args);
  117   1        p = (unsigned char *)buf;
  118   1        while (*p != '\0')
  119   1        {
  120   2          sendbyte2(*p);
  121   2          p++;
  122   2        }
  123   1      }
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 3   

  124          
  125          
  126          
  127          
  128          // 定义printf函数
  129          void printfTopingmu(const char *fmt, ...)
  130          {
  131   1        char *p;
  132   1        char buf[128]; // 定义一个缓冲区，足够存储输出的字符串
  133   1        va_list args;
  134   1        va_start(args, fmt);
  135   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
  136   1        va_end(args);
  137   1      
  138   1        p = (unsigned char *)buf;
  139   1        while (*p != '\0')
  140   1        {
  141   2          sendbyte3(*p);
  142   2          p++;
  143   2        }
  144   1      }
  145          
  146          char code duanzhi[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e
             -, 0x79, 0x71, 0x76, 0x00, 0x40, 0xff};
  147          
  148          sbit led4 = P4 ^ 3;
  149          sbit led3 = P4 ^ 4;
  150          sbit led2 = P2 ^ 0;
  151          sbit led1 = P2 ^ 1;
  152          #define Y0 led1
  153          #define Y1 led2
  154          #define Y2 led3
  155          #define Y3 led4
  156          
  157          char yout_set(char weizhi, char zhi)
  158          {
  159   1        if (weizhi == 0)
  160   1          Y0 = zhi;
  161   1        if (weizhi == 1)
  162   1          Y1 = zhi;
  163   1        if (weizhi == 2)
  164   1          Y2 = zhi;
  165   1        if (weizhi == 3)
  166   1          Y3 = zhi;
  167   1      
  168   1        return (0);
  169   1      }
  170          void yout_closeall()
  171          {
  172   1        char i;
  173   1        for (i = 0; i < 4; i++)
  174   1        {
  175   2          yout_set(i, 1);
  176   2        }
  177   1      }
  178          void Delay10us() //@24.000MHz
  179          {
  180   1        unsigned long i;
  181   1      
  182   1        _nop_();
  183   1        _nop_();
  184   1        _nop_();
  185   1        i = 58UL;
  186   1        while (i)
  187   1          i--;
  188   1      }
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 4   

  189          void delay10x(int i)
  190          {
  191   1        while (i-- > 0)
  192   1        {
  193   2          Delay10us();
  194   2        }
  195   1      }
  196          void showpre(int num)
  197          {
  198   1        int i;
  199   1        int a[4];
  200   1        a[0] = num % 10000 / 1000;
  201   1        a[1] = num % 1000 / 100;
  202   1      
  203   1        a[2] = num % 100 / 10;
  204   1        a[3] = num % 10;
  205   1      
  206   1        for (i = 0; i < 4; i++)
  207   1        {
  208   2          yout_closeall();
  209   2          yout_set(i, 0);
*** WARNING C188 IN LINE 209 OF main.c: 'parameter 1': value truncated
  210   2          P0 = ~duanzhi[a[i]];
  211   2          Delay10us();
  212   2          yout_closeall();
  213   2          P0 = 0xff;
  214   2          Delay10us();
  215   2        }
  216   1      }
  217          
  218          void testmain()
  219          {
  220   1        int a, b;
  221   1        int times = 0;
  222   1      }
*** WARNING C47 IN LINE 220 OF main.c: 'a': unreferenced local variable
*** WARNING C47 IN LINE 220 OF main.c: 'b': unreferenced local variable
  223          
  224          
  225          
  226          int g_dianliu = 600;
  227          
  228          
  229          
  230          
  231          
  232          
  233          
  234          char* mystrstr(const char* haystack, const char* needle) {
  235   1          if (*needle == '\0') {
  236   2              return (char*)haystack;
  237   2          }
  238   1      
  239   1          while (*haystack != '\0') {
  240   2              const char* h = haystack;
  241   2              const char* n = needle;
  242   2      
  243   2              while (*n != '\0' && *h == *n) {
  244   3                  h++;
  245   3                  n++;
  246   3              }
  247   2      
  248   2              if (*n == '\0') {
  249   3                  return (char*)haystack; // 子串匹配成功，返回起始位置
  250   3              }
  251   2      
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 5   

  252   2              haystack++;
  253   2          }
  254   1      
  255   1          return NULL; // 未找到子串，返回NULL
  256   1      }
  257          size_t mystrlen(const char* str) {
  258   1          size_t length = 0;
  259   1          while (str[length] != '\0') {
  260   2              length++;
  261   2          }
  262   1          return length;
  263   1      }
  264          
  265          char* myaddstrstr(const char* haystack, const char* needle)
  266          { 
  267   1        char* result = mystrstr(haystack, needle);
  268   1         if (result != NULL)
  269   1         {
  270   2          result=result+mystrlen(needle);
  271   2         }
  272   1         return result;
  273   1      }
  274          
  275          #define MAX_REGISTERS 10 // 设置最大寄存器数量
  276          
  277          struct Register
  278          {
  279            unsigned int num;
  280            unsigned int value;
  281          };
  282          struct Register registers[MAX_REGISTERS];
  283          int numRegisters = 0;
  284          void showgetzhi()
  285          {
  286   1        unsigned char i;
  287   1        if (i == 0)
  288   1        {
  289   2          printf1("Register not get");
  290   2        }
  291   1        // 遍历并打印所有寄存器的值
  292   1        for (i = 0; i < numRegisters; i++)
  293   1        {
  294   2          printf1("Register %d: %d\n", registers[i].num, registers[i].value);
  295   2        }
  296   1      }
  297          
  298          
  299          void jixi3(char* input)
  300          {
  301   1        char *p=input;
  302   1        char *p1;
  303   1        int i;
  304   1        numRegisters=0;
  305   1        //1234-2234;333-4;end
  306   1        for( i=0;i<100;i++)
  307   1        {
  308   2          p1=myaddstrstr(p,";"); //找有没有下一个的
  309   2          if(p1==NULL)
  310   2          {
  311   3            break;
  312   3          }
  313   2          registers[numRegisters].num = atoi(p);
  314   2          p=myaddstrstr(p,"-");
  315   2          registers[numRegisters].value = atoi(p);
  316   2          numRegisters++;
  317   2          p=myaddstrstr(p,";");  //指向下一个后面
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 6   

  318   2        }
  319   1        showgetzhi();
  320   1      }
  321          
  322          int flaginit=0;
  323          void setzhione(int dizhi,int zhi)
  324          {
  325   1        if(flaginit==0)
  326   1        {
  327   2          return ;
  328   2        }
  329   1        push(dizhi,zhi);
  330   1      }
  331          
  332          
  333          
  334          
  335          int setprezhi;
  336          
  337          int dianliusettime=0;
  338          char flagdianliuset=0;
  339          void setdianliusettime(int zhi)
  340          {
  341   1        if(dianliusettime!=0)
  342   1        {
  343   2          return ;
  344   2        }
  345   1        dianliusettime=zhi;
  346   1      }
  347          void changedainliuzhi()
  348          {
  349   1        if(setprezhi!=g_dianliu)
  350   1        {
  351   2          setprezhi=g_dianliu;
  352   2          setdianliusettime(250);
  353   2        }
  354   1      }
  355          
  356          
  357          
  358          char xin[30] = {0};
  359          sbit X0=P1^3;
  360          sbit X1=P1^1;
  361          void shurulvbo(void)
  362          {
  363   1        static u8 keybuf[40] = {
  364   1          0xFF,
  365   1          0xFF,
  366   1          0xFF,
  367   1          0xFF,
  368   1          0xFF,
  369   1          0xFF,
  370   1          0xFF,
  371   1          0xFF,
  372   1          0xFF,
  373   1          0xFF,
  374   1          0xFF,
  375   1          0xFF,
  376   1          0xFF,
  377   1          0xFF,
  378   1          0xFF,
  379   1          0xFF,
  380   1          0xFF,
  381   1          0xFF,
  382   1          0xFF,
  383   1          0xFF,
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 7   

  384   1          0xFF,
  385   1          0xFF,
  386   1          0xFF,
  387   1          0xFF,
  388   1          0xFF,
  389   1          0xFF,
  390   1          0xFF,
  391   1          0xFF,
  392   1          0xFF,
  393   1          0xFF,
  394   1          0xFF,
  395   1          0xFF,
  396   1          0xFF,
  397   1          0xFF,
  398   1          0xFF,
  399   1          0xFF,
  400   1          0xFF,
  401   1          0xFF,
  402   1          0xFF,
  403   1          0xFF,
  404   1        }; // 矩阵按键扫描缓冲区 8ms
  405   1        unsigned char i;
  406   1        i = X0;
  407   1        keybuf[0] = (keybuf[0] << 1) | i;
  408   1        i = X1;
  409   1        keybuf[1] = (keybuf[1] << 1) | i;
  410   1        // i = X2;
  411   1        // keybuf[2] = (keybuf[2] << 1) | i;
  412   1        // i = X3;
  413   1        // keybuf[3] = (keybuf[3] << 1) | i;
  414   1        for (i = 0; i < 2; i++) // 3按键，所以循环3次
  415   1        {
  416   2          if ((keybuf[i] & 0xFF) == 0x00)
  417   2          {
  418   3            xin[i] = 0;
  419   3          }
  420   2          else if ((keybuf[i] & 0xFF) == 0xFF)
  421   2          { // 连续3次扫描值为1，即1*8ms内都是弹起状态时，可认为按键已稳定的弹起
  422   3            xin[i] = 1;
  423   3          }
  424   2        }
  425   1      }
  426          char flagsetliangdu=0;
  427          void writebuf();
  428          void keydown(int i) // 按键按下的处理、、、
  429          {
  430   1        printf1("keydown %d",i);
  431   1        if(i==0)
  432   1          setzhione(4,g_dianliu);
  433   1        if(i==1)
  434   1        {
  435   2          if(flagsetliangdu==1)//保存记录的值
  436   2          {
  437   3            printf1("flagsetliangdusetzhi %d",g_dianliu);
  438   3            writebuf();   
  439   3          }
  440   2          flagsetliangdu=1-flagsetliangdu;
  441   2        }
  442   1          
  443   1      
  444   1      }
  445          void keyup(int i) // 按键按下的处理、、、
  446          {
  447   1        printf1("keyup %d",i);
  448   1        if(i==0)
  449   1          setzhione(4,0);
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 8   

  450   1      }
  451          void keyallchuli()
  452          {
  453   1        int i;
  454   1        static char flag[10] = {0};   // 标志记录
  455   1        static int dowmtimes[10] = {0}; // 标志记录
  456   1        for (i = 0; i < 6; i++)
  457   1        {
  458   2          if (xin[i] == 0)
  459   2          {
  460   3            if (flag[i] == 0) // 代表按键第一次按下。。。
  461   3            {
  462   4              flag[i] = 1;
  463   4              keydown(i);
  464   4            }
  465   3          }
  466   2          if (xin[i] == 1)
  467   2          {
  468   3            if (flag[i] == 1) // 代表下去了又上来
  469   3            {
  470   4              keyup(i);
  471   4            }
  472   3            flag[i] = 0;
  473   3            
  474   3          }
  475   2        }
  476   1      }
  477          
  478          int FLASH_SAVE_ADDR=0x000040; 
  479          void STMFLASH_Write(u8 WriteAddr,u16 *pBuffer,u16 NumToWrite) 
  480          {
  481   1        EEPROM_SectorErase(WriteAddr);
  482   1        EEPROM_write_n(WriteAddr,(u8 *)pBuffer,NumToWrite*2);
  483   1      }
  484          void EPPROMwrite()
  485          {
  486   1        g_reg[0]=0x55;
  487   1        STMFLASH_Write(FLASH_SAVE_ADDR,g_reg,30);
*** WARNING C188 IN LINE 487 OF main.c: 'parameter 1': value truncated
  488   1      }
  489          void STMFLASH_Read(u32 ReadAddr,u16 *pBuffer,u16 NumToRead) 
  490          {
  491   1        EEPROM_read_n(ReadAddr,(u8 *)pBuffer,NumToRead*2);
  492   1      }
  493          void dealorder();
  494          void getdianliupre()
  495          {
  496   1      
  497   1      }
  498          int timereport=0;
  499          
  500          int errpromdizhi=0x000040;
  501          void writebuf()
  502          {
  503   1        u8 get[10];
  504   1        get[0]=55;
  505   1        get[1]=g_dianliu/100;
  506   1        get[2]=g_dianliu%100;
  507   1        EEPROM_SectorErase(errpromdizhi);
  508   1        EEPROM_write_n(errpromdizhi,get,3);
  509   1      }
  510          void showzhi()
  511          {
  512   1        int i;
  513   1        int len2=sizeof(g_reg[0]);
  514   1        int len=sizeof(g_reg);
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 9   

  515   1        len=len/len2;
  516   1        for(i=0;i<len;i++)
  517   1        {
  518   2          if(g_reg[i]!=0)
  519   2          {
  520   3            printf("[%d-%d]",i,g_reg[i]);
  521   3          }
  522   2        }
  523   1      }
  524          void EPPROMinit()
  525          {        
  526   1        STMFLASH_Read(FLASH_SAVE_ADDR,g_reg,30);
  527   1        if(g_reg[0]!=0x55)
  528   1        {
  529   2          printf("this is First record");
  530   2          memset(g_reg,0,sizeof(g_reg));
  531   2          g_reg[indexTImeAll]=25000;
  532   2          EPPROMwrite();
  533   2        }
  534   1        else
  535   1        {
  536   2          printf("not First record");
  537   2        }
  538   1        showzhi();
  539   1      }
  540          void systemshowkaiji()
  541          {
  542   1        printtoDianao("system start now ,version 1.0,build 2023.08.06");
  543   1      }
  544          // sbit keyled1=P3^6;
  545          // sbit keyled2=P3^5;
  546          // #define ledon 0
  547          // #define ledclose 1
  548          // void showled()
  549          // {
  550          //  keyled1=ledclose;
  551          //  keyled2=ledclose;
  552          //  keyled2=ledon;
  553          // }
  554          void delay_ms(unsigned int ms)
  555          {
  556   1        unsigned int i;
  557   1        do{
  558   2          i = MAIN_Fosc / 6030;
  559   2          while(--i);
  560   2        }while(--ms);
  561   1      }
  562          
  563          void fuwei()
  564          {
  565   1        IAP_CONTR=0x60;
  566   1      }
  567          
  568          int com2jixi2(char* input)
  569          {
  570   1        char flagTrue=0;
  571   1        char *p=input;
  572   1        char *p1;
  573   1        int i;
  574   1        int weizhi;
  575   1        int zhi;
  576   1        int bakweizhi;
  577   1        int bakzhi;
  578   1        for( i=0;i<100;i++)
  579   1        {
  580   2          p1=myaddstrstr(p,";"); //找有没有下一个的
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 10  

  581   2          if(p1==NULL)
  582   2          {
  583   3            break;
  584   3          }
  585   2          weizhi = atoi(p);
  586   2          p=myaddstrstr(p,"-");
  587   2          zhi = atoi(p);
  588   2              if(i%2==0)
  589   2              {
  590   3                  bakweizhi=weizhi;
  591   3                  bakzhi=zhi;
  592   3              }
  593   2              if(i%2==1)
  594   2              {
  595   3                  if(weizhi==bakweizhi && bakzhi==zhi)
  596   3                  {
  597   4                      VectorPush(VectorDiannao,weizhi,zhi);
  598   4              flagTrue=1;
  599   4                  }
  600   3                  else
  601   3                  {
  602   4              flagTrue=0;
  603   4                      printf("get failed");
  604   4                  }
  605   3              }
  606   2          p=myaddstrstr(p,";");  //指向下一个后面
  607   2        }
  608   1        return flagTrue;
  609   1      }
  610          
  611          int  com2jiexi(char* input)
  612          {
  613   1        char par[1000]={0};
  614   1        char *begin,*end;
  615   1        begin=myaddstrstr(input,"set:");
  616   1        end=myaddstrstr(begin,"end");
  617   1        if(begin!=NULL && end!=NULL)
  618   1        {
  619   2          strcpy(par,begin);
  620   2          return com2jixi2(par);
  621   2        }
  622   1        return 0;
  623   1      }
  624          
  625          
  626          int flag_canset=0;
  627          int precom2check(char *input)
  628          {
  629   1        char *p;
  630   1        p=mystrstr(input,"ruibaokesettingmimaflag"); //找有没有下一个的)
  631   1        if(p!=NULL)
  632   1        {
  633   2          printtoDianao("passwd checkpass,you can set now\n");
  634   2          printtoDianao("\n");
  635   2          printtoDianao("初始电流值 20\n");
  636   2          printtoDianao("已使用寿命 21\n");
  637   2          printtoDianao("总寿命 22\n");
  638   2          printtoDianao("最大电流值 23\n");
  639   2          printtoDianao("使用方式 set:20-601;20-601;end\n");
  640   2          flag_canset=1;
  641   2          return 1;
  642   2        }
  643   1        p=mystrstr(input,"fuwei()"); //找有没有下一个的)
  644   1        if(p!=NULL)
  645   1        {
  646   2          fuwei();
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 11  

  647   2        }
  648   1        return 0;
  649   1      }
  650          
  651          
  652          int shoumingjisuan(int predianliu)
  653          {
  654   1        int bili;
  655   1        if(g_reg[indexTImeAll]==0)
  656   1        return predianliu;
  657   1        bili=g_reg[indexTImeuse]*100/g_reg[indexTImeAll];
  658   1        if(bili>100)
  659   1        {
  660   2          return 0;
  661   2        }
  662   1        if(bili>90)
  663   1        {
  664   2          return predianliu*0.3;
  665   2        }
  666   1        if(bili>80)
  667   1        {
  668   2          return predianliu*0.5;
  669   2        }
  670   1        if(bili>70)
  671   1        {
  672   2          return predianliu*0.8;
  673   2        }
  674   1        return predianliu;
  675   1      }
  676          // 电流输出计算
  677          int jisuandianliu(int predianliu)
  678          {
  679   1        if(predianliu==0)
  680   1        {
  681   2          return 0;
  682   2        }
  683   1        predianliu=predianliu+g_reg[indexAdddianliu];
  684   1        if(predianliu>2047)
  685   1        {
  686   2          predianliu=2047;
  687   2        }
  688   1        return shoumingjisuan(predianliu);
  689   1      }
  690          int formatzhi(int zhi)
  691          {
  692   1        if (zhi>2047)
  693   1        {
  694   2          zhi=2047;
  695   2        }
  696   1        if (zhi<0)
  697   1        {
  698   2          zhi=0;
  699   2        }
  700   1        return zhi;
  701   1        
  702   1      }
  703          void dianliusendtokongzhiban(int zhi)
  704          {
  705   1        char out[30]={0};
  706   1        int weizhi=4;
  707   1        zhi=formatzhi(zhi);
  708   1        g_dianliu=zhi;
  709   1        zhi=jisuandianliu(zhi);
  710   1        sprintf(out,"set:%d-%d;%d-%d;end",weizhi,zhi,weizhi,zhi);
  711   1        printfTopingmu(out);
  712   1        printf("%s",out);
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 12  

  713   1      }
  714          
  715          
  716          
  717          int isCanSetWeizhi(int weizhi)
  718          {
  719   1        if(weizhi>=indexAdddianliu && weizhi<=indexMAXdianliu)
  720   1        {
  721   2          return 1;
  722   2        }
  723   1        return 0;
  724   1      }
  725          void getlogstr(int weizhi,char* input)
  726          {
  727   1        if(weizhi==indexAdddianliu)
  728   1        {
  729   2          strcpy(input,"初始电流");
  730   2        }
  731   1        if(weizhi==indexAdddianliu+1)
  732   1        {
  733   2          strcpy(input,"已用寿命");
  734   2        }
  735   1        if(weizhi==indexAdddianliu+2)
  736   1        {
  737   2          strcpy(input,"总的寿命");
  738   2        }
  739   1        if(weizhi==indexAdddianliu+3)
  740   1        {
  741   2          strcpy(input,"最大寿命");
  742   2        }
  743   1      }
  744          
  745          // push 指令相关的计算。。
  746          int selfdeal(int weizhi,int zhi)
  747          {
  748   1        char rspstr[100]={0};
  749   1        char rsp2[100]={0};
  750   1        if(flag_canset==0)
  751   1        {
  752   2          return 0;
  753   2        }
  754   1        if(0==isCanSetWeizhi(weizhi))
  755   1        {
  756   2          return 0;
  757   2        }
  758   1        g_reg[weizhi]=zhi;
  759   1        getlogstr(weizhi,rspstr);
  760   1        EPPROMwrite();
  761   1        sprintf(rsp2,"%s设定:%d-%d 成功;",rspstr,weizhi,zhi);
  762   1        printtoDianao(rsp2);
  763   1        return 1;
  764   1      }
  765          int selfdealread(int weizhi,int zhi)
  766          {
  767   1        char rspstr[100]={0};
  768   1        char rsp2[100]={0};
  769   1        if(weizhi<1000)
  770   1        return 0;
  771   1        if(flag_canset==0)
  772   1        {
  773   2          return 0;
  774   2        }
  775   1        weizhi=weizhi-1000;
  776   1        if(0==isCanSetWeizhi(weizhi))
  777   1        {
  778   2          return 0;
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 13  

  779   2        }
  780   1        getlogstr(weizhi,rspstr);
  781   1        sprintf(rsp2,"%s读取:%d-%d 成功;",rspstr,weizhi,g_reg[weizhi]);
  782   1        printtoDianao(rsp2);
  783   1        return 1;
  784   1      }
*** WARNING C47 IN LINE 765 OF main.c: 'zhi': unreferenced parameter
  785          // 电脑过来的指令，，，处理。。。
  786          // 一样是压进队列。。然后处理就可以了。。。就是这种了。。。
  787          void dealDiannaoOrder()
  788          {
  789   1          int weizhi,zhi;
  790   1          VectorInfo get={0};
  791   1          VectorGet(VectorDiannao,&get);
  792   1          if(get.weizhi==0)
  793   1          {
  794   2              return ;
  795   2          }
  796   1          weizhi=get.weizhi;
  797   1          zhi=get.zhi;
  798   1        if(weizhi==4)//电流设置，等待设置完成后再处理。。。其他设置不用管。。
  799   1        {
  800   2          delay_ms(10);
  801   2          dianliusendtokongzhiban(zhi);
  802   2          delay_ms(10);
  803   2        }
  804   1        else
  805   1        {
  806   2          selfdeal(weizhi,zhi);
  807   2          selfdealread(weizhi,zhi);
  808   2        }
  809   1      }
  810          sbit keywendu1=P2^4;
  811          sbit keywendu2=P2^5;
  812          int flag_error=0;
  813          int iserror()
  814          {
  815   1        if(keywendu1==0)
  816   1        {
  817   2          flag_error=1;
  818   2          return 1;
  819   2        }
  820   1        if(keywendu2==0)
  821   1        {
  822   2          flag_error=1;
  823   2          return 1;
  824   2        }
  825   1        return 0;
  826   1      }
  827          void ShowInfoToDiannan()
  828          {
  829   1        char out[200]={0};
  830   1        if(g_dianliu>0)
  831   1        sprintf(out,"begin;open:%d;",g_dianliu);
  832   1        else
  833   1        sprintf(out,"begin;close:%d;",g_dianliu);
  834   1        if(iserror())
  835   1          {
  836   2            strcat(out,"tmp:error;"); 
  837   2          }
  838   1          else
  839   1          {
  840   2            strcat(out,"tmp:ok;");
  841   2          }
  842   1        if(iserror())
  843   1        {
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 14  

  844   2          strcat(out,"Stat:error;");
  845   2        }
  846   1        else
  847   1        {
  848   2          strcat(out,"Stat:ok;");
  849   2        }
  850   1        strcat(out,"end\n");
  851   1        printtoDianao(out);
  852   1      }
  853          void diannaoinputset()
  854          {
  855   1        int i;
  856   1        if(1==precom2check(rec2))
  857   1        {
  858   2          return ;
  859   2        }
  860   1        com2jiexi(rec2);
  861   1        if(VectorIsEmpty(VectorDiannao))
  862   1        {
  863   2          printtoDianao("oder format error,pleas check[%s]\n",rec2);
  864   2          return ;
  865   2        }
  866   1        for(i=0;i<10;i++)
  867   1        {
  868   2          dealDiannaoOrder(); //com过来的电脑命令解析。。。
  869   2        }
  870   1        ShowInfoToDiannan();
  871   1      }
  872          sbit ledgree=P3^5;
  873          sbit ledgread=P3^6;
  874          void setledisok(int i)
  875          {
  876   1        ledgree=1;
  877   1        ledgread=1;
  878   1        if(i==1)
  879   1        {
  880   2          ledgree=0;
  881   2        }
  882   1        else
  883   1        {
  884   2          ledgread=0;
  885   2        }
  886   1      }
  887          void diannaocheck()
  888          {
  889   1        int i=0;
  890   1        if(weizhi2==0)
  891   1        {
  892   2          return ;
  893   2        }
  894   1        for(i=0;i<5;i++)
  895   1        {
  896   2          delay_ms(2);
  897   2          showpre(g_dianliu);
  898   2        }
  899   1        
  900   1        diannaoinputset();
  901   1        memset(rec2, 0, sizeof(rec2));
  902   1        weizhi2 = 0;
  903   1      }
  904          void main(void)
  905          {
  906   1        int i=0;
  907   1        SYS_Ini();    // STC32初始化设置
  908   1        PWM_Config(); // PWM初始化设置
  909   1        EA = 1;     // 使能EA总中断
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 15  

  910   1      
  911   1        UartInit();
  912   1        Uart23Init();
  913   1        printf1("system is ok");
  914   1        Timer0Init();
  915   1        keyallchuli();
  916   1        flaginit=1;
  917   1        delay_ms(40);
  918   1        EPPROMinit();
  919   1        setzhione(4,0);
  920   1        systemshowkaiji();
  921   1        // test3();
  922   1        // 没有什么时序时序要求，，指点函数里面做算了。。
  923   1        // 算了，之前都写成这样了。。不改了。。原有逻辑上面改改就行吧，，
  924   1        keywendu1=1;
  925   1        keywendu2=1;
  926   1        setledisok(0);
  927   1        memset(rec2,0,sizeof(rec2));
  928   1        weizhi2=0;
  929   1        while (1)
  930   1        {
  931   2          keyallchuli();
  932   2          showpre(g_dianliu);
  933   2          dealorder();//取缓冲区里面的命令进行发送
  934   2          diannaocheck();
  935   2          iserror();
  936   2          if(i++>10000)
  937   2          {
  938   3            i=0;
  939   3            if(flag_error==1)
  940   3            {
  941   4              setledisok(0);
  942   4              ShowInfoToDiannan();
  943   4              setzhione(4,0);
  944   4              printf1("system error");
  945   4            }
  946   3            else
  947   3            {
  948   4              setledisok(1);
  949   4            }
  950   3          }
  951   2        }
  952   1      }
  953          
  954          void PWM_ISR() interrupt 26
  955          {
  956   1        if (PWMA_SR1 & 0X02) // 当捕获中断标志置1
  957   1        {
  958   2          cnt_H = PWMA_CCR1H; // 读取计数值高8位
  959   2          cnt_L = PWMA_CCR1L; // 读取计数值低8位
  960   2          PWMA_SR1 &= ~0X02;  // 清零捕获中断标志
  961   2          EC11_Handle();    // 处理EC11数据
  962   2        }
  963   1      }
  964          void PWM_Config() // PWM初始化设置
  965          {
  966   1        PWMA_CCER1 = 0x00; // 关闭通道
  967   1        PWMA_CCMR1 = 0xA1; // 通道模式配置为输入，接编码器 , 滤波器 80 时钟
  968   1        PWMA_CCMR2 = 0xA1; // 通道模式配置为输入，接编码器 , 滤波器 80 时钟
  969   1        PWMA_CCER1 = 0x55; // 使能捕获/比较通道1、通道2
  970   1      
  971   1        //  PWMA_SMCR = 0x01;         // 编码器模式 1
  972   1        //  PWMA_SMCR = 0x02;         // 编码器模式 2
  973   1        PWMA_SMCR = 0x03; // 编码器模式 3
  974   1      
  975   1        PWMA_IER = 0x02;  // 使能中断
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 16  

  976   1        PWMA_CR1 |= 0x01; // 使能计数器
  977   1        PWMA_PS |= 0x04;  // 选择 PWM2_2 通道
  978   1      }
  979          
  980          // 返回变化的步数
  981          long calculateChange(unsigned int previous, unsigned int current)
  982          {
  983   1        long diff = (current - previous + 65536) % 65536;
*** WARNING C188 IN LINE 983 OF main.c: 'initialization': value truncated
  984   1        return diff;
  985   1      }
  986          
  987          
  988          char flag3 = 0;
  989          int timeleft1, timeleft2, timeleft3, timeleft4;
  990          void chuankou1put(char c)
  991          {
  992   1        rec2[weizhi2++] = c;
  993   1        if (weizhi2 > sizeof(rec2) - 3)
  994   1          weizhi2 = 0;
  995   1        // timeleft3 = 3;
  996   1      }
  997          void chuankou1time()
  998          {
  999   1        if (timeleft3 > 0)
 1000   1        {
 1001   2          timeleft3--;
 1002   2          if (timeleft3 == 0) // 数据一次收完了.
 1003   2          {
 1004   3            flag3 = 1;
 1005   3          }
 1006   2        }
 1007   1      }
 1008          char get1[100];
 1009          int weizhi1=0;
 1010          void chuliguankji(char *get1)
 1011          {
 1012   1          char* index;
 1013   1          index=mystrstr(get1,"@STCISP#");
 1014   1        if(index==0)
 1015   1        {
 1016   2            return  ;
 1017   2        }
 1018   1          IAP_CONTR=0x60;
 1019   1      }
 1020          
 1021          void addgetsetzhi(int i)
 1022          {
 1023   1        int ans;
 1024   1        ans=g_dianliu+i;
 1025   1        if(ans>=0 && ans<=2047)
 1026   1        {
 1027   2          g_dianliu=ans;
 1028   2        }
 1029   1      }
 1030          static int timepush=0;
 1031          void dealorder()
 1032          {
 1033   1        Alltongxininfo get;
 1034   1        if(timepush>45)
 1035   1        {
 1036   2          timepush=0;
 1037   2          pop2(&get);
 1038   2          if(get.weizhi==4)
 1039   2          {
 1040   3            dianliusendtokongzhiban(get.zhi);
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 17  

 1041   3          }
 1042   2        }
 1043   1      }
 1044          void Timer0() interrupt 1
 1045          {
 1046   1        timereport++;
 1047   1        shurulvbo();
 1048   1        chuankou1time();
 1049   1        if(!empty())
*** WARNING C140 IN LINE 1049 OF main.c: 'empty' undefined; assuming 'extern int empty()'
 1050   1        {
 1051   2          timepush++;
 1052   2        }
 1053   1      }
 1054          void EC11_Handle() // EC11数据处理函数
 1055          {
 1056   1        static unsigned int previous = 0;
 1057   1        unsigned int nowzhi;
 1058   1        long ans;
 1059   1        nowzhi = cnt_H * 256 + cnt_L; // 读取当前计数值
 1060   1        ans = calculateChange(previous, nowzhi);
 1061   1        previous = nowzhi;
 1062   1        if(flagsetliangdu==1)
 1063   1        {
 1064   2          if (ans == 4)
 1065   2          {
 1066   3            addgetsetzhi(1);
 1067   3          }
 1068   2          else
 1069   2          {
 1070   3            addgetsetzhi(-1);
 1071   3          }
 1072   2          // 设定电流值。。。
 1073   2          setzhione(4,g_dianliu);
 1074   2          // setzhione(2,1);//开灯。。
 1075   2        }
 1076   1        
 1077   1      }
 1078          
 1079          int step=0;
 1080          void showstep(const char *s)
 1081          {
 1082   1        printf1("%s\n",s);
 1083   1      }
 1084          char* my_strstr(const char* haystack, const char* needle) {
 1085   1          if (*needle == '\0') {
 1086   2              return (char*) haystack;
 1087   2          }
 1088   1      
 1089   1          while (*haystack != '\0') {
 1090   2              const char* h = haystack;
 1091   2              const char* n = needle;
 1092   2      
 1093   2              while (*h == *n && *n != '\0') {
 1094   3                  h++;
 1095   3                  n++;
 1096   3              }
 1097   2      
 1098   2              if (*n == '\0') {
 1099   3                  return (char*) haystack;
 1100   3              }
 1101   2      
 1102   2              haystack++;
 1103   2          }
 1104   1      
 1105   1          return NULL;
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 18  

 1106   1      }
 1107          
 1108          void dealchuankou()
 1109          {
 1110   1      
 1111   1      }
 1112          
 1113          void UARTInterrupt(void) interrupt 4
 1114          {
 1115   1        unsigned char ans;
 1116   1        if (RI)
 1117   1        {
 1118   2          RI = 0;
 1119   2          ans = SBUF;
 1120   2          get1[weizhi1++]=ans;
 1121   2          if(weizhi1>80)
 1122   2          {
 1123   3            weizhi1=0;
 1124   3          }
 1125   2          chuliguankji(get1);
 1126   2        }
 1127   1        else
 1128   1        {
 1129   2          TI = 0;
 1130   2        }
 1131   1        if (TI) // 发送中断..
 1132   1        {
 1133   2          TI = 0;
 1134   2        }
 1135   1      }
 1136          void Uart3() interrupt 17 using 1
 1137          {
 1138   1        char temp3; 
 1139   1          if (S3CON & S3RI)
 1140   1          {
 1141   2              S3CON &= ~S3RI; //??S3RI?
 1142   2          temp3 = S3BUF;
 1143   2          }
 1144   1          if (S3CON & S3TI)
 1145   1          {
 1146   2              S3CON &= ~S3TI; // 清除S3TI位
 1147   2              busy3 = 0;      // 清忙标志
 1148   2          }
 1149   1      }
 1150          void uart2(void) interrupt 8
 1151          {
 1152   1        char ans;
 1153   1        if (S2CON & S2RI)
 1154   1        {
 1155   2          S2CON &= ~S2RI;
 1156   2          ans = S2BUF;
 1157   2          chuankou1put(ans);
 1158   2        }
 1159   1        if (S2CON & S2TI)
 1160   1        {
 1161   2          // y1=0;
 1162   2          S2CON &= ~S2TI; // 清除S2TI位
 1163   2          busy2 = 0;    // 清忙标志
 1164   2        }
 1165   1      }
 1166          
 1167          // 写个函数，传入两个非负数，计算是前进还是后退了，变化规律 15,16,0,1,2...15,16


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      4581     ------
C251 COMPILER V5.60.0,  main                                                               06/08/23  17:23:42  PAGE 19  

  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       567       2485
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      3160     ------
End of Module Information.


C251 COMPILATION COMPLETE.  8 WARNING(S),  0 ERROR(S)
