C251 COMPILER V5.60.0,  main                                                               19/07/23  01:35:20  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE main.c LARGE BROWSE DEBUG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\
                    -Objects\main.obj) 

stmt  level    source

    1          //  @布丁橘长 2023/03/10
    2          //  PWM编码器模式示例，本示例程序编码器模式1/2/3均支持，SMCR = 1：模式1，SMCR = 2:模式2，SMCR = 3：模式3
    3          //  EC11左旋或右旋，改变数码管亮度
    4          //  EC11引脚定义：A相-P1.0，B相-P5.4
    5          //  MAX7219数码管模块引脚定义：CS = P6^5;DIN = P6^6;CLK = P6^4;（可在MAX7219.h中修改）
    6          //  实验开发板：屠龙刀三.1 @主频12MHz
    7          
    8          
    9          
   10          
   11          
   12          
   13          
   14          
   15          #include <string.h>
   16          #include "stc32g.h"
   17          #include "config.h"
   18          
   19          
   20          #include <stdio.h>
   21          #include <stdarg.h>
   22          #include <stdio.h>
   23          
   24          #include <stdlib.h>
   25          
   26          void SYS_Ini();   // STC32初始化设置
   27          void EC11_Handle(); // EC11数据处理
   28                    // 数码管显示
   29          void PWM_Config(); // PWM初始化设置
   30          
   31          u8 cnt_H, cnt_L;   // 计数值高8位、低8位
   32          u16 count, newcount; // 当前计数值、上次计数值
   33                     // 亮度计数值
   34          
   35          void UartInit(void) // 115200@24.000MHz
   36          {
   37   1        SCON = 0x50;  // 8位数据,可变波特率
   38   1        AUXR |= 0x01; // 串口1选择定时器2为波特率发生器
   39   1        AUXR |= 0x04; // 定时器时钟1T模式
   40   1        T2L = 0xCC;   // 设置定时初始值
   41   1        T2H = 0xFF;   // 设置定时初始值
   42   1        AUXR |= 0x10; // 定时器2开始计时
   43   1        ES = 1;
   44   1        //  ES=0;//关闭串口0中断
   45   1        EA = 1;
   46   1      }
   47          
   48          void SYS_Ini() // STC32初始化设置
   49          {
   50   1        EAXFR = 1;    // 使能访问 XFR
   51   1        CKCON = 0x00; // 设置外部数据总线速度为最快
   52   1        WTST = 0x00;  // 设置程序代码等待参数，赋值为 0 可将 CPU 执行程序的速度设置为最快
   53   1        P0M1 = 0x00;
   54   1        P0M0 = 0x00; // 设置P0口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   55   1        P1M1 = 0x00;
   56   1        P1M0 = 0x00; // 设置P1口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   57   1        P2M1 = 0x00;
   58   1        P2M0 = 0x00; // 设置P2口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:35:20  PAGE 2   

   59   1        P3M1 = 0x00;
   60   1        P3M0 = 0x00; // 设置P3口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   61   1        P4M1 = 0x00;
   62   1        P4M0 = 0x00; // 设置P4口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   63   1        P5M1 = 0x00;
   64   1        P5M0 = 0x00; // 设置P5口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   65   1        P6M1 = 0x00;
   66   1        P6M0 = 0x00; // 设置P6口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   67   1        P7M1 = 0x00;
   68   1        P7M0 = 0x00; // 设置P7口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   69   1      }
   70          
   71          void sendbyte1(unsigned char ch)
   72          {
   73   1        int i;
   74   1        // EA=0;
   75   1        TI = 0; // 清零串口发送完成中断请求标志
   76   1        SBUF = ch;
   77   1        while (TI == 0) // 等待发送完成
   78   1        {
   79   2          for (i = 0; i < 2000; i++)
   80   2          {
   81   3            if (TI)
   82   3              break;
   83   3          }
   84   2          break;
   85   2        }
   86   1        EA = 1;
   87   1      }
   88          char putchar(char dat)
   89          {
   90   1        // Delay1us();
   91   1        sendbyte1(dat);
   92   1        return (dat);
   93   1      }
   94          
   95          void Delay100ms() //@24.000MHz
   96          {
   97   1        unsigned long i;
   98   1      
   99   1        _nop_();
  100   1        _nop_();
  101   1        i = 599998UL;
  102   1        while (i)
  103   1          i--;
  104   1      }
  105          // 定义printf函数
  106          void printf1(const char *fmt, ...)
  107          {
  108   1        char *p;
  109   1        char buf[128]; // 定义一个缓冲区，足够存储输出的字符串
  110   1        va_list args;
  111   1        va_start(args, fmt);
  112   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
  113   1        va_end(args);
  114   1      
  115   1        p = (unsigned char *)buf;
  116   1        while (*p != '\0')
  117   1        {
  118   2          sendbyte1(*p);
  119   2          p++;
  120   2        }
  121   1      }
  122          char code duanzhi[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e
             -, 0x79, 0x71, 0x76, 0x00, 0x40, 0xff};
  123          
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:35:20  PAGE 3   

  124          sbit led4 = P4 ^ 3;
  125          sbit led3 = P4 ^ 4;
  126          sbit led2 = P2 ^ 0;
  127          sbit led1 = P2 ^ 1;
  128          #define Y0 led1
  129          #define Y1 led2
  130          #define Y2 led3
  131          #define Y3 led4
  132          
  133          char yout_set(char weizhi, char zhi)
  134          {
  135   1        if (weizhi == 0)
  136   1          Y0 = zhi;
  137   1        if (weizhi == 1)
  138   1          Y1 = zhi;
  139   1        if (weizhi == 2)
  140   1          Y2 = zhi;
  141   1        if (weizhi == 3)
  142   1          Y3 = zhi;
  143   1        // if(weizhi==4)Y4=zhi;
  144   1        // if(weizhi==5)Y5=zhi;
  145   1        return (0);
  146   1      }
  147          void yout_closeall()
  148          {
  149   1        char i;
  150   1        for (i = 0; i < 4; i++)
  151   1        {
  152   2          yout_set(i, 1);
  153   2        }
  154   1      }
  155          void Delay10us() //@24.000MHz
  156          {
  157   1        unsigned long i;
  158   1      
  159   1        _nop_();
  160   1        _nop_();
  161   1        _nop_();
  162   1        i = 58UL;
  163   1        while (i)
  164   1          i--;
  165   1      }
  166          void delay10x(int i)
  167          {
  168   1        while (i-- > 0)
  169   1        {
  170   2          Delay10us();
  171   2        }
  172   1      }
  173          void showpre(int num)
  174          {
  175   1        int i;
  176   1        int a[4];
  177   1        a[0] = num % 10000 / 1000;
  178   1        a[1] = num % 1000 / 100;
  179   1      
  180   1        a[2] = num % 100 / 10;
  181   1        a[3] = num % 10;
  182   1      
  183   1        for (i = 0; i < 4; i++)
  184   1        {
  185   2          yout_closeall();
  186   2          yout_set(i, 0);
*** WARNING C188 IN LINE 186 OF main.c: 'parameter 1': value truncated
  187   2          P0 = ~duanzhi[a[i]];
  188   2          Delay10us();
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:35:20  PAGE 4   

  189   2          yout_closeall();
  190   2          P0 = 0xff;
  191   2          Delay10us();
  192   2        }
  193   1      }
  194          
  195          void testmain()
  196          {
  197   1        int a, b;
  198   1        int times = 0;
  199   1      }
*** WARNING C47 IN LINE 197 OF main.c: 'a': unreferenced local variable
*** WARNING C47 IN LINE 197 OF main.c: 'b': unreferenced local variable
  200          void Timer0Init(void) // 0.5ms @24.000MHz
  201          {
  202   1      
  203   1        AUXR |= 0x80; // 定时器时钟1T模式
  204   1        TMOD &= 0xF0; // 设置定时器模式
  205   1        TL0 = 0x40;   // 设置定时初始值
  206   1        TH0 = 0xA2;   // 设置定时初始值
  207   1        TF0 = 0;    // 清除TF0标志
  208   1        TR0 = 1;    // 定时器0开始计时
  209   1      
  210   1        TF0 = 0; // 清除TF0标志
  211   1        PT0 = 1;
  212   1        ET0 = 1;
  213   1        TR0 = 1; // 定时器0开始计时
  214   1        EA = 1;
  215   1      }
  216          
  217          void dealchuankou();
  218          int gsetzhi = 1234;
  219          
  220          
  221          
  222          
  223          
  224          
  225          
  226          char* mystrstr(const char* haystack, const char* needle) {
  227   1          if (*needle == '\0') {
  228   2              return (char*)haystack;
  229   2          }
  230   1      
  231   1          while (*haystack != '\0') {
  232   2              const char* h = haystack;
  233   2              const char* n = needle;
  234   2      
  235   2              while (*n != '\0' && *h == *n) {
  236   3                  h++;
  237   3                  n++;
  238   3              }
  239   2      
  240   2              if (*n == '\0') {
  241   3                  return (char*)haystack; // 子串匹配成功，返回起始位置
  242   3              }
  243   2      
  244   2              haystack++;
  245   2          }
  246   1      
  247   1          return NULL; // 未找到子串，返回NULL
  248   1      }
  249          size_t mystrlen(const char* str) {
  250   1          size_t length = 0;
  251   1          while (str[length] != '\0') {
  252   2              length++;
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:35:20  PAGE 5   

  253   2          }
  254   1          return length;
  255   1      }
  256          
  257          char* myaddstrstr(const char* haystack, const char* needle)
  258          { 
  259   1        char* result = mystrstr(haystack, needle);
  260   1         if (result != NULL)
  261   1         {
  262   2          result=result+mystrlen(needle);
  263   2         }
  264   1         return result;
  265   1      }
  266          
  267          #define MAX_REGISTERS 10 // 设置最大寄存器数量
  268          
  269          struct Register
  270          {
  271            unsigned int num;
  272            unsigned int value;
  273          };
  274          struct Register registers[MAX_REGISTERS];
  275          int numRegisters = 0;
  276          void showgetzhi()
  277          {
  278   1        unsigned char i;
  279   1        if (i == 0)
  280   1        {
  281   2          printf1("Register not get");
  282   2        }
  283   1        // 遍历并打印所有寄存器的值
  284   1        for (i = 0; i < numRegisters; i++)
  285   1        {
  286   2          printf1("Register %d: %d\n", registers[i].num, registers[i].value);
  287   2        }
  288   1      }
  289          
  290          #define MAXgetzhi 100
  291          int getzhi[MAXgetzhi]={0};
  292          void jixi3(char* input)
  293          {
  294   1        char *p=input;
  295   1        char *p1;
  296   1        int i;
  297   1        numRegisters=0;
  298   1        //1234-2234;333-4;end
  299   1        for( i=0;i<100;i++)
  300   1        {
  301   2          p1=myaddstrstr(p,";"); //找有没有下一个的
  302   2          if(p1==NULL)
  303   2          {
  304   3            break;
  305   3          }
  306   2          registers[numRegisters].num = atoi(p);
  307   2          p=myaddstrstr(p,"-");
  308   2          registers[numRegisters].value = atoi(p);
  309   2          numRegisters++;
  310   2          p=myaddstrstr(p,";");  //指向下一个后面
  311   2        }
  312   1        showgetzhi();
  313   1      }
  314          void jixi2(char* input)
  315          {
  316   1        char *p=input;
  317   1        char *p1;
  318   1        int i;
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:35:20  PAGE 6   

  319   1        unsigned int weizhi;
  320   1        unsigned int zhi;
  321   1        //1234-2234;333-4;end
  322   1        for( i=0;i<100;i++)
  323   1        {
  324   2          p1=myaddstrstr(p,";"); //找有没有下一个的
  325   2          if(p1==NULL)
  326   2          {
  327   3            break;
  328   3          }
  329   2          weizhi = atoi(p);
  330   2          p=myaddstrstr(p,"-");
  331   2          zhi = atoi(p);
  332   2          if(weizhi<MAXgetzhi)
  333   2          getzhi[weizhi]=zhi;
  334   2          p=myaddstrstr(p,";");  //指向下一个后面
  335   2          printf1("get set%d-%d",weizhi,zhi);
  336   2        }
  337   1      }
  338          void setzhione(int dizhi,int zhi)
  339          {
  340   1        char out[30]={0};
  341   1        sprintf(out,"set:%d-%d;end",dizhi,zhi);
  342   1        printf1(out);
  343   1      }
  344          void jiexi(char* input)
  345          {
  346   1        char par[500]={0};
  347   1        char *begin,end;
  348   1        begin=myaddstrstr(input,"set:");
  349   1        // printf1("input begin%s",begin);
  350   1        end=myaddstrstr(begin,"end");
*** WARNING C161 IN LINE 350 OF main.c: 'far' pointer truncated to 'char'
*** WARNING C10 IN LINE 350 OF main.c: conversion: 'pointer' to 'char'
  351   1        // printf1("input end%s",end);
  352   1        if(begin!=NULL && end!=NULL)
*** WARNING C40 IN LINE 352 OF main.c: 'char' converted to 'far' pointer
  353   1        {
  354   2          strcpy(par,begin);
  355   2          jixi2(par);
  356   2        }
  357   1      }
  358          int mainxx() {
  359   1      
  360   1        const char* haystack = "sdsdset:1234-2234;333-4;endsdsdsd";
  361   1        jiexi(haystack);
  362   1        
  363   1        setzhione(4,20);
  364   1      
  365   1        return 0;
  366   1      }
  367          
  368          
  369          int mainxx2() {
  370   1          const char* haystack = "Hello, world!";
  371   1          const char* needle = "world";
  372   1          char* result = mystrstr(haystack, needle);
  373   1      
  374   1          if (result != NULL) {
  375   2              printf("'%s' found in '%s' at index %ld\n", needle, haystack, result - haystack);
  376   2          } else {
  377   2              printf("'%s' not found in '%s'\n", needle, haystack);
  378   2          }
  379   1      
  380   1          return 0;
  381   1      }
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:35:20  PAGE 7   

  382          
  383          
  384          int mainxxx() {
  385   1          const char* str = "Hello, world!";
  386   1          size_t length = mystrlen(str);
  387   1          printf("Length of '%s' is %d\n", str, length);
  388   1          return 0;
  389   1      }
  390          
  391          
  392          void main(void)
  393          {
  394   1      
  395   1        SYS_Ini();    // STC32初始化设置
  396   1        PWM_Config(); // PWM初始化设置
  397   1        EA = 1;     // 使能EA总中断
  398   1      
  399   1        UartInit();
  400   1        printf1("system is ok");
  401   1        Timer0Init();
  402   1        mainxx();
  403   1        while (1)
  404   1        {
  405   2          showpre(gsetzhi);
  406   2          dealchuankou();
  407   2        }
  408   1      }
  409          
  410          void PWM_ISR() interrupt 26
  411          {
  412   1        if (PWMA_SR1 & 0X02) // 当捕获中断标志置1
  413   1        {
  414   2          cnt_H = PWMA_CCR1H; // 读取计数值高8位
  415   2          cnt_L = PWMA_CCR1L; // 读取计数值低8位
  416   2          PWMA_SR1 &= ~0X02;  // 清零捕获中断标志
  417   2          EC11_Handle();    // 处理EC11数据
  418   2        }
  419   1      }
  420          void PWM_Config() // PWM初始化设置
  421          {
  422   1        PWMA_CCER1 = 0x00; // 关闭通道
  423   1        PWMA_CCMR1 = 0xA1; // 通道模式配置为输入，接编码器 , 滤波器 80 时钟
  424   1        PWMA_CCMR2 = 0xA1; // 通道模式配置为输入，接编码器 , 滤波器 80 时钟
  425   1        PWMA_CCER1 = 0x55; // 使能捕获/比较通道1、通道2
  426   1      
  427   1        //  PWMA_SMCR = 0x01;         // 编码器模式 1
  428   1        //  PWMA_SMCR = 0x02;         // 编码器模式 2
  429   1        PWMA_SMCR = 0x03; // 编码器模式 3
  430   1      
  431   1        PWMA_IER = 0x02;  // 使能中断
  432   1        PWMA_CR1 |= 0x01; // 使能计数器
  433   1        PWMA_PS |= 0x04;  // 选择 PWM2_2 通道
  434   1      }
  435          
  436          // 返回变化的步数
  437          long calculateChange(unsigned int previous, unsigned int current)
  438          {
  439   1        long diff = (current - previous + 65536) % 65536;
*** WARNING C188 IN LINE 439 OF main.c: 'initialization': value truncated
  440   1        return diff;
  441   1      }
  442          
  443          char buf3[500];
  444          char flag3 = 0;
  445          int weishu3;
  446          int timeleft1, timeleft2, timeleft3, timeleft4;
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:35:20  PAGE 8   

  447          void chuankou1put(char c)
  448          {
  449   1        buf3[weishu3++] = c;
  450   1        if (weishu3 > sizeof(buf3) - 3)
  451   1          weishu3 = 0;
  452   1        timeleft3 = 3;
  453   1      }
  454          void chuankou1time()
  455          {
  456   1        if (timeleft3 > 0)
  457   1        {
  458   2          timeleft3--;
  459   2          if (timeleft3 == 0) // 数据一次收完了.
  460   2          {
  461   3            flag3 = 1;
  462   3          }
  463   2        }
  464   1      }
  465          void UARTInterrupt(void) interrupt 4
  466          {
  467   1        unsigned char ans;
  468   1        if (RI)
  469   1        {
  470   2          RI = 0;
  471   2          ans = SBUF;
  472   2          chuankou1put(ans);
  473   2          IAP_CONTR=0x60;
  474   2        }
  475   1        else
  476   1        {
  477   2          TI = 0;
  478   2          
  479   2        }
  480   1        if (TI) // 发送中断..
  481   1        {
  482   2          TI = 0;
  483   2        }
  484   1      }
  485          
  486          void Timer0() interrupt 1
  487          {
  488   1        gsetzhi++;
  489   1        chuankou1time();
  490   1      }
  491          void EC11_Handle() // EC11数据处理函数
  492          {
  493   1        static unsigned int previous = 0;
  494   1        unsigned int nowzhi;
  495   1        long ans;
  496   1        nowzhi = cnt_H * 256 + cnt_L; // 读取当前计数值
  497   1        ans = calculateChange(previous, nowzhi);
  498   1        previous = nowzhi;
  499   1        if (ans == 4)
  500   1        {
  501   2          gsetzhi++;
  502   2        }
  503   1        else
  504   1        {
  505   2          gsetzhi--;
  506   2        }
  507   1      }
  508          
  509          // #define MAX_REGISTERS 10 // 设置最大寄存器数量
  510          
  511          // struct Register
  512          // {
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:35:20  PAGE 9   

  513          //  unsigned char num;
  514          //  unsigned int value;
  515          // };
  516          
  517          // struct Register registers[MAX_REGISTERS];
  518          // int numRegisters = 0;
  519          
  520          // void setRegisterValue(const char* data) {
  521          //     unsigned char* delimiterPos = strchr(data, '-');
  522          //     if (delimiterPos != NULL) {
  523          //         unsigned char registerNum = *(delimiterPos - 1) - '0';
  524          //         unsigned int value = atoi(delimiterPos + 1);
  525          
  526          //         if (numRegisters < MAX_REGISTERS) {
  527          //             registers[numRegisters].num = registerNum;
  528          //             registers[numRegisters].value = value;
  529          //             numRegisters++;
  530          //         } else {
  531          //             printf("Max number of registers reached.\n");
  532          //         }
  533          //     }
  534          // }
  535          
  536          // void processReceivedData(const char* receivedData) {
  537          //     char* dataCopy = strdup(receivedData);
  538          //     char* token = my_strtok(dataCopy, ",");
  539          //     while (token != NULL) {
  540          //         setRegisterValue(token);
  541          //         token = my_strtok(NULL, ",");
  542          //     }
  543          //     free(dataCopy);
  544          // }
  545          // void showgetzhi()
  546          // {
  547          //  unsigned char i;
  548          //  if (i == 0)
  549          //  {
  550          //    printf1("Register not get");
  551          //  }
  552          //  // 遍历并打印所有寄存器的值
  553          //  for (i = 0; i < numRegisters; i++)
  554          //  {
  555          //    printf1("Register %d: %d\n", registers[i].num, registers[i].value);
  556          //  }
  557          // }
  558          int step=0;
  559          void showstep(const char *s)
  560          {
  561   1        printf1("%s\n",s);
  562   1      }
  563          char* my_strstr(const char* haystack, const char* needle) {
  564   1          if (*needle == '\0') {
  565   2              return (char*) haystack;
  566   2          }
  567   1      
  568   1          while (*haystack != '\0') {
  569   2              const char* h = haystack;
  570   2              const char* n = needle;
  571   2      
  572   2              while (*h == *n && *n != '\0') {
  573   3                  h++;
  574   3                  n++;
  575   3              }
  576   2      
  577   2              if (*n == '\0') {
  578   3                  return (char*) haystack;
C251 COMPILER V5.60.0,  main                                                               19/07/23  01:35:20  PAGE 10  

  579   3              }
  580   2      
  581   2              haystack++;
  582   2          }
  583   1      
  584   1          return NULL;
  585   1      }
  586          
  587          void dealbuf3()
  588          {
  589   1        char *receiveData = buf3;
  590   1        unsigned char *headerPos = my_strstr(receiveData, "set:");
  591   1        unsigned char *footerPos = my_strstr(receiveData, "end");
  592   1        printf1("dealbuf3");
  593   1        if (headerPos != NULL && footerPos != NULL && footerPos > headerPos)
  594   1        {
  595   2          unsigned char *dataStart = headerPos + 4;
  596   2          unsigned char *dataEnd = footerPos;
  597   2      
  598   2          // 分离出有效的数据部分
  599   2          *dataEnd = '\0';
  600   2      
  601   2          // 处理有效的数据部分
  602   2          // setRegisterValue(dataStart);
  603   2          printf1("dealbuf4");
  604   2        }
  605   1        // showgetzhi();
  606   1      }
  607          void dealchuankou()
  608          {
  609   1        if (flag3 == 1)
  610   1        {
  611   2          flag3 = 0;
  612   2          printf1("rec%s", buf3);
  613   2          dealbuf3();
  614   2          memset(buf3, 0, sizeof(buf3));
  615   2          weishu3 = 0;
  616   2        }
  617   1      }
  618          
  619          // 写个函数，传入两个非负数，计算是前进还是后退了，变化规律 15,16,0,1,2...15,16


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2227     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       765        738
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      1017     ------
End of Module Information.


C251 COMPILATION COMPLETE.  7 WARNING(S),  0 ERROR(S)
