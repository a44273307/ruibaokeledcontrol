C251 COMPILER V5.60.0,  main                                                               06/08/23  14:53:33  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc251\C251\BIN\C251.EXE main.c LARGE BROWSE DEBUG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.
                    -\Objects\main.obj) 

stmt  level    source

    1          //  @布丁橘长 2023/03/10
    2          //  PWM编码器模式示例，本示例程序编码器模式1/2/3均支持，SMCR = 1：模式1，SMCR = 2:模式2，SMCR = 3：模式3
    3          //  EC11左旋或右旋，改变数码管亮度
    4          //  EC11引脚定义：A相-P1.0，B相-P5.4
    5          //  MAX7219数码管模块引脚定义：CS = P6^5;DIN = P6^6;CLK = P6^4;（可在MAX7219.h中修改）
    6          //  实验开发板：屠龙刀三.1 @主频12MHz
    7          
    8          
    9          
   10          
   11          
   12          
   13          
   14          
   15          #include <string.h>
   16          #include "stc32g.h"
   17          #include "config.h"
   18          
   19          
   20          #include <stdio.h>
   21          #include <stdarg.h>
   22          #include <stdio.h>
   23          
   24          #include <stdlib.h>
   25          #include "uart.h"
*** WARNING C317 IN LINE 24 OF uart.h: attempt to redefine macro 'MAIN_Fosc'
   26          #include "tongxin.h"
   27          #include "tongxin2.h"
   28          #include "STC32G_EEPROM.h"
   29          
   30          void SYS_Ini();   // STC32初始化设置
   31          void EC11_Handle(); // EC11数据处理
   32                    // 数码管显示
   33          void PWM_Config(); // PWM初始化设置
   34          
   35          u8 cnt_H, cnt_L;   // 计数值高8位、低8位
   36          u16 count, newcount; // 当前计数值、上次计数值
   37                     // 亮度计数值
   38          
   39          
   40          
   41          char rec2[500];
   42          int weizhi2=0;
   43          
   44          
   45          // 最后下去到板子的要乘以2，，最后的计算值。。
   46          
   47          int bili=2;
   48          void SYS_Ini() // STC32初始化设置
   49          {
   50   1        EAXFR = 1;    // 使能访问 XFR
   51   1        CKCON = 0x00; // 设置外部数据总线速度为最快
   52   1        WTST = 0x00;  // 设置程序代码等待参数，赋值为 0 可将 CPU 执行程序的速度设置为最快
   53   1        P0M1 = 0x00;
   54   1        P0M0 = 0x00; // 设置P0口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   55   1        P1M1 = 0x00;
   56   1        P1M0 = 0x00; // 设置P1口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   57   1        P2M1 = 0x00;
C251 COMPILER V5.60.0,  main                                                               06/08/23  14:53:33  PAGE 2   

   58   1        P2M0 = 0x00; // 设置P2口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   59   1        P3M1 = 0x00;
   60   1        P3M0 = 0x00; // 设置P3口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   61   1        P4M1 = 0x00;
   62   1        P4M0 = 0x00; // 设置P4口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   63   1        P5M1 = 0x00;
   64   1        P5M0 = 0x00; // 设置P5口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   65   1        P6M1 = 0x00;
   66   1        P6M0 = 0x00; // 设置P6口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   67   1        P7M1 = 0x00;
   68   1        P7M0 = 0x00; // 设置P7口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
   69   1      }
   70          
   71          
   72          
   73          void Delay100ms() //@24.000MHz
   74          {
   75   1        unsigned long i;
   76   1      
   77   1        _nop_();
   78   1        _nop_();
   79   1        i = 599998UL;
   80   1        while (i)
   81   1          i--;
   82   1      }
   83          // 定义printf函数
   84          void printf1(const char *fmt, ...)
   85          {
   86   1        char *p;
   87   1        char buf[128]; // 定义一个缓冲区，足够存储输出的字符串
   88   1        va_list args;
   89   1        va_start(args, fmt);
   90   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
   91   1        va_end(args);
   92   1      
   93   1        p = (unsigned char *)buf;
   94   1        while (*p != '\0')
   95   1        {
   96   2          sendbyte1(*p);
   97   2          p++;
   98   2        }
   99   1      }
  100          
  101          // 定义printf函数
  102          void print2(const char *fmt, ...)
  103          {
  104   1        char *p;
  105   1        char buf[400]={0}; // 定义一个缓冲区，足够存储输出的字符串
  106   1        va_list args;
  107   1        va_start(args, fmt);
  108   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
  109   1        va_end(args);
  110   1        p = (unsigned char *)buf;
  111   1        while (*p != '\0')
  112   1        {
  113   2          sendbyte1(*p);
  114   2          p++;
  115   2        }
  116   1      }
  117          
  118          
  119          // 定义printf函数
  120          void printf3(const char *fmt, ...)
  121          {
  122   1        char *p;
  123   1        char buf[128]; // 定义一个缓冲区，足够存储输出的字符串
C251 COMPILER V5.60.0,  main                                                               06/08/23  14:53:33  PAGE 3   

  124   1        va_list args;
  125   1        va_start(args, fmt);
  126   1        vsprintf(buf, fmt, args); // 将格式化的字符串写入缓冲区
  127   1        va_end(args);
  128   1      
  129   1        p = (unsigned char *)buf;
  130   1        while (*p != '\0')
  131   1        {
  132   2          sendbyte3(*p);
  133   2          p++;
  134   2        }
  135   1      }
  136          char code duanzhi[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e
             -, 0x79, 0x71, 0x76, 0x00, 0x40, 0xff};
  137          
  138          sbit led4 = P4 ^ 3;
  139          sbit led3 = P4 ^ 4;
  140          sbit led2 = P2 ^ 0;
  141          sbit led1 = P2 ^ 1;
  142          #define Y0 led1
  143          #define Y1 led2
  144          #define Y2 led3
  145          #define Y3 led4
  146          
  147          char yout_set(char weizhi, char zhi)
  148          {
  149   1        if (weizhi == 0)
  150   1          Y0 = zhi;
  151   1        if (weizhi == 1)
  152   1          Y1 = zhi;
  153   1        if (weizhi == 2)
  154   1          Y2 = zhi;
  155   1        if (weizhi == 3)
  156   1          Y3 = zhi;
  157   1      
  158   1        return (0);
  159   1      }
  160          void yout_closeall()
  161          {
  162   1        char i;
  163   1        for (i = 0; i < 4; i++)
  164   1        {
  165   2          yout_set(i, 1);
  166   2        }
  167   1      }
  168          void Delay10us() //@24.000MHz
  169          {
  170   1        unsigned long i;
  171   1      
  172   1        _nop_();
  173   1        _nop_();
  174   1        _nop_();
  175   1        i = 58UL;
  176   1        while (i)
  177   1          i--;
  178   1      }
  179          void delay10x(int i)
  180          {
  181   1        while (i-- > 0)
  182   1        {
  183   2          Delay10us();
  184   2        }
  185   1      }
  186          void showpre(int num)
  187          {
  188   1        int i;
C251 COMPILER V5.60.0,  main                                                               06/08/23  14:53:33  PAGE 4   

  189   1        int a[4];
  190   1        a[0] = num % 10000 / 1000;
  191   1        a[1] = num % 1000 / 100;
  192   1      
  193   1        a[2] = num % 100 / 10;
  194   1        a[3] = num % 10;
  195   1      
  196   1        for (i = 0; i < 4; i++)
  197   1        {
  198   2          yout_closeall();
  199   2          yout_set(i, 0);
*** WARNING C188 IN LINE 199 OF main.c: 'parameter 1': value truncated
  200   2          P0 = ~duanzhi[a[i]];
  201   2          Delay10us();
  202   2          yout_closeall();
  203   2          P0 = 0xff;
  204   2          Delay10us();
  205   2        }
  206   1      }
  207          
  208          void testmain()
  209          {
  210   1        int a, b;
  211   1        int times = 0;
  212   1      }
*** WARNING C47 IN LINE 210 OF main.c: 'a': unreferenced local variable
*** WARNING C47 IN LINE 210 OF main.c: 'b': unreferenced local variable
  213          
  214          
  215          
  216          int gsetzhi = 600;
  217          
  218          
  219          
  220          
  221          
  222          
  223          
  224          char* mystrstr(const char* haystack, const char* needle) {
  225   1          if (*needle == '\0') {
  226   2              return (char*)haystack;
  227   2          }
  228   1      
  229   1          while (*haystack != '\0') {
  230   2              const char* h = haystack;
  231   2              const char* n = needle;
  232   2      
  233   2              while (*n != '\0' && *h == *n) {
  234   3                  h++;
  235   3                  n++;
  236   3              }
  237   2      
  238   2              if (*n == '\0') {
  239   3                  return (char*)haystack; // 子串匹配成功，返回起始位置
  240   3              }
  241   2      
  242   2              haystack++;
  243   2          }
  244   1      
  245   1          return NULL; // 未找到子串，返回NULL
  246   1      }
  247          size_t mystrlen(const char* str) {
  248   1          size_t length = 0;
  249   1          while (str[length] != '\0') {
  250   2              length++;
  251   2          }
C251 COMPILER V5.60.0,  main                                                               06/08/23  14:53:33  PAGE 5   

  252   1          return length;
  253   1      }
  254          
  255          char* myaddstrstr(const char* haystack, const char* needle)
  256          { 
  257   1        char* result = mystrstr(haystack, needle);
  258   1         if (result != NULL)
  259   1         {
  260   2          result=result+mystrlen(needle);
  261   2         }
  262   1         return result;
  263   1      }
  264          
  265          #define MAX_REGISTERS 10 // 设置最大寄存器数量
  266          
  267          struct Register
  268          {
  269            unsigned int num;
  270            unsigned int value;
  271          };
  272          struct Register registers[MAX_REGISTERS];
  273          int numRegisters = 0;
  274          void showgetzhi()
  275          {
  276   1        unsigned char i;
  277   1        if (i == 0)
  278   1        {
  279   2          printf1("Register not get");
  280   2        }
  281   1        // 遍历并打印所有寄存器的值
  282   1        for (i = 0; i < numRegisters; i++)
  283   1        {
  284   2          printf1("Register %d: %d\n", registers[i].num, registers[i].value);
  285   2        }
  286   1      }
  287          
  288          #define MAXgetzhi 100
  289          int getzhi[MAXgetzhi]={0};
  290          void jixi3(char* input)
  291          {
  292   1        char *p=input;
  293   1        char *p1;
  294   1        int i;
  295   1        numRegisters=0;
  296   1        //1234-2234;333-4;end
  297   1        for( i=0;i<100;i++)
  298   1        {
  299   2          p1=myaddstrstr(p,";"); //找有没有下一个的
  300   2          if(p1==NULL)
  301   2          {
  302   3            break;
  303   3          }
  304   2          registers[numRegisters].num = atoi(p);
  305   2          p=myaddstrstr(p,"-");
  306   2          registers[numRegisters].value = atoi(p);
  307   2          numRegisters++;
  308   2          p=myaddstrstr(p,";");  //指向下一个后面
  309   2        }
  310   1        showgetzhi();
  311   1      }
  312          
  313          int flaginit=0;
  314          void setzhione(int dizhi,int zhi)
  315          {
  316   1        if(flaginit==0)
  317   1        {
C251 COMPILER V5.60.0,  main                                                               06/08/23  14:53:33  PAGE 6   

  318   2          return ;
  319   2        }
  320   1        push(dizhi,zhi);
  321   1      }
  322          
  323          
  324          
  325          
  326          int setprezhi;
  327          
  328          int dianliusettime=0;
  329          char flagdianliuset=0;
  330          void setdianliusettime(int zhi)
  331          {
  332   1        if(dianliusettime!=0)
  333   1        {
  334   2          return ;
  335   2        }
  336   1        dianliusettime=zhi;
  337   1      }
  338          void changedainliuzhi()
  339          {
  340   1        if(setprezhi!=gsetzhi)
  341   1        {
  342   2          setprezhi=gsetzhi;
  343   2          setdianliusettime(250);
  344   2        }
  345   1      }
  346          
  347          
  348          
  349          char xin[30] = {0};
  350          sbit X0=P1^3;
  351          sbit X1=P1^1;
  352          void shurulvbo(void)
  353          {
  354   1        static u8 keybuf[40] = {
  355   1          0xFF,
  356   1          0xFF,
  357   1          0xFF,
  358   1          0xFF,
  359   1          0xFF,
  360   1          0xFF,
  361   1          0xFF,
  362   1          0xFF,
  363   1          0xFF,
  364   1          0xFF,
  365   1          0xFF,
  366   1          0xFF,
  367   1          0xFF,
  368   1          0xFF,
  369   1          0xFF,
  370   1          0xFF,
  371   1          0xFF,
  372   1          0xFF,
  373   1          0xFF,
  374   1          0xFF,
  375   1          0xFF,
  376   1          0xFF,
  377   1          0xFF,
  378   1          0xFF,
  379   1          0xFF,
  380   1          0xFF,
  381   1          0xFF,
  382   1          0xFF,
  383   1          0xFF,
C251 COMPILER V5.60.0,  main                                                               06/08/23  14:53:33  PAGE 7   

  384   1          0xFF,
  385   1          0xFF,
  386   1          0xFF,
  387   1          0xFF,
  388   1          0xFF,
  389   1          0xFF,
  390   1          0xFF,
  391   1          0xFF,
  392   1          0xFF,
  393   1          0xFF,
  394   1          0xFF,
  395   1        }; // 矩阵按键扫描缓冲区 8ms
  396   1        unsigned char i;
  397   1        i = X0;
  398   1        keybuf[0] = (keybuf[0] << 1) | i;
  399   1        i = X1;
  400   1        keybuf[1] = (keybuf[1] << 1) | i;
  401   1        // i = X2;
  402   1        // keybuf[2] = (keybuf[2] << 1) | i;
  403   1        // i = X3;
  404   1        // keybuf[3] = (keybuf[3] << 1) | i;
  405   1        for (i = 0; i < 2; i++) // 3按键，所以循环3次
  406   1        {
  407   2          if ((keybuf[i] & 0xFF) == 0x00)
  408   2          {
  409   3            xin[i] = 0;
  410   3          }
  411   2          else if ((keybuf[i] & 0xFF) == 0xFF)
  412   2          { // 连续3次扫描值为1，即1*8ms内都是弹起状态时，可认为按键已稳定的弹起
  413   3            xin[i] = 1;
  414   3          }
  415   2        }
  416   1      }
  417          char flagsetliangdu=0;
  418          void writebuf();
  419          void keydown(int i) // 按键按下的处理、、、
  420          {
  421   1        printf1("keydown %d",i);
  422   1        if(i==0)
  423   1          setzhione(4,gsetzhi);
  424   1        if(i==1)
  425   1        {
  426   2          // if(flagsetliangdu==0)//不能设置值。。变成设置
  427   2          // {
  428   2      
  429   2          // }
  430   2          if(flagsetliangdu==1)//保存记录的值
  431   2          {
  432   3            printf1("flagsetliangdusetzhi %d",gsetzhi);
  433   3            writebuf();   
  434   3          }
  435   2          flagsetliangdu=1-flagsetliangdu;
  436   2        }
  437   1          
  438   1      
  439   1      }
  440          void keyup(int i) // 按键按下的处理、、、
  441          {
  442   1        printf1("keyup %d",i);
  443   1        if(i==0)
  444   1          setzhione(4,0);
  445   1      }
  446          void keyallchuli()
  447          {
  448   1        int i;
  449   1        static char flag[10] = {0};   // 标志记录
C251 COMPILER V5.60.0,  main                                                               06/08/23  14:53:33  PAGE 8   

  450   1        static int dowmtimes[10] = {0}; // 标志记录
  451   1        for (i = 0; i < 6; i++)
  452   1        {
  453   2          if (xin[i] == 0)
  454   2          {
  455   3            if (flag[i] == 0) // 代表按键第一次按下。。。
  456   3            {
  457   4              flag[i] = 1;
  458   4              keydown(i);
  459   4            }
  460   3          }
  461   2          if (xin[i] == 1)
  462   2          {
  463   3            if (flag[i] == 1) // 代表下去了又上来
  464   3            {
  465   4              keyup(i);
  466   4            }
  467   3            flag[i] = 0;
  468   3            
  469   3          }
  470   2        }
  471   1      }
  472          void dealorder();
  473          void getdianliupre()
  474          {
  475   1      
  476   1      }
  477          int timereport=0;
  478          
  479          int errpromdizhi=0x000040;
  480          void writebuf()
  481          {
  482   1        u8 get[10];
  483   1        get[0]=55;
  484   1        get[1]=gsetzhi/100;
  485   1        get[2]=gsetzhi%100;
  486   1        EEPROM_SectorErase(errpromdizhi);
  487   1        EEPROM_write_n(errpromdizhi,get,3);
  488   1      }
  489          
  490          void readbuf()
  491          {
  492   1        u8 get[10];
  493   1      
  494   1          EEPROM_read_n(errpromdizhi,get,3);
  495   1          if(get[0]==55)
  496   1          {
  497   2              printf("has init\n");
  498   2          gsetzhi=get[1]*100+get[2];
  499   2          if(gsetzhi>=1023)
  500   2          {
  501   3            gsetzhi=1023;
  502   3          }
  503   2          if(gsetzhi<=0)
  504   2          {
  505   3            gsetzhi=0;
  506   3          }
  507   2          printf("has init %d-%d\n",get[1],get[2]);
  508   2          }
  509   1          else
  510   1          {
  511   2              printf("not init\n");
  512   2          get[0]=55;
  513   2          gsetzhi=550;
  514   2            EEPROM_write_n(errpromdizhi,get,1);
  515   2          }
C251 COMPILER V5.60.0,  main                                                               06/08/23  14:53:33  PAGE 9   

  516   1      }
  517          sbit keyled1=P3^6;
  518          sbit keyled2=P3^5;
  519          #define ledon 0
  520          #define ledclose 1
  521          void showled()
  522          {
  523   1        keyled1=ledclose;
  524   1        keyled2=ledclose;
  525   1        keyled2=ledon;
  526   1      }
  527          void delay_ms(int weizhi)
  528          {
  529   1      
  530   1      }
*** WARNING C47 IN LINE 527 OF main.c: 'weizhi': unreferenced parameter
  531          void fuwei()
  532          {
  533   1        IAP_CONTR=0x60;
  534   1      }
  535          
  536          int com2jixi2(char* input)
  537          {
  538   1        char flagTrue=0;
  539   1        char *p=input;
  540   1        char *p1;
  541   1        int i;
  542   1        int weizhi;
  543   1        int zhi;
  544   1        int bakweizhi;
  545   1        int bakzhi;
  546   1        for( i=0;i<100;i++)
  547   1        {
  548   2          p1=myaddstrstr(p,";"); //找有没有下一个的
  549   2          if(p1==NULL)
  550   2          {
  551   3            break;
  552   3          }
  553   2          weizhi = atoi(p);
  554   2          p=myaddstrstr(p,"-");
  555   2          zhi = atoi(p);
  556   2              if(i%2==0)
  557   2              {
  558   3                  bakweizhi=weizhi;
  559   3                  bakzhi=zhi;
  560   3              }
  561   2              if(i%2==1)
  562   2              {
  563   3                  if(weizhi==bakweizhi && bakzhi==zhi)
  564   3                  {
  565   4                      VectorPush(VectorDiannao,weizhi,zhi);
  566   4              flagTrue=1;
  567   4                  }
  568   3                  else
  569   3                  {
  570   4              flagTrue=0;
  571   4                      printf("get failed");
  572   4                  }
  573   3              }
  574   2          p=myaddstrstr(p,";");  //指向下一个后面
  575   2        }
  576   1        return flagTrue;
  577   1      }
  578          
  579          int  com2jiexi(char* input)
  580          {
C251 COMPILER V5.60.0,  main                                                               06/08/23  14:53:33  PAGE 10  

  581   1        char par[1000]={0};
  582   1        char *begin,*end;
  583   1        begin=myaddstrstr(input,"set:");
  584   1        end=myaddstrstr(begin,"end");
  585   1        if(begin!=NULL && end!=NULL)
  586   1        {
  587   2          strcpy(par,begin);
  588   2          return com2jixi2(par);
  589   2        }
  590   1        return 0;
  591   1      }
  592          
  593          
  594          int flag_canset=0;
  595          int precom2check(char *input)
  596          {
  597   1        char *p;
  598   1        p=mystrstr(input,"ruibaokesettingmimaflag"); //找有没有下一个的)
  599   1        if(p!=NULL)
  600   1        {
  601   2          print2("passwd checkpass,you can set now\n");
  602   2          print2("\n");
  603   2          print2("初始电流值 20\n");
  604   2          print2("已使用寿命 21\n");
  605   2          print2("总寿命 22\n");
  606   2          print2("最大电流值 23\n");
  607   2          print2("使用方式 set:20-601;20-601;end\n");
  608   2          flag_canset=1;
  609   2          return 1;
  610   2        }
  611   1        p=mystrstr(input,"fuwei()"); //找有没有下一个的)
  612   1        if(p!=NULL)
  613   1        {
  614   2          fuwei();
  615   2        }
  616   1        return 0;
  617   1      }
  618          
  619          void dealDiannaoOrder()
  620          {
  621   1      
  622   1      }
  623          void diannaoinputset()
  624          {
  625   1        int i;
  626   1        if(1==precom2check(rec2))
  627   1        {
  628   2          return ;
  629   2        }
  630   1        if(VectorIsEmpty(VectorDiannao))
  631   1        {
  632   2          print2("oder format error,pleas check\n");
  633   2          return ;
  634   2        }
  635   1        for(i=0;i<10;i++)
  636   1        {
  637   2          dealDiannaoOrder(); //com过来的电脑命令解析。。。
  638   2        }
  639   1        // ShowInfoToDiannan(1);
  640   1      }
  641          void diannaocheck()
  642          {
  643   1        if(weizhi2==0)
  644   1        {
  645   2          return ;
  646   2        }
C251 COMPILER V5.60.0,  main                                                               06/08/23  14:53:33  PAGE 11  

  647   1        delay_ms(2);
  648   1        memset(rec2, 0, sizeof(rec2));
  649   1        weizhi2 = 0;
  650   1      }
  651          void main(void)
  652          {
  653   1        SYS_Ini();    // STC32初始化设置
  654   1        PWM_Config(); // PWM初始化设置
  655   1        EA = 1;     // 使能EA总中断
  656   1      
  657   1        UartInit();
  658   1        Uart23Init();
  659   1        printf1("system is ok");
  660   1        Timer0Init();
  661   1        printf1("system is overall");
  662   1        
  663   1        keyallchuli();
  664   1        flaginit=1;
  665   1        setzhione(4,0);
  666   1        // test3();
  667   1        readbuf();
  668   1        // 没有什么时序时序要求，，指点函数里面做算了。。
  669   1        // 算了，之前都写成这样了。。不改了。。原有逻辑上面改改就行吧，，
  670   1        while (1)
  671   1        {
  672   2          showled();
  673   2          keyallchuli();
  674   2          showpre(gsetzhi);
  675   2          dealorder();//取缓冲区里面的命令进行发送
  676   2          
  677   2        }
  678   1      }
  679          
  680          void PWM_ISR() interrupt 26
  681          {
  682   1        if (PWMA_SR1 & 0X02) // 当捕获中断标志置1
  683   1        {
  684   2          cnt_H = PWMA_CCR1H; // 读取计数值高8位
  685   2          cnt_L = PWMA_CCR1L; // 读取计数值低8位
  686   2          PWMA_SR1 &= ~0X02;  // 清零捕获中断标志
  687   2          EC11_Handle();    // 处理EC11数据
  688   2        }
  689   1      }
  690          void PWM_Config() // PWM初始化设置
  691          {
  692   1        PWMA_CCER1 = 0x00; // 关闭通道
  693   1        PWMA_CCMR1 = 0xA1; // 通道模式配置为输入，接编码器 , 滤波器 80 时钟
  694   1        PWMA_CCMR2 = 0xA1; // 通道模式配置为输入，接编码器 , 滤波器 80 时钟
  695   1        PWMA_CCER1 = 0x55; // 使能捕获/比较通道1、通道2
  696   1      
  697   1        //  PWMA_SMCR = 0x01;         // 编码器模式 1
  698   1        //  PWMA_SMCR = 0x02;         // 编码器模式 2
  699   1        PWMA_SMCR = 0x03; // 编码器模式 3
  700   1      
  701   1        PWMA_IER = 0x02;  // 使能中断
  702   1        PWMA_CR1 |= 0x01; // 使能计数器
  703   1        PWMA_PS |= 0x04;  // 选择 PWM2_2 通道
  704   1      }
  705          
  706          // 返回变化的步数
  707          long calculateChange(unsigned int previous, unsigned int current)
  708          {
  709   1        long diff = (current - previous + 65536) % 65536;
*** WARNING C188 IN LINE 709 OF main.c: 'initialization': value truncated
  710   1        return diff;
  711   1      }
C251 COMPILER V5.60.0,  main                                                               06/08/23  14:53:33  PAGE 12  

  712          
  713          
  714          char flag3 = 0;
  715          int timeleft1, timeleft2, timeleft3, timeleft4;
  716          void chuankou1put(char c)
  717          {
  718   1        rec2[weizhi2++] = c;
  719   1        if (weizhi2 > sizeof(rec2) - 3)
  720   1          weizhi2 = 0;
  721   1        // timeleft3 = 3;
  722   1      }
  723          void chuankou1time()
  724          {
  725   1        if (timeleft3 > 0)
  726   1        {
  727   2          timeleft3--;
  728   2          if (timeleft3 == 0) // 数据一次收完了.
  729   2          {
  730   3            flag3 = 1;
  731   3          }
  732   2        }
  733   1      }
  734          char get1[100];
  735          int weizhi1=0;
  736          void chuliguankji(char *get1)
  737          {
  738   1          char* index;
  739   1          index=mystrstr(get1,"@STCISP#");
  740   1        if(index==0)
  741   1        {
  742   2            return  ;
  743   2        }
  744   1          IAP_CONTR=0x60;
  745   1      }
  746          
  747          void addgetsetzhi(int i)
  748          {
  749   1        int ans;
  750   1        ans=gsetzhi+i;
  751   1        if(ans>=0 && ans<=1023)
  752   1        {
  753   2          gsetzhi=ans;
  754   2        }
  755   1      }
  756          static int timepush=0;
  757          void dealorder()
  758          {
  759   1        char out[30]={0};
  760   1        Alltongxininfo get;
  761   1        if(timepush>45)
  762   1        {
  763   2          timepush=0;
  764   2          pop2(&get);
  765   2          if(get.weizhi==4)
  766   2          {
  767   3            get.zhi=get.zhi*bili;
  768   3          }
  769   2          sprintf(out,"set:%d-%d;end",get.weizhi,get.zhi);
  770   2          printf3(out);
  771   2          printf(out);
  772   2        }
  773   1      }
  774          void Timer0() interrupt 1
  775          {
  776   1        timereport++;
  777   1        shurulvbo();
C251 COMPILER V5.60.0,  main                                                               06/08/23  14:53:33  PAGE 13  

  778   1        chuankou1time();
  779   1        if(!empty())
*** WARNING C140 IN LINE 779 OF main.c: 'empty' undefined; assuming 'extern int empty()'
  780   1        {
  781   2          timepush++;
  782   2        }
  783   1      }
  784          void EC11_Handle() // EC11数据处理函数
  785          {
  786   1        static unsigned int previous = 0;
  787   1        unsigned int nowzhi;
  788   1        long ans;
  789   1        nowzhi = cnt_H * 256 + cnt_L; // 读取当前计数值
  790   1        ans = calculateChange(previous, nowzhi);
  791   1        previous = nowzhi;
  792   1        if(flagsetliangdu==1)
  793   1        {
  794   2          if (ans == 4)
  795   2          {
  796   3            addgetsetzhi(1);
  797   3          }
  798   2          else
  799   2          {
  800   3            addgetsetzhi(-1);
  801   3          }
  802   2          // 设定电流值。。。
  803   2          setzhione(4,gsetzhi);
  804   2          // setzhione(2,1);//开灯。。
  805   2        }
  806   1        
  807   1      }
  808          
  809          int step=0;
  810          void showstep(const char *s)
  811          {
  812   1        printf1("%s\n",s);
  813   1      }
  814          char* my_strstr(const char* haystack, const char* needle) {
  815   1          if (*needle == '\0') {
  816   2              return (char*) haystack;
  817   2          }
  818   1      
  819   1          while (*haystack != '\0') {
  820   2              const char* h = haystack;
  821   2              const char* n = needle;
  822   2      
  823   2              while (*h == *n && *n != '\0') {
  824   3                  h++;
  825   3                  n++;
  826   3              }
  827   2      
  828   2              if (*n == '\0') {
  829   3                  return (char*) haystack;
  830   3              }
  831   2      
  832   2              haystack++;
  833   2          }
  834   1      
  835   1          return NULL;
  836   1      }
  837          
  838          void dealchuankou()
  839          {
  840   1      
  841   1      }
  842          
C251 COMPILER V5.60.0,  main                                                               06/08/23  14:53:33  PAGE 14  

  843          void UARTInterrupt(void) interrupt 4
  844          {
  845   1        unsigned char ans;
  846   1        if (RI)
  847   1        {
  848   2          RI = 0;
  849   2          ans = SBUF;
  850   2          get1[weizhi1++]=ans;
  851   2          if(weizhi1>80)
  852   2          {
  853   3            weizhi1=0;
  854   3          }
  855   2          chuliguankji(get1);
  856   2          chuankou1put(ans);
  857   2        }
  858   1        else
  859   1        {
  860   2          TI = 0;
  861   2        }
  862   1        if (TI) // 发送中断..
  863   1        {
  864   2          TI = 0;
  865   2        }
  866   1      }
  867          void Uart3() interrupt 17 using 1
  868          {
  869   1        char temp3; 
  870   1          if (S3CON & S3RI)
  871   1          {
  872   2              S3CON &= ~S3RI; //??S3RI?
  873   2          temp3 = S3BUF;
  874   2          }
  875   1          if (S3CON & S3TI)
  876   1          {
  877   2              S3CON &= ~S3TI; // 清除S3TI位
  878   2              busy3 = 0;      // 清忙标志
  879   2          }
  880   1      }
  881          
  882          // 写个函数，传入两个非负数，计算是前进还是后退了，变化规律 15,16,0,1,2...15,16


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3242     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       985       1881
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      2247     ------
End of Module Information.


C251 COMPILATION COMPLETE.  7 WARNING(S),  0 ERROR(S)
