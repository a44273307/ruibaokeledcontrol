C51 COMPILER V9.05   MAIN                                                                  06/04/2023 09:13:38 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /************************************************************************************
   2             
   3          程序名称： （晶振频率18.432MHz） 
   4          功能说明: 通过串口3发送“Everything is possible!”  
   5                    波特率9600，数据位8，奇偶效验无，停止位1，数据流控制无  
   6          ************************************************************************************/
   7          #include "stc15f2k60s2.h"           // 单片机STC15F2K60S2头文件,可以不再加入reg51.h
   8          #include <intrins.h>                                    // 加入此头文件后,可使用_nop_库函数
   9          #include "delay.h"                      // 延时函数头文件
  10          #include "uart.h"                               // 串行通信函数头文件
  11          #define  uint unsigned int  
  12          #define  uchar unsigned char    
  13          #include <stdio.h>
  14          #include <string.h>
  15          #include "MODBUS.h"
  16          
  17          #include <stdio.h>
  18          #include <string.h>
  19          #include <stdlib.h>
  20          
  21          bit busy;
  22          
  23          
  24          uint temp1,temp2,temp3,temp4;
  25          
  26          
  27          
  28          
  29          //sbit x0 = P4^3;
  30          //sbit x1 = P4^4; 
  31          //sbit x2 = P2^0; 
  32          //sbit x3 = P2^1;  
  33          //sbit x4 = P2^2;  
  34          //sbit x5 = P2^3;
  35          //sbit x6 = P2^4; 
  36          //sbit x7 = P2^5;
  37          //sbit x10 = P2^6;
  38          //sbit x11 = P2^7; 
  39          //sbit x12 = P4^5;
  40          //sbit x13 = P4^6;
  41          
  42          sbit x0 = P2^4; 
  43          sbit x1 = P2^5; 
  44          
  45          
  46          sbit x2 = P2^6;  
  47          sbit x3 = P2^7;
  48          
  49          sbit x4 = P4^5; 
  50          sbit x5 = P4^6;
  51          
  52          sbit x6 = P0^2;
  53          sbit x7 = P0^3; 
  54          
  55          sbit x8 = P0^4; 
C51 COMPILER V9.05   MAIN                                                                  06/04/2023 09:13:38 PAGE 2   

  56          sbit x9 = P5^2;
  57          
  58          
  59          
  60          
  61          sbit y0 = P2^3;  
  62          sbit y1 = P2^2; 
  63          sbit y2 = P2^1;
  64          sbit y3 = P2^0;
  65          sbit y4 = P4^4;
  66          sbit y5 = P4^3;
  67          
  68          
  69          
  70          void printf2(char *puts)
  71          {
  72   1               while(*puts) 
  73   1              {
  74   2                      sendbyte2(*puts);
  75   2                      puts++;
  76   2              }
  77   1      }
  78          
  79          void io_inint()
  80          {
  81   1              P0M1 = 0;       P0M0 = 0;       //设置P0.0~P0.7为准双向口
  82   1                  P1M0 = 0x00;                                //设置P1.0为ADC口
  83   1          P1M1 = 0x80;
  84   1      
  85   1      
  86   1              // P1M1 = 0;    P1M0 = 0;       //设置P1.0~P1.7为准双向口
  87   1              P2M1 = 0;       P2M0 = 0;       //设置P2.0~P2.7为准双向口 
  88   1                  P3M0 = 0;
  89   1          P3M1 = 0;
  90   1              P4M1 = 0;       P4M0 = 0;       //设置P4.0~P4.7为准双向口
  91   1              P5M1 = 0;       P5M0 = 0;       //设置P5.0~P5.7为准双向口
  92   1      }
  93          
  94          
  95          
  96          
  97          int xinget(int zhi)
  98          {
  99   1              if(zhi==0) return x0;
 100   1              if(zhi==1) return x1;
 101   1              if(zhi==2) return x2;
 102   1              if(zhi==3) return x3;
 103   1              if(zhi==4) return x4;
 104   1              if(zhi==5) return x5;
 105   1              if(zhi==6) return x6;
 106   1              if(zhi==7) return x7;
 107   1              if(zhi==8) return x8;
 108   1              if(zhi==9) return x9;
 109   1      }
 110          void getxin()
 111          {
 112   1              int i;
 113   1              char datatmp[10];
 114   1              for(i=0;i<10;i++)
 115   1              {
 116   2                      sprintf(datatmp,"x%d %d\n",i,xinget(i));
 117   2                      PrintString(datatmp);
C51 COMPILER V9.05   MAIN                                                                  06/04/2023 09:13:38 PAGE 3   

 118   2              }
 119   1      }
 120          void Delay1ms()         //@24.000MHz
 121          {
 122   1              unsigned char i, j;
 123   1      
 124   1              i = 24;
 125   1              j = 85;
 126   1              do
 127   1              {
 128   2                      while (--j);
 129   2              } while (--i);
 130   1      }
 131          
 132          void delay_ms(int m)
 133          {
 134   1              int x;
 135   1              for(x=m;x>0;x--)
 136   1              {
 137   2                      Delay1ms();
 138   2              }
 139   1              
 140   1      }
 141          void Start()
 142          {uint i=0;
 143   1          busy = 1;
 144   1          I2CMSCR = 0x81;                             //发送START命令
 145   1          while (busy&&i<6000)i++;
 146   1      }
 147          
 148          void SendData(char dat)
 149          {uint i=0;
 150   1          I2CTXD = dat;                               //写数据到数据缓冲区
 151   1          busy = 1;
 152   1          I2CMSCR = 0x82;                             //发送SEND命令
 153   1          while (busy&&i<6000)i++;
 154   1      }
 155          
 156          void RecvACK()
 157          {uint i=0;
 158   1          busy = 1;
 159   1          I2CMSCR = 0x83;                             //发送读ACK命令
 160   1          while (busy&&i<6000)i++;
 161   1      }
 162          
 163          char RecvData()
 164          {uint i=0;
 165   1          busy = 1;
 166   1          I2CMSCR = 0x84;                             //发送RECV命令
 167   1          while (busy&&i<6000)i++;
 168   1          return I2CRXD;
 169   1      }
 170          
 171          void SendACK()
 172          {uint i=0;
 173   1          I2CMSST = 0x00;                             //设置ACK信号
 174   1          busy = 1;
 175   1          I2CMSCR = 0x85;                             //发送ACK命令
 176   1          while (busy&&i<6000)i++;
 177   1      }
 178          
 179          void SendNAK()
C51 COMPILER V9.05   MAIN                                                                  06/04/2023 09:13:38 PAGE 4   

 180          {uint i=0;
 181   1          I2CMSST = 0x01;                             //设置NAK信号
 182   1          busy = 1;
 183   1          I2CMSCR = 0x85;                             //发送ACK命令
 184   1          while (busy&&i<6000)i++;
 185   1      }
 186          
 187          void Stop()
 188          {uint i=0;
 189   1          busy = 1;
 190   1          I2CMSCR = 0x86;                             //发送STOP命令
 191   1          while (busy&&i<6000)i++;
 192   1      }
 193          void I2C_Isr() interrupt 24
 194          {
 195   1          _push_(P_SW2);
 196   1          P_SW2 |= 0x80;
 197   1          if (I2CMSST & 0x40)
 198   1          {
 199   2              I2CMSST &= ~0x40;                       //清中断标志
 200   2              busy = 0;
 201   2          }
 202   1          _pop_(P_SW2);
 203   1      }
 204          sbit out1=P1^6;  //
 205          sbit out2=P3^2;
 206          void deanyan()
 207           {  
 208   1              int sw1=2000;
 209   1              int sw2=3000;
 210   1              Start();                                    //发送起始命令
 211   1          SendData(0xc2);                             //发送设备地址+写命令
 212   1          RecvACK();
 213   1          SendData(0x60);                             //发送存储地址高字节
 214   1          RecvACK();
 215   1          SendData(sw1/16);                             //发送存储地址低字节
 216   1          RecvACK();
 217   1          SendData((sw1%16)<<4);                             //写测试数据1
 218   1          RecvACK();
 219   1          Stop();                                     //发送停止命令
 220   1      
 221   1          Start();                                    //发送起始命令
 222   1          SendData(0xc0);                             //发送设备地址+写命令
 223   1          RecvACK();
 224   1          SendData(0x60);                             //发送存储地址高字节
 225   1          RecvACK();
 226   1          SendData(sw2/16);                             //发送存储地址低字节
 227   1          RecvACK();
 228   1          SendData((sw2%16)<<4);                             //写测试数据1
 229   1          RecvACK();
 230   1          Stop();
 231   1                      
 232   1                      Start();                                    //发送起始命令
 233   1          SendData(0xc2);                             //发送设备地址+写命令
 234   1          RecvACK();
 235   1          SendData(0x60);                             //发送存储地址高字节
 236   1          RecvACK();
 237   1          SendData(sw1/16);                             //发送存储地址低字节
 238   1          RecvACK();
 239   1          SendData((sw1%16)<<4);                             //写测试数据1
 240   1          RecvACK();
 241   1          Stop();                                     //发送停止命令
C51 COMPILER V9.05   MAIN                                                                  06/04/2023 09:13:38 PAGE 5   

 242   1      
 243   1          Start();                                    //发送起始命令
 244   1          SendData(0xc0);                             //发送设备地址+写命令
 245   1          RecvACK();
 246   1          SendData(0x60);                             //发送存储地址高字节
 247   1          RecvACK();
 248   1          SendData(sw2/16);                             //发送存储地址低字节
 249   1          RecvACK();
 250   1          SendData((sw2%16)<<4);                             //写测试数据1
 251   1          RecvACK();
 252   1          Stop();
 253   1              
 254   1                        
 255   1       }
 256          void main()                                                    
 257          {
 258   1              
 259   1              io_inint();
 260   1              Uart23Init();
 261   1              
 262   1              
 263   1              Timer0Init();
 264   1              UartInit();
 265   1              
 266   1              Uart4Init();
 267   1              PrintString("system is ok\n");
 268   1              P_SW2 = 0x80;
 269   1          I2CCFG = 0xe0;                              //使能I2C主机模式
 270   1          I2CMSST = 0x00;
 271   1               EA = 1;
 272   1              out2=1;
 273   1              delay_ms(10);
 274   1              Modbus_ClearBuff();
 275   1      delay_ms(200);
 276   1      deanyan();
 277   1              while (1)
 278   1              {
 279   2                      delay_ms(2);
 280   2                      // printf("0000000000");
 281   2                      if(recover==1)
 282   2                      {
 283   3                              // deanyan();
 284   3                              jishouokjisuan();
 285   3                              recover=0;
 286   3                      }
 287   2              }
 288   1      }
 289                   
 290                   
 291          
 292          
 293          
 294          void Timer0() interrupt 1
 295          {
 296   1              time1msjisuan();
 297   1      }
 298          char buf1[100]={0};
 299          int weizhi1=0;
 300          void putchuankou1(char c)
 301          {
 302   1          
 303   1          buf1[weizhi1++]=c;
C51 COMPILER V9.05   MAIN                                                                  06/04/2023 09:13:38 PAGE 6   

 304   1          if(weizhi1>80)
 305   1          weizhi1=0;
 306   1      }
 307          void chuliguankji()
 308          {
 309   1          char* index;
 310   1          index=strstr(buf1,"@STCISP#");
 311   1              if(index==0)
 312   1              {
 313   2                      return  ;
 314   2              }
 315   1          IAP_CONTR=0x60;
 316   1          
 317   1      }
 318          void UARTInterrupt(void) interrupt 4
 319          {
 320   1              unsigned char ans;
 321   1              if (RI)
 322   1              {
 323   2                      RI = 0;
 324   2                      ans=SBUF;
 325   2              IAP_CONTR=0x60;
 326   2                      // putchuankou1(ans);
 327   2              // chuliguankji();
 328   2              }
 329   1              else
 330   1              {
 331   2                      TI = 0;
 332   2              }
 333   1              if (TI) //发送中断..
 334   1              {
 335   2                      TI = 0;
 336   2              }
 337   1      }
 338          
 339          void uart2(void ) interrupt 8 
 340          {
 341   1        if (S2CON & S2RI)
 342   1              {
 343   2                      S2CON &= ~S2RI;         
 344   2                      temp2 = S2BUF;
 345   2              }
 346   1        if (S2CON & S2TI)
 347   1          {
 348   2                              //y1=0;
 349   2              S2CON &= ~S2TI;         //清除S2TI位
 350   2              busy2 = 0;               //清忙标志
 351   2          }  
 352   1      }
 353          
 354            
 355          
 356          
 357          void Uart3() interrupt 17 using 1
 358          {
 359   1          if (S3CON & S3RI)
 360   1          {
 361   2              S3CON &= ~S3RI;         //??S3RI?
 362   2              temp3 = S3BUF;
 363   2                      chuankou1jisuuan(temp3);
 364   2         }
 365   1      if (S3CON & S3TI)
C51 COMPILER V9.05   MAIN                                                                  06/04/2023 09:13:38 PAGE 7   

 366   1          {
 367   2              S3CON &= ~S3TI;         //清除S3TI位
 368   2              busy3 = 0;               //清忙标志
 369   2          }
 370   1      }
 371          
 372          void Uart4() interrupt 18 
 373          {
 374   1          if (S4CON & S4RI)
 375   1          {
 376   2              S4CON &= ~S4RI;         //??S4RI?
 377   2              temp4=S4BUF;
 378   2         }
 379   1      if(TI4)
 380   1              {
 381   2                      CLR_TI4();
 382   2                      busy4 = 0;               //清忙标志
 383   2              }
 384   1      }
 385          
 386          
 387          
*** WARNING C291 IN LINE 109 OF main.c: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1174    ----
   CONSTANT SIZE    =     31    ----
   XDATA SIZE       =    110      18
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
