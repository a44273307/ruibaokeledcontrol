C251 COMPILER V5.60.0,  STC32G_UART_Isr                                                    19/09/23  21:23:38  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE STC32G_UART_Isr
OBJECT MODULE PLACED IN .\list\STC32G_UART_Isr.obj
COMPILER INVOKED BY: D:\keilc251\C251\BIN\C251.EXE ..\Driver\isr\STC32G_UART_Isr.c LARGE INTR2 ROM(HUGE) BROWSE INCDIR(.
                    -.\Driver\inc;..\User;..\App\inc) DEBUG PRINT(.\list\STC32G_UART_Isr.lst) TABS(2) OBJECT(.\list\STC32G_UART_Isr.obj) 

stmt  level    source

    1          /*---------------------------------------------------------------------*/
    2          /* --- STC MCU Limited ------------------------------------------------*/
    3          /* --- STC 1T Series MCU Demo Programme -------------------------------*/
    4          /* --- Mobile: (86)13922805190 ----------------------------------------*/
    5          /* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
    6          /* --- Tel: 86-0513-55012928,55012929,55012966 ------------------------*/
    7          /* --- Web: www.STCAI.com ---------------------------------------------*/
    8          /* --- Web: www.STCMCUDATA.com  ---------------------------------------*/
    9          /* --- BBS: www.STCAIMCU.com  -----------------------------------------*/
   10          /* --- QQ:  800003751 -------------------------------------------------*/
   11          /* 如果要在程序中使用此代码,请在程序中注明使用了STC的资料及程序            */
   12          /*---------------------------------------------------------------------*/
   13          
   14          #include "STC32G_UART.h"
   15          
   16          bit B_ULinRX1_Flag;
   17          bit B_ULinRX2_Flag;
   18          
   19          //========================================================================
   20          // 函数: UART1_ISR_Handler
   21          // 描述: UART1中断函数.
   22          // 参数: none.
   23          // 返回: none.
   24          // 版本: V1.0, 2020-09-23
   25          //========================================================================
   26          // #ifdef UART1
   27          // void UART1_ISR_Handler (void) interrupt UART1_VECTOR
   28          // {
   29          //  u8 Status;
   30          
   31          //  if(RI)
   32          //  {
   33          //    RI = 0;
   34          
   35          //    //--------USART LIN---------------
   36          //    Status = USARTCR5;
   37          //    if(Status & 0x02)     //if LIN header is detected
   38          //    {
   39          //      B_ULinRX1_Flag = 1;
   40          //    }
   41          
   42          //    if(Status & 0xc0)     //if LIN break is detected / LIN header error is detected
   43          //    {
   44          //      COM1.RX_Cnt = 0;
   45          //    }
   46          //    USARTCR5 &= ~0xcb;    //Clear flag
   47          //    //--------------------------------
   48              
   49          //         if(COM1.RX_Cnt >= COM_RX1_Lenth) COM1.RX_Cnt = 0;
   50          //         RX1_Buffer[COM1.RX_Cnt++] = SBUF;
   51          //         COM1.RX_TimeOut = TimeOutSet1;
   52          //  }
   53          
   54          //  if(TI)
   55          //  {
   56          //    TI = 0;
   57              
   58          //         #if(UART_QUEUE_MODE == 1)   //判断是否使用队列模式
C251 COMPILER V5.60.0,  STC32G_UART_Isr                                                    19/09/23  21:23:38  PAGE 2   

   59          //    if(COM1.TX_send != COM1.TX_write)
   60          //    {
   61          //      SBUF = TX1_Buffer[COM1.TX_send];
   62          //      if(++COM1.TX_send >= COM_TX1_Lenth)   COM1.TX_send = 0;
   63          //    }
   64          //    else  COM1.B_TX_busy = 0;
   65          //         #else
   66          //         COM1.B_TX_busy = 0;     //使用阻塞方式发送直接清除繁忙标志
   67          //         #endif
   68          //  }
   69          // }
   70          // #endif
   71          
   72          // //========================================================================
   73          // // 函数: UART2_ISR_Handler
   74          // // 描述: UART2中断函数.
   75          // // 参数: none.
   76          // // 返回: none.
   77          // // 版本: V1.0, 2020-09-23
   78          // //========================================================================
   79          // #ifdef UART2
   80          // void UART2_ISR_Handler (void) interrupt UART2_VECTOR
   81          // {
   82          //  u8 Status;
   83          
   84          //  if(S2RI)
   85          //  {
   86          //    CLR_RI2();
   87          
   88          //    //--------USART LIN---------------
   89          //    Status = USART2CR5;
   90          //    if(Status & 0x02)     //if LIN header is detected
   91          //    {
   92          //      B_ULinRX2_Flag = 1;
   93          //    }
   94          
   95          //    if(Status & 0xc0)     //if LIN break is detected / LIN header error is detected
   96          //    {
   97          //      COM2.RX_Cnt = 0;
   98          //    }
   99          //    USART2CR5 &= ~0xcb;   //Clear flag
  100          //    //--------------------------------
  101              
  102          //         if(COM2.RX_Cnt >= COM_RX2_Lenth) COM2.RX_Cnt = 0;
  103          //         RX2_Buffer[COM2.RX_Cnt++] = S2BUF;
  104          //         COM2.RX_TimeOut = TimeOutSet2;
  105          //  }
  106          
  107          //  if(S2TI)
  108          //  {
  109          //    CLR_TI2();
  110              
  111          //         #if(UART_QUEUE_MODE == 1)   //判断是否使用队列模式
  112          //    if(COM2.TX_send != COM2.TX_write)
  113          //    {
  114          //      S2BUF = TX2_Buffer[COM2.TX_send];
  115          //      if(++COM2.TX_send >= COM_TX2_Lenth)   COM2.TX_send = 0;
  116          //    }
  117          //    else  COM2.B_TX_busy = 0;
  118          //         #else
  119          //         COM2.B_TX_busy = 0;     //使用阻塞方式发送直接清除繁忙标志
  120          //         #endif
  121          //  }
  122          // }
  123          // #endif
  124          
C251 COMPILER V5.60.0,  STC32G_UART_Isr                                                    19/09/23  21:23:38  PAGE 3   

  125          // //========================================================================
  126          // // 函数: UART3_ISR_Handler
  127          // // 描述: UART3中断函数.
  128          // // 参数: none.
  129          // // 返回: none.
  130          // // 版本: V1.0, 2020-09-23
  131          // //========================================================================
  132          // #ifdef UART3
  133          // void UART3_ISR_Handler (void) interrupt UART3_VECTOR
  134          // {
  135          //  if(S3RI)
  136          //  {
  137          //    CLR_RI3();
  138          
  139          //         if(COM3.RX_Cnt >= COM_RX3_Lenth) COM3.RX_Cnt = 0;
  140          //         RX3_Buffer[COM3.RX_Cnt++] = S3BUF;
  141          //         COM3.RX_TimeOut = TimeOutSet3;
  142          //  }
  143          
  144          //  if(S3TI)
  145          //  {
  146          //    CLR_TI3();
  147              
  148          //         #if(UART_QUEUE_MODE == 1)   //判断是否使用队列模式
  149          //    if(COM3.TX_send != COM3.TX_write)
  150          //    {
  151          //      S3BUF = TX3_Buffer[COM3.TX_send];
  152          //      if(++COM3.TX_send >= COM_TX3_Lenth)   COM3.TX_send = 0;
  153          //    }
  154          //    else  COM3.B_TX_busy = 0;
  155          //         #else
  156          //         COM3.B_TX_busy = 0;     //使用阻塞方式发送直接清除繁忙标志
  157          //         #endif
  158          //  }
  159          // }
  160          // #endif
  161          
  162          // //========================================================================
  163          // // 函数: UART4_ISR_Handler
  164          // // 描述: UART4中断函数.
  165          // // 参数: none.
  166          // // 返回: none.
  167          // // 版本: V1.0, 2020-09-23
  168          // //========================================================================
  169          // #ifdef UART4
  170          // void UART4_ISR_Handler (void) interrupt UART4_VECTOR
  171          // {
  172          //  if(S4RI)
  173          //  {
  174          //    CLR_RI4();
  175          
  176          //         if(COM4.RX_Cnt >= COM_RX4_Lenth) COM4.RX_Cnt = 0;
  177          //         RX4_Buffer[COM4.RX_Cnt++] = S4BUF;
  178          //         COM4.RX_TimeOut = TimeOutSet4;
  179          //  }
  180          
  181          //  if(S4TI)
  182          //  {
  183          //    CLR_TI4();
  184              
  185          //         #if(UART_QUEUE_MODE == 1)   //判断是否使用队列模式
  186          //    if(COM4.TX_send != COM4.TX_write)
  187          //    {
  188          //      S4BUF = TX4_Buffer[COM4.TX_send];
  189          //      if(++COM4.TX_send >= COM_TX4_Lenth)   COM4.TX_send = 0;
  190          //    }
C251 COMPILER V5.60.0,  STC32G_UART_Isr                                                    19/09/23  21:23:38  PAGE 4   

  191          //    else  COM4.B_TX_busy = 0;
  192          //         #else
  193          //         COM4.B_TX_busy = 0;     //使用阻塞方式发送直接清除繁忙标志
  194          //         #endif
  195          //  }
  196          // }
  197          //#endif


Module Information          Static   Overlayable
------------------------------------------------
  code size            =    ------     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =         2     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
